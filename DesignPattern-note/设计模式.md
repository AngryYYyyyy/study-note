# 一、UML图

类图（Class Diagram）是统一建模语言（UML, Unified Modeling Language）中的一种图形，用于展示系统中的类、类之间的关系以及类的内部结构。它是面向对象分析和设计过程中最常用的图形之一。类图不仅有助于软件开发过程中的设计和文档化，也有助于团队成员之间的沟通。

## 1.类

![image-20240617225140851](./assets/image-20240617225140851.png)

### （1）矩形框

- **顶部**：显示类的名称，如果是抽象类，则名称是斜体。
- **中部**：显示类的属性或成员变量。
- **底部**：显示类的方法或成员函数。

### （2）修饰符

- “+” 表示 `public`；
- “-” 表示 `private`；
- “#” 表示 `protected`；
- 不带符号表示 `default`。

## 2.接口

接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 <<interface>>表示，下面是接口的名字，第二层是方法。

![image-20240617225236131](./assets/image-20240617225236131.png)

## 3.关系表示

![image-20240617225305024](./assets/image-20240617225305024.png)

# 二、创建型模式

## 1.单例模式

### （1）概述

单例模式保证某个类在运行期间，只有一个实例，并为该实例提供一个全局访问节点，而这个类被称为单例类。

![image-20240617225812112](./assets/image-20240617225812112.png)

### （2）饿汉模式

饿汉式单例模式是一种在类加载时就完成实例化并初始化好静态实例的方法，以确保实例的唯一性和线程安全。这种方法利用了Java类加载机制，确保实例只被创建一次。

**实现：**

```java
public class Singleton {
    // 在类加载时就初始化一个静态私有实例
    private static final Singleton instance = new Singleton();

    // 私有构造函数，防止外部创建实例
    private Singleton() {}

    // 提供一个公共的静态方法，返回唯一实例
    public static Singleton getInstance() {
        return instance;
    }
}

```

**特点**

- **线程安全**：由于单例的唯一实例是在类加载时创建的，这一过程由JVM执行，因此不会出现线程安全问题。
- **无延迟加载**：实例在类加载时就已创建，因此不存在延迟加载的选项。这样做的好处是避免了调用 `getInstance()` 方法时的任何类型的同步延迟，但是也可能导致资源利用率降低。
- **资源消耗**：如果实例创建过程中涉及重资源分配，或实例占用明显的内存空间，且该实例的使用频率并不高，那么这种模式可能导致资源的浪费。

### （3）懒汉模式（DCL）

双重校验锁模式（Double-Check Locking）是懒汉模式的一个改进版本，用于减少获取对象的成本和提高性能，同时保持线程安全。这种方式首先检查实例是否已经创建，如果尚未创建，才进行同步。这种方法可以大大减少 `getInstance()` 的时间消耗。

**实现：**

```java
public class LazySingleton {
    // 使用 volatile 关键字保证可见性和禁止指令重排序
    private static volatile LazySingleton instance;

    // 私有构造函数，防止外部实例化
    private LazySingleton() {}

    // 公共的获取实例方法，实现双重校验锁
    public static LazySingleton getInstance() {
        if (instance == null) { // 第一次检查：避免不必要的同步
            synchronized (LazySingleton.class) { // 同步
                if (instance == null) { // 第二次检查：在null的情况下创建实例
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}

```

**特点**

- **线程安全**：通过同步代码块减少了同步的开销，只在第一次创建实例时才同步，提高了效率。
- **延迟加载**：实例在首次使用时创建，优化了资源的使用。
- **资源优化**：避免了在应用启动时就创建对象，减轻了启动负担。

**注意事项**

- **volatile 关键字**：`instance` 需要被声明为 `volatile`，这样可以防止 JVM 的指令重排，确保在对象被初始化之后才将引用指向内存空间，从而保证线程安全。
- **性能考虑**：虽然双重校验锁比普通锁性能更好，但在极高并发的情况下仍然会有性能瓶颈。

## 2.工厂方法模式

### （1）概述

工厂方法模式是一种创建型设计模式，它定义了一个创建对象的接口，但将实际的对象创建工作推迟到实现类中完成。这样的设计模式让类的实例化操作延迟到其实现类，通过这种方式，工厂方法模式解决了接口选择的问题，使一个类不需要知道它所创建的对象的具体类。

### （2）组成

- **抽象产品（Product）**:定义了产品的接口，是工厂方法创建的对象所必须遵守的模型。抽象产品可以是一个接口或抽象类，由具体产品类实现或继承。
- **具体产品（Concrete Product）**:实现或继承抽象产品的具体类。每一个具体产品类都对应一个特定的实际产品。
- **抽象工厂（Factory）**:声明工厂方法，该方法返回一个抽象产品。创建者通常是一个接口，包含调用工厂方法以返回产品对象的代码。
- **具体工厂（Concrete Factory）**:实现抽象工厂中定义的工厂方法，返回一个具体产品实例。具体工厂决定如何创建产品，以及要创建哪些产品。

### （3）类图结构

![image-20240617233031139](./assets/image-20240617233031139.png)

### （4）示例

```java
// 抽象产品
public interface Product {
    void operate();
}

// 具体产品A
public class ConcreteProductA implements Product {
    @Override
    public void operate() {
        System.out.println("ConcreteProductA operating.");
    }
}

// 具体产品B
public class ConcreteProductB implements Product {
    @Override
    public void operate() {
        System.out.println("ConcreteProductB operating.");
    }
}

// 抽象工厂
public interface  Factory {
    // 声明工厂方法
    Product factoryMethod();
}

// 具体工厂A
public class ConcreteFactoryA implements Factory {
    @Override
    public Product factoryMethod() {
        return new ConcreteProductA();
    }
}

// 具体工厂B
public class ConcreteFactoryB implements Factory {
    @Override
    public Product factoryMethod() {
        return new ConcreteProductB();
    }
}

```



## 3.抽象工厂模式

### （1）概述

抽象工厂模式是一种创建型设计模式，用于处理具有相同（或相似）主题的产品族而无需指定具体类的情况。这个模式提供了一个接口，用来创建一系列相关或相互依赖的对象，而不需要指定它们具体的类。

### （2）产品等级结构与产品族

- **产品等级结构** ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

- **产品族** ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

![image-20240617233446309](./assets/image-20240617233446309.png)

### （3）组成

- **抽象工厂（Abstract Factory）**:提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
- **具体工厂（Concrete Factory）**:实现抽象工厂的操作，生成具体的产品。
- **抽象产品（Abstract Product）**:为一类产品对象声明一个接口。
- **具体产品（Concrete Product）**:抽象产品的具体实现。这些定义了具体工厂生产的具体产品对象，实现抽象产品定义的接口。

### （4）类图结构

![image-20240617234505335](./assets/image-20240617234505335.png)

### （5）示例

```java
// 抽象产品A
public interface ProductA {
    void useA();
}

// 抽象产品B
public interface ProductB {
    void useB();
}

// 具体产品A1
public class ProductA1 implements ProductA {
    @Override
    public void useA() {
        System.out.println("Using Product A1");
    }
}

// 具体产品B1
public class ProductB1 implements ProductB {
    @Override
    public void useB() {
        System.out.println("Using Product B1");
    }
}

// 具体产品A2
public class ProductA2 implements ProductA {
    @Override
    public void useA() {
        System.out.println("Using Product A2");
    }
}

// 具体产品B2
public class ProductB2 implements ProductB {
    @Override
    public void useB() {
        System.out.println("Using Product B2");
    }
}

// 抽象工厂
public interface AbstractFactory {
    ProductA createProductA();
    ProductB createProductB();
}

// 具体工厂1
public class ConcreteFactory1 implements AbstractFactory {
    @Override
    public ProductA createProductA() {
        return new ProductA1();
    }

    @Override
    public ProductB createProductB() {
        return new ProductB1();
    }
}

// 具体工厂2
public class ConcreteFactory2 implements AbstractFactory {
    @Override
    public ProductA createProductA() {
        return new ProductA2();
    }

    @Override
    public ProductB createProductB() {
        return new ProductB2();
    }
}

// 客户端代码
public class Client {
    private ProductA productA;
    private ProductB productB;

    public Client(AbstractFactory factory) {
        productA = factory.createProductA();
        productB = factory.createProductB();
    }

    public void useProducts() {
        productA.useA();
        productB.useB();
    }
}

```



## 4.建造者模式

### （1）概述

建造者模式是一种创建型设计模式，它提供了一种创建复杂对象的最佳方式。该模式允许你将一个复杂对象的构建过程从其表示中分离出来，使得同样的构建过程可以创建不同的表示。这种模式通常用于设计一个复杂对象的组成部分和它的装配方式。

### （2）组成

1. **产品（Product）**:最终要构建的复杂对象。
2. **建造者（Builder）**:抽象接口，定义创建产品对象的各个部件的接口。
3. **具体建造者（Concrete Builder）**:实现 Builder 接口，提供完成构建最终产品实例的方法和过程。每个具体建造者都负责创建特定产品的实例。
4. **指挥者（Director）**:负责安排已有模块的构建步骤，对外提供简化的接口。

### （3）类图结构

![image-20240618000746879](./assets/image-20240618000746879.png)

### （4）示例

```java
// 产品角色
class Car {
    private String wheels;
    private String engine;
    private String roof;

    public void setWheels(String wheels) { this.wheels = wheels; }
    public void setEngine(String engine) { this.engine = engine; }
    public void setRoof(String roof) { this.roof = roof; }
    public String toString() {
        return "Car with " + wheels + ", " + engine + ", " + roof;
    }
}

// 抽象建造者
interface Builder {
    void buildWheels();
    void buildEngine();
    void buildRoof();
    Car getCar();
}

// 具体建造者
class CarBuilder implements Builder {
    private Car car;

    public CarBuilder() {
        this.car = new Car();
    }

    @Override
    public void buildWheels() {
        car.setWheels("Normal wheels");
    }

    @Override
    public void buildEngine() {
        car.setEngine("Normal engine");
    }

    @Override
    public void buildRoof() {
        car.setRoof("Normal roof");
    }

    @Override
    public Car getCar() {
        return car;
    }
}

// 指挥者
class Director {
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    public Car construct() {
        builder.buildWheels();
        builder.buildEngine();
        builder.buildRoof();
        return builder.getCar();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Builder builder = new CarBuilder();
        Director director = new Director(builder);
        Car car = director.construct();
        System.out.println(car);
    }
}

```

## 5.原型模式

# 三、结构性模式

## 1.代理模式

### （1）概述

代理模式作为一种结构型设计模式，主要用于间接访问某个对象，同时添加一些控制这种访问的功能。它是一种非常有用的模式，特别是在需要控制或增强对某个对象访问的情况下。

在代理模式中，代理（Proxy）通过实现与真实主题（Real Subject）相同的接口，成为客户端和真实主题之间的中介。代理对象内部包含对真实主题的引用，控制着对真实主题的访问，并可以在调用真实主题的方法前后执行其他操作。这种结构允许进行各种操作，比如安全检查、增强功能、管理资源等。

### （2）组成

- **抽象主题（Subject）类**：这是一个接口或抽象类，定义代理和真实主题必须实现的方法，确保代理可以在任何需要真实主题的场合被使用。
- **真实主题（Real Subject）类**：这个类实现了抽象主题的业务操作，定义了代理所代表的真实对象。
- **代理（Proxy）类**：代理含有对真实主题的引用，通常会处理所有的对真实主题的访问请求。代理通常在执行真实主题的一个操作前后进行其它操作，如执行安全检查、修改请求、管理资源、缓存结果等。

### （3）静态代理

静态代理是在编译时就已经确定了代理类和目标类的关系。在这种代理模式中，代理类和目标类通常会实现相同的接口或继承相同的抽象类，代理类需要显式地声明它代理的目标对象，并在内部持有目标对象的引用。

**特点**

- **编码复杂**：代理类需要为每一个目标类显式地编写代码。
- **编译时确定**：代理关系在编译时就已经被确定。
- **性能优良**：因为是直接的方法调用，运行时性能很好，没有额外的调用开销。

考虑一个简单的场景，如一个文档编辑器中的图片加载：

- **抽象主题**：定义了显示图像的方法。
- **真实主题**：加载磁盘上的图像并显示。
- **代理**：代理图像类首先在屏幕上显示一个加载中的提示，然后异步加载真实图像，加载完成后更新显示。

```java
interface Image {
    void display();
}

// Real Subject
class RealImage implements Image {
    private String filePath;

    public RealImage(String filePath) {
        this.filePath = filePath;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Loading " + filePath);
    }

    @Override
    public void display() {
        System.out.println("Displaying " + filePath);
    }
}

// Proxy
class ProxyImage implements Image {
    private RealImage realImage;
    private String filePath;

    public ProxyImage(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public void display() {
        if (realImage == null) {
            System.out.println("Display placeholder while loading the image");
            realImage = new RealImage(filePath);
        }
        realImage.display();
    }
}
```

### （4）动态代理

动态代理不需要显式地定义代理类；代理类在运行时被动态创建。Java 提供了几种动态代理的实现方式，最常见的是使用 `java.lang.reflect.Proxy` 类和 `java.lang.reflect.InvocationHandler` 接口。

- java.lang.reflect Proxy，主要方法为

  ```java
  static Object newProxyInstance(
      ClassLoader loader,  		//指定当前目标对象使用类加载器
      Class<?>[] interfaces,    //目标对象实现的接口的类型
      InvocationHandler h      //事件处理器
  ) 
  //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。
  ```

- java.lang.reflect InvocationHandler，主要方法为

  ```java
  Object invoke(Object proxy, Method method, Object[] args) 
  // 在代理实例上处理方法调用并返回结果。
  ```

**特点**

- **灵活性高**：代理类在运行时动态创建，无需为每个服务编写显式的代理类。
- **开发效率高**：可以使用一套通用的代理逻辑处理多种服务。
- **性能开销**：相较于静态代理，动态代理有一定的性能开销，因为涉及到反射调用。

#### **示例：日志记录代理**

假设我们有一个接口和一个实现该接口的类，我们想为这个类的方法调用添加日志记录功能。

```java
interface Service {
    void perform();
}

class RealService implements Service {
    @Override
    public void perform() {
        System.out.println("Performing service");
    }
}
```

接下来，我们将创建一个 `InvocationHandler` 实现，用于在调用 `RealService` 的方法前后添加日志输出。

```java
class LoggingHandler implements InvocationHandler {
    private final Object target;

    public LoggingHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Entering " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("Exiting " + method.getName());
        return result;
    }
}
```

现在我们可以使用 `Proxy.newProxyInstance` 方法来创建 `Service` 接口的动态代理实例。

```java
public class ProxyDemo {
    public static void main(String[] args) {
        Service realService = new RealService();
        Service proxyService = (Service) Proxy.newProxyInstance(
            RealService.class.getClassLoader(),
            new Class<?>[] { Service.class },
            new LoggingHandler(realService)
        );

        // 调用代理的方法
        proxyService.perform();
    }
}
```

#### 类是如何动态生成的

动态代理类的字节码是在运行时创建的。Java 使用 `java.lang.reflect.Proxy` 类和 `java.lang.reflect.InvocationHandler` 接口实现动态代理。核心方法 `Proxy.newProxyInstance` 能够在运行时动态创建代理类。这个过程大致包括以下步骤：

1. **确定代理类的名称**：通常形式为 `com.sun.proxy.$ProxyN`，其中 `N` 是一个递增的数字。
2. **生成代理类的字节码**：根据传递给 `newProxyInstance` 方法的接口列表和调用处理器，动态生成代理类的字节码。这个过程由 `ProxyClassFactory` 完成，它调用 `ProxyGenerator.generateProxyClass` 方法来生成字节码。
3. **加载代理类到 JVM**：使用指定的类加载器，将生成的字节码加载到 JVM 中。这个类加载器通常是传递给 `newProxyInstance` 方法的类加载器。
4. **创建代理实例**：使用反射机制，通过加载的代理类构造函数创建代理实例。构造函数接受一个 `InvocationHandler` 作为参数。

生成的代理类实际上继承自 `Proxy` 类并实现了指定的接口。代理类中的每个方法实际上是通过调用其 `InvocationHandler` 的 `invoke` 方法来实现的。这样，当代理类的方法被调用时，实际执行的是 `InvocationHandler` 中的代码。











