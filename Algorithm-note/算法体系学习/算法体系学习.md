# class07

## 1.最大线段重合问题

给定多条线段，每条线段用一对整数 \([start, end]\) 表示，代表线段的起始和结束位置，其中 \(start\) 和 \(end\) 为闭区间。目标是找到所有线段中重合区域最多的部分，计算该区域包含的线段数量。线段重合区域的长度必须大于或等于 1。

为解决这个问题，我们采取以下步骤：

1. **排序**：首先根据每条线段的起始位置 \(start\) 对所有线段进行排序。

2. **使用优先队列（小根堆）**：使用一个小根堆来维护当前活跃的线段的结束位置 \(end\)。小根堆允许我们快速地访问当前所有重叠线段中最早结束的线段。

3. **遍历处理**：
   - 对每条已排序的线段进行遍历。
   - 对于当前线段，如果它的起始位置 \(start\) 大于或等于小根堆的堆顶（也就是最早结束的线段的结束位置 \(end\)），则将这个结束位置从堆中移除。重复该操作，直到堆顶的结束位置大于当前线段的起始位置或堆为空。
   - 将当前线段的结束位置加入到小根堆中。

4. **记录最大重合数量**：
   - 在添加每条线段到堆中后，记录堆的大小。这表示当前重合的线段数量。
   - 比较并更新记录的最大值。

5. **输出结果**：
   - 遍历结束后，记录的最大值即为最多重合区域中包含的线段数量。

**时间复杂度：**O(N*logN)

**代码实现：**

```java
public static int solution(int[][]lines) {
        //根据每条线段的起始位置start对所有线段进行排序。
        Arrays.sort(lines,(line1,line2) -> (line1[0]-line2[0]));
        //使用一个小根堆来维护当前活跃的线段的结束位置end。小根堆允许我们快速地访问当前所有重叠线段中最早结束的线段。
        PriorityQueue<Integer> heap=new PriorityQueue<>();
        //记录结果
        int res=0;
        heap.add(lines[0][1]);
        //遍历线段
        for (int[] line : lines) {
            // 移除heap内所有end早于当前线段start的线段
            if(!heap.isEmpty()&&line[0]>=heap.peek()){
               heap.poll();
            }
            //当前线段end加入heap
            heap.add(line[1]);
            //更新历史最大重合线段数量
            res=Math.max(res,heap.size());
        }
        return res;
    }
```

## 2.手动改写堆

在二叉堆中修改元素的优先级或删除非堆顶元素是具有挑战性的操作，因为标准的二叉堆结构并未设计为支持这些操作的高效执行。当堆中某个元素的优先级改变导致堆性质破坏时，理想中的调整操作（向上或向下调整）的时间复杂度是O(log N)，但问题在于标准二叉堆通常无法直接快速定位到特定元素，因此可能需要O(N)时间复杂度的遍历来找到这个元素。同样，删除任意非顶部元素也通常需要O(N)时间来定位元素，随后的调整是O(log N)。为提高效率，可以考虑使用额外的数据结构如哈希表维持元素的索引，或使用如斐波那契堆等更高级的堆结构来优化这些操作。

为解决这个问题，我们采取以下步骤：

使用哈希表：构建反向索引表，直接快速定位到元素位置。

```java
public class EnhancedHeap<T> {
    private ArrayList<T> heapElements;
    //反向索引表
    private HashMap<T, Integer> elementIndexMap;
    private int heapSize;
    private Comparator<? super T> comparator;

    public EnhancedHeap(Comparator<? super T> comparator) {
        this.heapElements = new ArrayList<>();
        this.elementIndexMap = new HashMap<>();
        this.heapSize = 0;
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return heapSize == 0;
    }

    public int getSize() {
        return heapSize;
    }

    public boolean containsElement(T element) {
        return elementIndexMap.containsKey(element);
    }

    public T peekTop() {
        return heapElements.get(0);
    }

    public void add(T element) {
        heapElements.add(element);
        elementIndexMap.put(element, heapSize);
        siftUp(heapSize++);
    }

    public T removeTop() {
        T topElement = heapElements.get(0);
        swap(0, heapSize - 1);
        elementIndexMap.remove(topElement);
        heapElements.remove(--heapSize);
        siftDown(0);
        return topElement;
    }

    public void removeElement(T element) {
    // 获取堆中最后一个元素
    T lastElement = heapElements.get(heapSize - 1);
    // 获取待删除元素在堆中的索引
    int index = elementIndexMap.get(element);
    // 从索引映射中移除该元素
    elementIndexMap.remove(element);
    // 减少堆的大小并移除最后一个元素
    heapElements.remove(--heapSize);
    // 如果待删除的元素不是堆中的最后一个元素
    if (!element.equals(lastElement)) {
        // 将最后一个元素移至待删除元素的位置
        heapElements.set(index, lastElement);
        // 更新最后一个元素的新位置
        elementIndexMap.put(lastElement, index);
        // 调整堆以保持堆性质
        adjustElement(lastElement);
    }
}


    public void adjustElement(T element) {
        siftUp(elementIndexMap.get(element));
        siftDown(elementIndexMap.get(element));
    }

    public List<T> getAllElements() {
        return new ArrayList<>(heapElements);
    }
	//向上调整
    private void siftUp(int index) {
        while (index > 0 && comparator.compare(heapElements.get(index), heapElements.get((index - 1) / 2)) < 0) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }
	//向下调整
    private void siftDown(int index) {
        int leftChildIndex = index * 2 + 1;
        while (leftChildIndex < heapSize) {
            int smallestChildIdx = leftChildIndex + 1 < heapSize &&
                                   comparator.compare(heapElements.get(leftChildIndex + 1), heapElements.get(leftChildIndex)) < 0
                                   ? leftChildIndex + 1
                                   : leftChildIndex;
            smallestChildIdx = comparator.compare(heapElements.get(smallestChildIdx), heapElements.get(index)) < 0
                               ? smallestChildIdx
                               : index;
            if (smallestChildIdx == index) {
                break;
            }
            swap(smallestChildIdx, index);
            index = smallestChildIdx;
            leftChildIndex = index * 2 + 1;
        }
    }

    private void swap(int i, int j) {
        T tempElement1 = heapElements.get(i);
        T tempElement2 = heapElements.get(j);
        heapElements.set(i, tempElement2);
        heapElements.set(j, tempElement1);
        elementIndexMap.put(tempElement2, i);
        elementIndexMap.put(tempElement1, j);
    }
}

```

## 3.topK问题

在一个在线购物平台中，实时展示购买数量最多的前`k`名顾客。它处理了两种事件：顾客购买商品和顾客退货，通过这些事件动态地更新获奖者名单。

为解决这个问题，我们采取以下步骤：

**1. 加强堆的使用：**为了有效管理顾客购买行为的动态变化，系统利用两种不同类型的加强堆结构来维护获奖区和候选区：

   - **候选区：** 使用大根堆，优先级按购买数量从大到小排列，使得购买数量最多的顾客可以被优先考虑晋升至获奖区。
   - **获奖区：** 使用小根堆，按购买数量从小到大排列，确保购买数量最少的顾客在需要时可以被移动到候选区。如果顾客的购买数量相同，则遵循先到先服务的原则（FIFO）进行排列。

**2. 顾客映射表：**系统通过一个哈希映射（HashMap）来记录所有事件发生的顾客信息。这个映射表使用顾客的ID作为键，映射到对应的`Customer`对象，从而快速获取和更新顾客的购买记录和其他相关信息。

**3. 事件处理逻辑：**

- **退货事件：** 如果事件为退货且顾客之前没有记录，则该事件被忽略。
- **首次购买：** 如果是顾客首次购买，系统会创建一个新的`Customer`对象：
  - 如果获奖区未满，新顾客将直接被加入获奖区。
  - 否则，新顾客将被加入候选区。
- **已有记录的购买：** 如果顾客已有购买记录并再次购买，其购买数量会增加，并相应更新所在堆的状态。
- **已有记录的退货：** 如果顾客退货，其购买数量减少。如果购买数量减至零，则从映射表和相应堆中移除该顾客。否则，更新堆以反映新的购买数量。

**4. 晋升逻辑：**在每次事件处理后，系统会执行晋升逻辑，以确保获奖区始终保持最合适的顾客。这一逻辑检查并调整获奖区和候选区之间的顾客，以保证顾客的正确排名。

**5. 结果记录与返回：**系统将记录每个事件处理后的获奖名单，并最终返回整个事件序列的获奖名单历史。

**时间复杂度：**O(N*logN)

# class08

## 1.前缀树

前缀树（Trie），又称字典树或键树，是一种树形结构，常用于处理字符串相关的算法问题。前缀树的核心思想是利用字符串之间的公共前缀来降低查询时间的开销，以达到提高效率的目的。它特别适合于实现字典查询、词频统计、自动补全等功能。

**基本性质**

- 每个节点代表一个字符串（该字符串为从根到该节点的路径上所有字符组成的串）。
- 根节点通常为空，不包含字符。

**复杂度分析**：对于前缀树，其操作的时间复杂度主要由遍历字符串的长度 L*决定，平均情况下是 O(L)。

### 思路1：数组实现

```java
package com.lxy.class08;

public class Trie01 {
    public static class Node{
        public int pass;
        public int end;
        public Node[] next;
        Node(){
            pass=0;//经过这个节点单词数量
            end=0;//在这个节点结束单词的数量
            next=new Node[26];//记录下一个节点的路径
        }
    }
    private Node root;
    public Trie01(){
        root=new Node();
    }

    public void insert(String word){
        if(word==null){
            return;
        }
        char[] chars = word.toCharArray();
        Node cur=root;
        cur.pass++;
        for(char e:chars){
            int path=e-'a';
            if(cur.next[path]==null){
                cur.next[path]=new Node();
            }
            cur=cur.next[path];
            cur.pass++;
        }
        cur.end++;
    }
    public void erase(String word) {
        if(countWordsEqualTo(word)==0){
            return;
        }
        char[] chars = word.toCharArray();
        Node cur=root;
        for(char e:chars){
            int path=e-'a';
            if(--cur.next[path].pass==0){
                cur.next[path]=null;
                return;
            }
            cur=cur.next[path];
        }
        cur.end--;
    }
    public int countWordsEqualTo(String word) {
        if(word==null){
            return 0;
        }
        char[] chars = word.toCharArray();
        Node cur=root;
        for(char e:chars){
            int path=e-'a';
            if(cur.next[path]==null){
                return 0;
            }else{
                cur=cur.next[path];
            }
        }
        return cur.end;
    }
    public int countWordsStartingWith(String pre) {
        if(pre==null){
            return 0;
        }
        char[] chars = pre.toCharArray();
        Node cur=root;
        for(char e:chars){
            int path=e-'a';
            if(cur.next[path]==null){
                return 0;
            }else{
                cur=cur.next[path];
            }
        }
        return cur.pass;
    }
}
```

### 思路2：哈希表实现

使用`HashMap`来代替数组来存储节点之间的连接。这种方式使得前缀树更加灵活，能够处理不仅仅是小写字母a到z的情况，而是可以处理所有的Unicode字符。这对于多语言或者特殊字符的情况特别有用。

```java
package com.lxy.class08;

import java.util.HashMap;

public class Trie02 {
    public static class Node{
        public int pass;
        public int end;
        public HashMap<Integer,Node> next;
        Node(){
            pass=0;
            end=0;
            next=new HashMap<>();
        }
    }
    private Node root;
    public Trie02(){
        root=new Node();
    }

    public void insert(String word){
        if(word==null){
            return;
        }
        char[] chars = word.toCharArray();
        Node cur=root;
        cur.pass++;
        for(char e:chars){
            if(!cur.next.containsKey((int)e)){
                cur.next.put((int)e,new Node());
            }
            cur=cur.next.get((int)e);
            cur.pass++;
        }
        cur.end++;
    }
    public void erase(String word) {
        if(countWordsEqualTo(word)==0){
            return;
        }
        char[] chars = word.toCharArray();
        Node cur=root;
        for(char e:chars){
            if(--cur.next.get((int)e).pass==0){
                cur.next.remove((int)e);
                return;
            }
            cur=cur.next.get((int)e);
        }
        cur.end--;
    }
    public int countWordsEqualTo(String word) {
        if(word==null){
            return 0;
        }
        char[] chars = word.toCharArray();
        Node cur=root;
        for(char e:chars){
            if(!cur.next.containsKey((int)e)){
                return 0;
            }else{
                cur=cur.next.get((int)e);
            }
        }
        return cur.end;
    }
    public int countWordsStartingWith(String pre) {
        if(pre==null){
            return 0;
        }
        char[] chars = pre.toCharArray();
        Node cur=root;
        for(char e:chars){
            if(!cur.next.containsKey((int)e)){
                return 0;
            }else{
                cur=cur.next.get((int)e);
            }
        }
        return cur.pass;
    }
}
```

## 2.计数排序 (Counting Sort)

> 非比较排序

计数排序是一种稳定的排序算法，适用于一定范围内的整数排序。它不是基于元素比较的，而是通过计算一个数组中每个值的出现次数来实现排序。

**原理和过程**：

1. **确定范围**：首先，找出待排序数组中的最大值和最小值，确定值的范围。
3. **累计计数**：创建一个计数数组，用来统计每个值的出现次数，对计数数组做累加操作，使得每个位置存储的是在排序后数组中，对应值之前的元素总数。
4. **回填**：根据计数数组，将每个元素放回到原数组或者另一个结果数组中的正确位置。

**时间复杂度**：\(O(n + k)\)，其中 \(n\) 是原数组的长度，\(k\) 是值的范围大小。当 \(k\) 不是很大并且分布比较均匀时，计数排序是非常高效的。

**空间复杂度**：\(O(k)\)，主要用于存储计数数组。

```java
//非负数
public class CountingSort {
    public static void countSort(int[] arr){
        if (arr == null || arr.length < 2) {
            return;
        }
        int max=Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max=Math.max(arr[i],max);
        }
        int[] bucket=new int[max+1];
        for (int i = 0; i < arr.length; i++) {
            bucket[arr[i]]++;
        }
        int j=0;
        for (int i = 0; i < bucket.length; i++) {
            while (bucket[i]-->0){
                arr[j++]=i;
            }
        }
    }
}
```



## 3.基数排序(Radix Sort)

> 非比较排序
>

基数排序是通过对待排序元素的每一位进行排序来达到整体排序的目的。它可以使用任何稳定排序作为子程序来排序数字的每一位，常用的是计数排序。

**原理和过程**：

1. **按位排序**：从最低位开始，对每一位执行稳定排序（通常使用计数排序）。对于每一位的排序，都保证了前一位的相对顺序不会被改变。
2. **重复操作**：对每一位重复执行上述排序操作，从最低位一直到最高位。

**时间复杂度**：$\(O(d \cdot (n + k))\)$，其中 \(d\) 是最大数的位数，\(n\) 是数组长度，\(k\) 是基数（对于十进制数，\(k\) 为10），主要影响计数排序。当 \(d\) 相对较小，且 \(n\) 大时，基数排序可以非常高效。

**空间复杂度**：\(O(n + k)\)，除了原数组外，需要额外的空间来存储每一位的计数信息和临时排序结果。

**解释：**

1. **准备工作**：
   
   `count` 数组用于计数，大小为基数 `k`（例如，对于十进制数，`k=10`）。这个数组用来记录每个数字在当前位上的出现次数。

   `tmp` 数组用于暂时存储排序过程中的数组，大小与原数组 `arr` 相同。
   
2. **对每一位进行稳定排序**：
   
   对于数组中的每个元素，根据当前位（从最低位开始）的数字，更新 `count` 数组以计数每个数字出现的次数。

   计算 `count` 数组的前缀和，使得 `count[i]` 在之后表示值小于等于 `i` 的数的总数。这一步是关键，它为下一步的元素定位提供了基础。
   
3. **元素定位与排序**：
   
   **反向遍历**原数组 `arr`：这一步是确保排序稳定性的关键。通过从后向前遍历，我们保证了当有相同的数时，最后出现的那个数在排序后的数组中也会最后出现，从而保持了原有的相对顺序。

   根据元素在当前位的数字找到它在 `tmp` 数组中的正确位置，即 `count[num] - 1`，并相应地减少 `count[num]` 的值。这样，即使有多个相同的值，它们也会被放在 `tmp` 数组中正确的连续位置上。
   
4. **复制回原数组**：
   将 `tmp` 数组中的元素复制回原数组 `arr`，完成当前位的排序。
   
5. **重复上述步骤**直到最高位：
   
   对每个位重复上述过程，直至最高位排序完成。

通过这种方式，基数排序能够在每一位上利用计数排序的效率，同时保持前一位排序的结果的稳定性。这使得基数排序在处理具有多个位的数据（如整数、长数字或字符串等）时非常有效。正如你所分析的，这个过程确保了每一位的正确排序，同时维持了整体排序的稳定性。

```java
public class RadixSort {
    public static int maxBits(int[] arr) {
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
        }
        int res = 0;
        while (max != 0) {
            res++;
            max /= 10;
        }
        return res;
    }
    public static int getDigit(int x, int d) {
        return ((x / ((int) Math.pow(10, d - 1))) % 10);
    }

    public static void radixSort(int[] arr){
        if (arr == null || arr.length < 2) {
            return;
        }
        radixSort(arr, 0, arr.length-1, maxBits(arr));
    }
    public static void radixSort(int[] arr, int L, int R, int digit) {
        int radix=10;
        int[]tmp=new int[R-L+1];
        for (int d = 1; d <=digit ; d++) {
            int[]count=new int[radix];
            for (int i = L; i <= R; i++) {
                int num=getDigit(arr[i],d);
                count[num]++;
            }
            for (int i = 1; i < count.length; i++) {
                count[i]=count[i]+count[i-1];
            }
            for (int i = R; i >= L; i--) {
                int num=getDigit(arr[i],d);
                tmp[count[num]-1]=arr[i];
                count[num]--;
            }
            for (int i = L,j = 0; i <= R; i++, j++) {
                arr[i] = tmp[j];
            }
        }
    }
}
```

# class09

## 1.快慢指针

（1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点

分析：最初始的快慢指针版本。

时间复杂度：O（N）

空间复杂度：O（1）

```java
public static Node midOrUpMidNode(Node head) {
    if (head == null || head.next == null || head.next.next == null) {
        return head;
    }
    //此时链表至少存在三个节点
    Node slow = head.next;
    Node fast = head.next.next;
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

（2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点

分析：将快慢指针均向前移动，把问题转换为最初的快慢指针版本，或者理解为fast指针起始位置少一步，这样如果节点为偶数，后面同步移动时，fast会带动slow多走一步。

```java
public static Node midOrDownMidNode(Node head) {
    if (head == null || head.next == null) {
        return head;
    }
    //至少存在两个节点
    Node slow = head.next;
    Node fast = head.next;
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

（3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个

分析：奇偶均返回中点前一个，可以让slow的起始位置向前一步（当然也可以让fast多向后一步，也就是移动两个节点，不过得追加更多的判断），再次共同移动。

```java
public static Node midOrUpMidPreNode(Node head) {
    if (head == null || head.next == null || head.next.next == null) {
        return null;
    }
    //此时链表至少存在三个节点
    Node fast = head.next.next;
    Node slow = head;
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

（4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

分析：经过前面算法的练习，可以总结出一些规律

- 偶数中点返回第二个处理方法：slow、fast均向前移动一个节点

  ```java
  //注意保证链表至少有两个节点
  Node slow = head.next;
  Node fast = head.next;
  ```

- 返回中点的前一个节点处理方法：起始位置slow比fast晚走一步

  ```java
  //注意保证链表至少有三个节点
  Node fast = head.next.next;
  Node slow = head;
  ```

  那么如果同时满足上面两种条件，则需要将其处理方法耦合，即slow、fast先都移动一个节点，再让起始位置fast比slow多走一步。

  ```
  Node fast = head.next.next.next;
  Node slow = head.next;
  ```

  但是这样就需要保证链表至少有四个节点，我们也可以简化，因为slow一步一个节点、fast一步两个节点，简化为

  ```
  //注意保证链表至少有两个节点
  Node fast = head.next;
  Node slow = head;
  ```

  

```java
public static Node midOrDownMidPreNode (Node head){
    if (head == null || head.next == null ) {
        return null;
    }
    //此时链表至少存在2个节点
    Node slow = head;
    Node fast = head.next;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```

## 2.判断链表回文结构

给定一个单链表的头节点head，请判断该链表是否为回文结构。

### 思路1：容器

分析：借助栈，利用先进后出的特点，可以在栈中取出从后往前的值与原链表判断是否回文。

时间复杂度：O（n）

空间复杂度：O（n），如果确定中点的话，可以优化为O（1/2*n）

```java
public static boolean isPalindromeListByStack(Node head){
    Stack<Node> stack = new Stack<>();
    Node cur=head;
    while(cur!=null){
        stack.add(cur);
        cur=cur.next;
    }
    while(head!=null){
        if(stack.pop().value!=head.value){
            return false;
        }
        head=head.next;
    }
    return true;
}
```

### 思路2：不开辟空间

分析：通过找到链表中点，然后反转链表的后半部分，再将前半部分与反转后的后半部分进行比较的方式来判断是否为回文。

时间复杂度：O（n）

空间复杂度：O（1）

```java
public static boolean isPalindromeList(Node head){
    //偶数节点返回第一个中间节点
    Node midNode = midOrUpMidNode(head);
    Node newHead = reverseList(midNode.next);
    while(newHead!=null){
        if(newHead.value!=head.value){
            return false;
        }
        newHead=newHead.next;
        head=head.next;
    }
    return true;
}
```

## 3.划分链表

题目：按照某个值（pivot）将链表划分为三部分：左边小于pivot的值，中间等于pivot的值，以及右边大于pivot的值

### 思路1：容器

分析：将链表的所有值复制到一个数组中，然后对该数组使用荷兰棋进行划分，最后将排序后的数组值回写到链表中。

时间复杂度：O（n）

空间复杂度：O（n）

```java
public static void smallerEqualBiggerByArray(Node head,int pivot){
    int[] arr=new int[countList(head)];
    Node cur=head;
    for (int i = 0; i < arr.length; i++) {
        arr[i]=cur.value;
        cur=cur.next;
    }
    //根据pivot，通过荷兰旗思维划分
    netherlandsFlag(arr, 0, arr.length - 1, pivot);
    for (int e : arr) {
        head.value = e;
        head = head.next;
    }
}
```

### 思路2：不开辟空间

分析：按照给定的pivot值将单向链表分区，使得分区后的链表左侧都是小于pivot的值，中间是等于pivot的值，右侧是大于pivot的值，并将分区头尾链接。不过链接时，边界判断很有意思，存在多种情况，下面代码是优化后的版本，该思路适用于多种链接问题。

时间复杂度：O（n）

空间复杂度：O（1）

```java
public static Node smallerEqualBigger(Node head,int pivot){
    Node smallerHead=null;
    Node smallerTail=null;
    Node equalHead=null;
    Node equalTail=null;
    Node biggerHead=null;
    Node biggerTail=null;
    //根据pivot划区域
    while(head!=null){
        if(head.value<pivot){
            if(smallerHead==null){
                smallerHead=smallerTail=head;
            }else {
                smallerTail.next=head;
                smallerTail=head;
            }
        } else if (head.value==pivot) {
            if(equalHead==null){
                equalHead=equalTail=head;
            }else {
                equalTail.next=head;
                equalTail=head;
            }
        }else {
            if(biggerHead==null){
                biggerHead=biggerTail=head;
            }else {
                biggerTail.next=head;
                biggerTail=head;
            }
        }
        head=head.next;
    }
    //防止形成环形链表
    biggerTail.next=null;
    //smaller区不为空,则将smallTail接到equal区
    if(smallerHead!=null){
        smallerTail.next=equalHead;
        //为了后续的链接，尽量保证equalTail不为空（存在前两个区都为空的情况，那么直接返回第三个）
        equalTail=equalTail!=null?equalTail:smallerTail;
    }
    if(equalTail!=null){
        equalTail.next=biggerHead;
    }
    return smallerHead!=null?smallerHead:(equalHead!=null?equalHead:biggerHead);
}
```

## 4.链表random节点拷贝（有点东西但不多）

题目：实现一个函数完成这个含义random节点链表的复制，并返回复制的新链表的头节点。
	分析：

在复制一个包含`random`指针的链表时，我们面临一个独特的挑战：如何在不增加复杂度至O(n\^2)的情况下，为复制出的链表的每个节点正确设置其`random`指针。在常规的遍历复制过程中，单纯地复制每个节点及其`next`和`random`指针是不足够的，因为原链表中的`random`指针可能指向链表中任意一个节点，而这种随机性在独立的复制链表中难以直接复现。若尝试记录原节点到其`random`节点的跳转次数以复制该`random`关系，则时间复杂度会增至O(n^2)，显然不是一个高效的解决方案。

为了优雅且高效地解决这一问题，我们采用了一种巧妙的方法：在每个原始节点之后直接插入其复制节点。这一策略的关键优势在于，它允许我们利用原链表的结构来辅助建立复制链表中的`random`指针关系。具体而言，对于原链表中的任一节点A及其`random`指针指向的节点B，A的复制节点A'位于A的`next`位置，同理，B的复制节点B'位于B的`next`位置。因此，A'的`random`指针应当指向B'，即A的`random`指针的`next`节点。通过这种方法，我们能够在遍历原链表的同时，为每个复制节点正确地设置其`random`指针，而无需额外的映射或查找操作。

在建立了复制节点的`random`指针关系之后，下一步就是将这些复制节点从原链表中分离出来，形成一个独立的复制链表。这一步骤通过调整节点的`next`指针完成，确保原链表恢复到其原始状态，同时生成了一个结构与原链表相同、`random`指针也正确指向的复制链表。

```java
public static Node copyListWithRandom(Node head){
    Node cur=head;
    //在原链表上插入copy节点
    while(cur!=null){
        Node copyNode=new Node(cur.value);
        copyNode.next=cur.next;
        cur.next=copyNode;
        cur=copyNode.next;
    }
    //连接random节点
    cur=head;
    while (cur!=null){
        //注意判断random节点为null
        cur.next.random=cur.random.next!=null?cur.random.next:null;
        cur=cur.next.next;
    }
    //原链表与copy链表断开
    cur=head;
    Node copyHead=cur.next;
    while (cur!=null){
        Node copyNode=cur.next;
        cur.next=copyNode.next;
        cur=copyNode.next;
        //注意判断下一个节点为null
        copyNode.next=cur!=null?cur.next:null;
    }
    return copyHead;
}
```

# class10

## 1.环形链表（有不少东西）

题目：给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 。要求不开辟额外空间

分析：

（1）判断链表是否有环，如果有环则返回第一个入环节点。

使用快慢指针法判断链表是否有环。如果快慢指针在某点相遇，则表明链表有环。当快慢指针相遇后，将其中一个指针重置到链表头部，然后两个指针以相同的速度移动，它们再次相遇的节点即为环的入口节点。

```java
public static Node findLoopNode(Node head){
    if(head==null||head.next==null||head.next.next==null){
        return null;
    }
    //至少有三个节点
    Node slow=head.next;
    Node fast=head.next.next;
    while(slow!=fast){
        //fast走到头了，没有相交，代表无环
        if(fast.next==null||fast.next.next==null){
            return null;
        }
        slow=slow.next;
        fast=fast.next.next;
    }
    //有环，找出入环节点
    //fast从头开始，以每次一步的动作再次与slow相遇时，便是入环节点
    fast=head;
    while(fast!=slow){
        fast=fast.next;
        slow=slow.next;
    }
    return slow;
}
```

（2）判断链表环形多种相交情况

- 两个链表均无环

首先遍历两个链表来找出长度差，然后从长链表开始先走长度差的步数。接着，两个链表同步前进，直到它们相遇的点，该点即为相交的第一个节点。

```java
public static Node noLoop(Node head1,Node head2){
    if (head1 == null || head2 == null) {
        return null;
    }
    Node cur1=head1;
    Node cur2=head2;
    int count=0;
    while(cur1.next!=null){
        cur1=cur1.next;
        count++;
    }
    while(cur2.next!=null){
        cur2=cur2.next;
        count--;
    }
    //不相交
    if(cur1!=cur2){
        return null;
    }
    //相交
    //cur1为长链表，cur2为短链表
    cur1=count>0?head1:head2;
    cur2=cur1==head1?head2:head1;
    //count必须为正数
    count=Math.abs(count);
    while(count!=0){
        count--;
        cur1=cur1.next;
    }
    while(cur1!=cur2){
        cur1=cur1.next;
        cur2=cur2.next;
    }
    return cur1;
}
```

- 两个链表只有一个有环

在这种情况下，两个链表不可能相交。因为如果一个链表有环，而另一个没有，它们不可能共享相同的节点序列。因此，应直接返回`null`。

- 两个链表均有环

  - 环外相交

  如果两个链表的入环节点相同，表明它们在环外相交。处理方法类似于处理无环链表相交的情况，只不过在遇到共同的入环节点前停止遍历。

  - 环内相交

  如果两个链表的入环节点不同，则需要检查它们是否在环内相交。通过从一个链表的入环节点开始遍历整个环，如果能找到另一个链表的入环节点，表明它们在环内相交。两个链表的任一入环节点都可以作为相交的节点返回。

  - 不相交

  如果两个链表均有环，但是在环内相交的检查过程中没有发现它们共享入环节点，表明它们不相交。

```java
public static Node allLoopOut(Node head1,Node head2,Node loopNode){
    Node cur1=head1;
    Node cur2=head2;
    int count=0;
    while(cur1!=loopNode){
        cur1=cur1.next;
        count++;
    }
    while(cur2!=loopNode){
        cur2=cur2.next;
        count--;
    }
    //cur1为长链表，cur2为短链表
    cur1=count>0?head1:head2;
    cur2=cur1==head1?head2:head1;
    count=Math.abs(count);
    while(count>0){
        count--;
        cur1=cur1.next;
    }
    while(cur1!=cur2){
        cur1=cur1.next;
        cur2=cur2.next;
    }
    return cur1;
}
public static Node allLoop(Node head1, Node head2, Node loopNode01, Node loopNode02){
    //环外相交
    if(loopNode01==loopNode02){
        return allLoopOut(head1,head2,loopNode01);
    }
    //判断不相交和环内相交
    Node cur=loopNode01.next;
    while(cur!=loopNode01){
        if(cur==loopNode02){
            //环内相交
            return loopNode01;
        }
        cur=cur.next;
    }
    //不相交
    return null;
}
```

时间复杂度：

## 2.二叉树的前、中、后序遍历

### （1）递归

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int v) {
        value = v;
    }
}
public static void preOrderTraversal(Node root){
    if(root==null){
        return;
    }
    System.out.println(root.value);
    preOrderTraversal(root.left);
    preOrderTraversal(root.right);
}
public static void middleOrderTraversal(Node root){
    if(root==null){
        return;
    }
    middleOrderTraversal(root.left);
    System.out.println(root.value);
    middleOrderTraversal(root.right);
}
public static void postOrderTraversal(Node root){
    if(root==null){
        return;
    }
    postOrderTraversal(root.left);
    postOrderTraversal(root.right);
    System.out.println(root.value);
}
```

### （2）非递归

栈的回溯特性：栈（Stack）具有“后进先出”（LIFO, Last In First Out）的特性，这种特性让它在处理具有嵌套或递归结构的数据时非常有效，因此它自然地支持回溯功能。回溯算法通常涉及到对一系列决策的探索，当发现当前路径不可行时，算法会退回（回溯）到上一个决策点继续尝试其他可能的路径。栈能够很自然地实现这一过程：每做出一个决策，就将其推入栈中；每回溯一个决策，就从栈中弹出最后一个决策。

#### 1）前序

分析：

首先将根节点压入栈。只要栈不为空，重复以下步骤：

- 弹出栈顶元素，访问它（打印）。
- 将该节点的右子节点（如果有）压入栈。
- 将该节点的左子节点（如果有）压入栈。

```java
public static void preOrderTraversal( Node root){
    if (root == null) {
        return;
    }
    Stack<Node> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        Node node = stack.pop();
        System.out.println(node.value);
        if(node.right!=null){
            stack.push(node.right);
        }
        if(node.left!=null){
            stack.push(node.left);
        }
    }
}
```

#### 2）后序

通常需要两个栈来实现：

第一个栈用于模拟递归的过程。

将根节点压入第一个栈，只要第一个栈不为空，重复以下步骤：

- 弹出栈顶元素，将其压入第二个栈。
- 将弹出节点的左子节点和右子节点分别压入第一个栈。

第二个栈中的元素顺序将会是后序遍历的顺序，依次弹出并访问。

```java
public static void postOrderTraversal( Node root){
    if(root==null){
        return;
    }
    Stack<Node> stack = new Stack<>();
    Stack<Node> helperStack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        Node node = stack.pop();
        helperStack.push(node);
        if(node.left!=null){
            stack.push(node.left);
        }
        if(node.right!=null){
            stack.push(node.right);
        }
    }
    helperStack.stream().map(node->node.value).forEach(System.out::println);
}
```

#### 3）中序

从根节点开始，所有初始化的左子节点都被压入栈，直到没有左子节点。只要栈不为空，重复以下步骤：

- 弹出栈顶元素，访问它。
- 转向弹出节点的右子节点，压入其所有左子节点。

```java
public static void middleOrderTraversal( Node root){
    if (root == null) {
        return;
    }
    Stack<Node> stack = new Stack<>();
    Node cur=root;
    while(!stack.isEmpty()||cur!=null){
        while(cur!=null){
            stack.push(cur);
            cur=cur.left;
        }
        cur=stack.pop();
        System.out.println(cur);
        cur=cur.right;
    }
}
```



### （3）其他概念

#### 1）递归序

在理解递归算法时，**递归序**是一个重要的概念。递归序基本上指的是在递归过程中代码的执行顺序。每当你调用一个函数时（包括递归函数），你都会进入一个新的函数执行上下文（或称作"调用栈帧"）。递归函数特别之处在于它会重复调用自己，这种重复调用形成了一个执行栈，其中每个函数调用都遵循先进后出的原则。

对于二叉树的遍历来说，递归序特别指每个节点被访问的顺序，无论是前序、中序还是后序遍历，都可以视为递归过程的一部分，每个节点都会经历三次递归序的机会：

1. **第一次到达一个节点时**，在这一点上，前序遍历会处理（或“访问”）这个节点。
2. **从节点的左子树返回时**，这是中序遍历处理节点的时机。
3. **从节点的右子树返回时**，这是后序遍历处理节点的时机。

递归序的理解

- **递归序的概念帮助我们理解**：每次递归调用自身时，无论是进入更深一层的递归还是返回到上一层，都是递归过程的一部分。在二叉树遍历的上下文中，即便是单一的遍历过程，每个节点在递归中实际上都被“访问”了三次。
- **编写递归函数时**，我们可以利用这三次访问的机会来执行不同的操作，如在二叉树遍历中的不同点处理节点。

以二叉树的递归中序遍历为例，递归序的应用可以这样理解：

1. 当函数首次到达一个节点（还未探索它的子节点），这标志着递归序中的“前序位置”。
2. 探索完左子树，返回到这个节点，这标志着“中序位置”。
3. 探索完右子树并再次返回到这个节点，这标志着“后序位置”。

理解递归序对于深入理解递归函数的执行流程和设计复杂递归算法非常有帮助。通过递归序的视角，我们可以更好地规划和理解在递归过程中各个点上应当执行的操作。

#### 2）证明一个节点的前序遍历后左边的数，与后序遍历右边的数，交集为该节点的祖先

1. **前序遍历（Pre-order Traversal）的特性**：在前序遍历中，任意节点N的遍历形式为“N，左子树，右子树”。因此，节点N之后遍历的都是它的子孙节点。所以，前序遍历中位于节点N左侧的节点只可能是它的祖先节点或其祖先的其他子树中的节点，而不包括它的子孙节点。
2. **后序遍历（Post-order Traversal）的特性**：在后序遍历中，任意节点N的遍历形式为“左子树，右子树，N”。这意味着在遍历到节点N之前，其所有子孙节点都已经被遍历过。因此，后序遍历中位于节点N右侧的节点只能是它的祖先节点。
3. **排除兄弟节点的可能性**：
   - 在前序遍历中，如果节点N是某个子树的左节点，其右兄弟节点及右兄弟节点的子树会在节点N之后被遍历，因此不会出现在节点N左侧。
   - 在后序遍历中，如果节点N是某个子树的右节点，其左兄弟节点及左兄弟节点的子树都会在节点N之前被遍历，因此不会出现在节点N右侧。

通过以上分析，我们可以得出结论：一个节点在前序遍历中位于其左侧的节点（排除了该节点的子孙节点）和在后序遍历中位于其右侧的节点（也是其祖先节点）的交集，只包含该节点的祖先节点。这是因为只有祖先节点能同时出现在前序遍历的左侧和后序遍历的右侧，而所有非祖先节点（包括兄弟节点及其子孙节点）都被这种遍历顺序排除了。

# class11

## 1.删除链表节点

题目：不提供单链表的头节点，而提供要被删除节点，在链表中删除整个节点

分析：假设要删除的节点不是链表的尾节点，可以通过将下一个节点的值复制到当前节点，然后删除下一个节点来实现。这样，本质上是将下一个节点的值“移动”到了当前节点，并未直接删除当前节点，但从链表的角度看，效果相同。

局限性：

1. **尾节点无法删除**：如果给定的节点是链表的尾节点，这种方法就无法应用，因为尾节点没有下一个节点的值可以复制，而且你无法通过当前节点访问和修改前一个节点的`next`指针。
2. **只修改了节点值**：这种方法实际上删除的是给定节点的下一个节点，而不是给定节点本身。如果节点包含复杂的数据或引用，简单的值复制可能不足以满足需求。



## 2.二叉树层序遍历

题目：实现二叉树的按层遍历，并按行打印

分析：在对二叉树进行层序遍历时，采用队列这一数据结构是因为它遵循先进先出（FIFO）的原则，这使得我们能够按照宽度优先的策略访问树中的每个节点。为了在遍历过程中实现按行打印的功能，我们使用了两个变量`row`和`nextRow`。这里，`row`代表当前行剩余待遍历的节点数，而`nextRow`用于计数下一行的节点数。

当从队列中取出一个节点进行处理时，该节点记为`cur`，并直接打印其值。此时，`row`的值减一，表示当前行的节点数减少了一个。如果`cur`节点存在左或右子节点，这些子节点依次被加入队列中，同时`nextRow`的值相应增加，反映了下一行待遍历的节点数增加。

一旦`row`的值变为0，意味着当前行的所有节点及其子节点均已经被遍历并加入队列中。此时，我们打印一个换行符以分隔不同的行，然后将`nextRow`的值赋给`row`，以准备遍历下一行的节点，同时将`nextRow`重置为0，为接下来的行计数做准备。

时间复杂度：O（n）

空间复杂度：O（n）

```java
static public void levelTraversalBT(Node root){
    if(root==null){
        return;
    }
    Queue<Node> queue=new LinkedList<>();
    int row=1;
    int nextRow=0;
    queue.add(root);
    while(!queue.isEmpty()){
        Node cur=queue.poll();
        row--;
        System.out.println(cur.value);
        if(cur.left!=null){
            queue.add(cur.left);
            nextRow++;
        }
        if(cur.right!=null){
            queue.add(cur.right);
            nextRow++;
        }
        //控制换行
        if (row==0){
            row=nextRow;
            nextRow=0;
            System.out.println();
        }
    }
}
```

## 3.实现二叉树的序列化和反序列化

题目：实现二叉树的序列化和反序列化

### （1）前序、后序遍历实现（以前序遍历为例）

分析：在序列化二叉树时，关键在于准确地记录下每个节点的位置及其子节点的情况，特别是对于叶子节点的空子节点。为了解决这个问题，我们引入一个特定的分隔符（如"#"）来明确标记那些空指针的位置，从而确保序列化的结果能够完整地反映出原始树的结构。为了便于后续的反序列化过程，我们选择使用队列来存储表示树结构的字符串序列。

在进行反序列化时，算法从队列中逐一取出元素。这里，我们首先检查队列的首元素（使用`peek`方法），以判断是否遇到了分隔符。如果当前元素不是分隔符，则表明该位置应当存在一个节点，我们据此创建一个新的节点，并进一步递归地重建该节点的左右子树。通过这种方式，我们能够根据前序遍历序列化的结果，逐步重建出原始的二叉树结构。

分隔符如下：

```java
private static final String SEPARATOR="#";
```

算法实现：

```java
private static void preOrderTraversal(Node root, Queue<String> ans) {
    if(root==null){
        ans.add(SEPARATOR);
        return;
    }
    ans.add(Integer.toString(root.value));
    preOrderTraversal(root.left,ans);
    preOrderTraversal(root.right,ans);
}
private static Node reconstructByPre(Queue<String> strings) {
    if(Objects.equals(strings.peek(), SEPARATOR)){
        return null;
    }
    Node node = new Node(Integer.parseInt(strings.poll()));
    node.left=reconstructByPre(strings);
    node.right=reconstructByPre(strings);
    return node;
}
```

### （2）层序遍历实现

分析：在通过层序遍历进行二叉树的序列化过程中，关键是使用一个队列来存储树中的节点，以便按层次进行遍历。在这个遍历过程中，我们会遇到两种情况：非空节点和空节点。对于非空节点，我们直接记录其值；而对于空节点，虽然它们不会被实际存储为树的一部分，我们仍需要在序列化的字符串中用特定的分隔符（如"#"）来标记它们的位置。这样做的目的是保留树结构的完整信息，包括那些不存在的子节点，确保在反序列化过程中能够准确地重建原始树结构。

在反序列化中，我们同样利用一个队列来处理节点，但这次是为了按照层序的顺序逐层重建树。从字符串队列中逐个取出元素，每个元素要么是一个有效的节点值，要么是代表空节点的分隔符。对于有效的节点值，我们创建新的节点并将其添加到当前正在构建的树中；而遇到分隔符时，则对应地在树中添加一个空指针。在处理完一个节点的左右子节点后，我们将这些子节点（非空）加入到队列中，以便继续按层序重建树的后续部分。

```java
private static void levelTraversal(Node root, Queue<String> ans) {
    Queue<Node> nodeQueue = new LinkedList<>();
    nodeQueue.add(root);
    while(!nodeQueue.isEmpty()){
        Node cur=nodeQueue.poll();
        if(cur!=null){
            ans.add(Integer.toString(cur.value));
            nodeQueue.add(cur.left);
            nodeQueue.add(cur.right);
        }else{
            ans.add(SEPARATOR);
        }
    }
}
private static Node reconstructByLevel(Queue<String> strings) {
    if(strings.isEmpty()){
        return null;
    }
    Queue<Node> nodeQueue = new LinkedList<>();
    Node root = new Node(Integer.parseInt(strings.poll()));
    nodeQueue.add(root);
    while(!nodeQueue.isEmpty()){
        Node cur=nodeQueue.poll();
        cur.left=generateNode(strings.poll());
        cur.right=generateNode(strings.poll());
        if(cur.left!=null){
            nodeQueue.add(cur.left);
        }
        if(cur.right!=null){
            nodeQueue.add(cur.right);
        }
    }
    return root;
}
public static Node generateNode(String string){
    if(Objects.equals(string,SEPARATOR)){
        return null;
    }
    return new Node(Integer.parseInt(string));
}
```

## 4.Encode N-ary Tree to Binary Tree

题目：给定一个N叉树的根节点，你需要实现两个函数：

1. `encode`函数，将给定的N叉树编码为一个二叉树。
2. `decode`函数，将上一步骤得到的二叉树解码回原始的N叉树。

编码和解码的策略需要自己设计，但必须确保编码后的二叉树能够完全还原成原来的N叉树。

### （1）encode

分析：在进行N叉树到二叉树的编码（`encode`）过程中，关键在于合理利用二叉树节点的“左子节点”和“右兄弟节点”位置，以保存N叉树中节点的所有子节点信息。具体做法是将N叉树节点的第一个子节点映射为相应二叉树节点的左子节点。对于N叉树节点的其余子节点，则按顺序将它们链接成左子节点的右侧链条，即每个子节点成为其前一个子节点在二叉树中的右子节点。

这种编码策略的核心思想是，在二叉树中，任一节点的左子节点代表其在N叉树中的第一个直接子节点，而该左子节点的右边界（即该节点及其右子节点形成的链）则代表了在N叉树中同一父节点下的所有子节点。通过这种方式，不仅能够保留原N叉树中父子关系的完整性，还能够准确地反映兄弟节点之间的顺序关系。因此，通过选择父节点的左孩子的右边界进行子节点的插入，我们能够有效地将N叉树编码为二叉树，且该过程是可逆的，从而支持后续的解码过程。

```java
public static BTNode encode(Node root){
    if(root==null){
        return null;
    }
    BTNode newRoot = new BTNode(root.val);
    newRoot.left=encodeProcess(root.children);
    return newRoot;
}

private static BTNode encodeProcess(List<Node> children) {
    if(children==null|| children.isEmpty()){
        return null;
    }
    BTNode root = null;
    BTNode cur = null;
    for (Node child:children){
        BTNode node = new BTNode(child.val);
        node.left=encodeProcess(child.children);
        if(root==null){
            root=node;
            cur=node;
        }else {
            cur.right=node;
        }
    }
    return root;
}
```

### （2）decode

分析：在解码（`decode`）过程中，我们的目标是从已编码的二叉树结构中重建原始的N叉树。在编码阶段，我们将N叉树的子节点通过二叉树的左子节点和右兄弟节点来表示，其中每个节点的左子节点代表其在N叉树中的第一个子节点，而其右子节点（如果有的话）则代表同一父节点下的下一个兄弟节点。因此，二叉树中任意节点的左子树（通过其右边界）实际上代表了N叉树中该节点的所有子节点。

具体到解码实现上，我们首先确定每个二叉树节点的左子节点作为N叉树中对应节点的第一个子节点。然后，遍历这个左子节点的整个右边界，将遇到的每个节点转换为N叉树节点，并将它们收集为原节点的子节点列表。这样，通过递归地对每个二叉树节点执行此操作，我们可以恢复出每个N叉树节点的完整子节点列表。

此解码方法确保了从二叉树到N叉树的转换能够准确无误地重建原始树的结构，不仅恢复了所有的父子关系，也保持了子节点间的顺序关系不变。通过这种方式，我们完成了从编码的二叉树结构到原始N叉树结构的准确转换。

```java
private static Node decode(BTNode root) {
    if(root==null){
        return null;
    }
    Node newRoot = new Node(root.val);
    newRoot.children=decodeProcess(root.left);
    return newRoot;
}

private static List<Node> decodeProcess(BTNode root) {
    if(root==null){
        return null;
    }
    ArrayList<Node> nodes = new ArrayList<>();
    while(root!=null){
        Node node = new Node(root.val);
        node.children=decodeProcess(root.left);
        nodes.add(node);
        root=root.right;
    }
    return nodes;
}
```

## 5.后继节点

**题目：**给定一个二叉搜索树（BST）的一个节点，你需要找到该节点在中序遍历顺序下的后继节点。树中的节点除了有左右孩子指针外，还有一个指向父节点的指针。如果目标节点没有后继节点，则返回`null`。

**分析：**在二叉搜索树中，寻找任一节点的后继节点，即在中序遍历序列中该节点之后的节点，可以归纳为两种主要情形：节点拥有右子树，和节点不拥有右子树。

1. **当节点拥有右子树时**，其后继节点是该节点右子树中的左边界终点，具体地，是该右子树的最左侧节点。这是因为在中序遍历中，该节点的所有右侧子节点都在其之后被遍历，而最左侧节点是其中最先被遍历的。因此，从给定节点的右子节点出发，沿着左子节点一直向下遍历，直到达到最左侧节点，即找到了后继节点。
2. **当节点不拥有右子树时**，其后继节点是该节点的最低的“左祖先”节点，即在向上追溯其祖先节点过程中，第一个作为左子节点的祖先的父节点。这是因为在没有右子树的情况下，该节点在中序遍历序列中的下一个节点将是其向上路径中第一次作为左子节点的那个祖先节点的父节点。如果该节点在向上遍历过程中一直是其祖先的右子节点，这意味着它位于中序遍历的一个终点，因而它没有后继节点，此时应返回`null`。

```java
public static Node getSuccessorNode(Node node){
    if(node==null){
        return null;
    }
    if(node.right!=null){
        Node tmp=node.right;
        while(tmp.left!=null){
            tmp=tmp.left;
        }
        return tmp;
    }else {
        Node parent=node.parent;
        while(parent!=null&&parent.right==node){
            parent=parent.parent;
        }
        return parent;
    }
}
```

## 6.折纸问题

题目：请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 

分析：在连续对折纸条的过程中，每一次对折都会在现有折痕之间插入新的折痕，而新出现的折痕遵循一个明确的模式：在上方的折痕总是凹形（向下），在下方的折痕总是凸形（向上）。这种规律反映了一种固有的顺序，正如中序遍历二叉树时左根右的顺序一样，可以将每次对折过程中产生的折痕视为二叉树中的节点。

具体到实现，我们可以通过模拟中序遍历来从上到下打印所有折痕的方向。在这种方法中：

- 对于任意给定的对折次数`N`，我们可以构造一个虚拟的二叉树，其中每个节点代表一个折痕，节点的值表示折痕的方向（凹或凸）。
- 节点的左子树代表该折痕上方的折痕（总是凹形），而右子树代表该折痕下方的折痕（总是凸形）。
- 通过递归地中序遍历这个虚拟的二叉树，我们可以按照上到下的顺序打印出所有折痕的方向。

```java
public static void allFolding(int n){
    process(n,false);
}
public static void process(int n,boolean fold){
    if(n==0){
        return;
    }
    n--;
    process(n,false);
    if(fold){
        System.out.println("up");
    }else{
        System.out.println("down");
    }
    process(n,true);
}
```

# class12

## 1.二叉树是否是完全二叉树

**题目：**二叉树是否是完全二叉树

**分析：**要准确判断一棵树是否是完全二叉树，关键在于检查其各层节点是否从左到右依次填满，直至最后一层。在进行层次遍历时，我们遵循以下准则：若某节点的右子节点存在而左子节点不存在，则该树不能是完全二叉树；如果遇到一个节点没有右子节点（无论是否有左子节点），则从该节点开始，后续遍历到的所有节点都必须是叶子节点，即它们都没有子节点。如果在遍历过程中所有节点都满足这一条件，那么我们可以得出结论，这棵树是一棵完全二叉树。

```java
public class IsCBT {
    public static class Node{
        public Node left;
        public Node right;
        Node(){}
    }
    public static boolean isCBT(Node root){
        if(root==null){
            return true;
        }
        LinkedList<Node> queue=new LinkedList<>();
        queue.add(root);
        boolean startLeaf=false;
        while(!queue.isEmpty()){
            Node cur=queue.poll();
            Node left=cur.left;
            Node right=cur.right;
            if((left==null&&right!=null) || (startLeaf&&(left!=null||right!=null))){
                return false;
            }
            if(left!=null){
                queue.add(left);
            }
            if(right!=null){
                queue.add(right);
            }
            if(left!=null&&right==null){
                startLeaf=true;
            }
        }
        return true;
    }
}
```

## 2.二叉树的递归解法框架

> 解决大部分二叉树dp问题

1. **定义问题**：首先定义你想要解决的问题。这个问题可以是计算二叉树的某个属性（例如高度、平衡性、最大路径和等），或者是对二叉树进行某种转换（例如镜像、序列化等）。

2. **假设子树解已知**：对于二叉树中的任意节点X，假设你已经知道了其左子树和右子树的相关信息。这些信息可以是子树的深度、子树中的最大值、子树是否满足某个条件等。

3. **合并子树信息**：在上述假设基础上，探讨如果以X为根节点的树，如何结合X节点的信息及其左、右子树的信息，来解答整个问题。这一步骤通常涉及到考虑不同情况下的答案如何通过左、右子树的信息组合得到。

4. **明确信息需求**：明确你需要从左子树和右子树中获取哪些具体信息，以便能够合并这些信息来解决以X为根的树的问题。

5. **设计全集信息S**：确定一个信息结构S，这个结构包含了解决问题所需的所有信息。递归函数应当返回这个信息结构S，以确保每个子树都按此要求提供信息。

6. **实现递归函数**：根据上述框架，实现递归函数。在函数内部，先递归调用左右子树获取信息，然后根据这些信息加上当前节点的信息来计算当前树的答案，并返回信息结构S。

## 3.二叉树是不是平衡二叉树

**题目：**二叉树是不是平衡二叉树

**分析：**为了判断一个二叉树是否为平衡二叉树，关键在于利用二叉树的高度属性和平衡条件进行判断。我们以任意节点X为根节点的树为例，首先收集其左右子树的相关信息，包括子树是否平衡以及子树的高度。基于这些信息，我们进一步构建并返回给父节点的信息。

在决定如何构建并返回这些信息的过程中，我们需要考虑所有可能的情况。对于本问题，一个节点X的树要被认为是平衡的，必须满足以下两个条件：

1. 左右子树都必须是平衡的。
2. 左右子树的高度差不能超过1。

当这两个条件同时满足时，我们可以确定以节点X为根的树是平衡的。此外，该树的高度被定义为其左右子树的最大高度加1。这个高度值随后被用于父节点的平衡判断和高度计算中。

通过递归地应用以上逻辑，我们可以有效地从下往上逐层检查每个节点，以判断整棵二叉树是否为平衡二叉树。这种方法不仅确保了检查的全面性，也保证了处理的效率，因为它避免了重复计算子树的高度和重复判断子树的平衡状态。

```java
public class IsBalance {
    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }
    public static class Info{
        public boolean isBalanced;
        public int height;
        public Info(boolean i, int h) {
            isBalanced = i;
            height = h;
        }
    }
    private static Info process(Node root){
        if(root==null){
            return new Info(true,0);
        }
        Info leftInfo=process(root.left);
        Info rightInfo = process(root.right);
        boolean isBalanced=false;
        int height=Math.max(leftInfo.height, rightInfo.height)+1;
        if(leftInfo.isBalanced&&rightInfo.isBalanced){
            if(Math.abs(leftInfo.height-rightInfo.height)<2){
                isBalanced=true;
            }
        }
        return new Info(isBalanced,height);
    }
    private static boolean isBalancedBT(Node root){
        return process(root).isBalanced;
    }
}
```

## 4.二叉树是不是搜索二叉树

**题目：**二叉树是不是搜索二叉树

**分析：**要准确判断一个二叉树是否是二叉搜索树，关键在于评估每个节点及其左右子树之间的关系。具体来说，我们需要关注以下几个方面：

1. 对于树中的任意节点X，我们首先需要获取其左右子树的关键信息：这些子树是否各自为二叉搜索树，以及它们的最大和最小值。

2. 在收集到这些信息的基础上，我们针对节点X进一步构建并返回包含该节点信息的数据结构。由于基础情况（base case）即空节点不便于直接建立信息，因此我们选择在此情况下返回`null`，留给调用者（通常是X的父节点）来处理。

3. 在整合左右子树的信息时，若左右子树信息均非空，我们将对这些信息进行分析。具体而言，我们将比较并更新当前节点树的最大值和最小值：最大值为左子树最大值、右子树最大值以及节点X值的最大者；最小值则由左子树最小值、右子树最小值以及节点X值的最小者确定。

4. 接下来，我们需要对当前节点的二叉搜索树属性进行判断：如果左子树存在但不是二叉搜索树，或者左子树的最大值大于节点X的值；或者右子树存在但不是二叉搜索树，或者右子树的最小值小于节点X的值，则以节点X为根的树不能被认为是二叉搜索树。

5. 根据上述评估，我们构建并返回包含当前节点树信息的数据结构，以便上级节点根据这些信息做出进一步判断。

```java
public class IsBST {
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        Node(int value){this.value=value;}
    }
    public static class Info{
        public int max;
        public int min;
        public Boolean isBST;
        public Info(boolean i, int max, int min) {
            isBST = i;
            this.max = max;
            this.min = min;
        }
    }
    private static Info process(Node root){
        if(root==null){
            return null;
        }
        Info leftInfo=process(root.left);
        Info rightInfo=process(root.right);
        boolean isBST=true;
        int max=root.value;
        int min=root.value;
        if(leftInfo!=null){
            max=Math.max(leftInfo.max,max);
            min=Math.min(leftInfo.min,min);
        }
        if(rightInfo!=null){
            max=Math.max(rightInfo.max,max);
            min=Math.min(rightInfo.min,min);
        }
        if (leftInfo != null && (!leftInfo.isBST||leftInfo.max >= root.value)) {
            isBST = false;
        }
        if (rightInfo != null && (!rightInfo.isBST||rightInfo.min <= root.value)) {
            isBST = false;
        }
        return new Info(isBST,max,min);
    }
    public static boolean isBST(Node root){
        if(root==null){
            return true;
        }
        return process(root).isBST;
    }
}
```

## 5.二叉树是不是满二叉树

**题目：**二叉树是不是满二叉树

**分析：**为了判断一个二叉树是否为满二叉树，关键在于考虑二叉树的子树是否是满二叉树以及子树的高度。

我们对任意节点X，首先获取其左右子树的相关信息，在决定如何整合并返回这些信息的过程中，一个节点X的树要被认为是满二叉树的条件：

1. 其左右子树都是满二叉树；
2. 其左右子树的高度完全相同。

当这两个条件都满足时，可以确定以节点X为根的树是满二叉树。此外，我们将该树的高度定义为其左右子树的最大高度加1，这个高度值用于上层节点的满二叉树判断和高度计算。

通过递归地应用上述逻辑，我们可以从下往上逐层检查每个节点，判断整棵二叉树是否为满二叉树。这种方法的优点在于它确保了判断的全面性和效率，避免了重复计算子树的高度和重复判断子树是否满足满二叉树的条件。

```java
public class IsFull {
    public static class Node{
        public Node left;
        public Node right;
        Node(){}
    }
    private static class Info{
        public boolean isFull;
        public int height;
        Info(boolean isFull,int height){
            this.isFull=isFull;
            this.height=height;
        }
    }
    private static Info process(Node root){
        if(root==null){
            return new Info(true,0);
        }
        Info leftInfo=process(root.left);
        Info rightInfo=process(root.right);
        boolean isFull=false;
        int height=Math.max(leftInfo.height,rightInfo.height)+1;
        if(leftInfo.isFull&&rightInfo.isFull){
            if(leftInfo.height==rightInfo.height){
                isFull=true;
            }
        }
        return new Info(isFull,height);
    }
    public static boolean isFull(Node root){
        return process(root).isFull;
    }
}
```

## 6.返回整棵二叉树的最大距离

**题目：**返回整棵二叉树的最大距离

**分析：**为了准确计算整棵二叉树中任意两节点间的最大距离，每个子树需要向其父节点传递两项关键信息：该子树的最大距离和高度。具体来说，当我们以节点X为当前的根节点时，可以通过以下步骤计算：

1. **计算当前树的高度**：当前树的高度是其左右子树高度的最大值加1。这反映了从当前节点到其最远叶子节点的路径长度。
2. **确定当前树的最大距离**：在考虑当前节点X时，树的最大距离可能来源于三个方面：
   - 左子树内部的最大距离。
   - 右子树内部的最大距离。
   - 经过当前节点X连接左右子树的路径，这个路径的长度为左子树的高度加上右子树的高度加1。

通过对这三个方面的比较，我们可以确定以节点X为根的树的最大距离。然后，这个信息被封装在一个Info对象中，包括计算得到的树高度和最大距离，递归地返回给上一级节点。

最终，通过递归地应用上述逻辑，从叶节点逐层向上直至根节点，我们可以有效地计算出整棵二叉树的最大距离。

```java
public class MaxDistance {
    public static class Node{
        public Node left;
        public Node right;
        Node(){}
    }
    private static class Info{
        public int height;
        public int maxDistance;
        public Info(int height, int maxDistance) {
            this.height = height;
            this.maxDistance = maxDistance;
        }
    }
    private static Info process(Node root){
        if(root==null){
            return new Info(0,0);
        }
        Info leftInfo = process(root.left);
        Info rightInfo = process(root.right);
        int height=Math.max(leftInfo.height,rightInfo.height)+1;
        int maxDistance=Math.max(leftInfo.maxDistance, Math.max(rightInfo.maxDistance, leftInfo.height)+ rightInfo.height+1);
        return new Info(height,maxDistance);
    }
    public static int maxDistance(Node root){
        return process(root).maxDistance;
    }
}
```

## 7.二叉树中最大的二叉搜索子树的大小

**题目：**二叉树中最大的二叉搜索子树的大小。

**分析：**为了确定以任意节点X为根的二叉树中最大的二叉搜索树子树的大小，我们需要从该节点的左右子树获取关键信息，包括子树中最大的二叉搜索树的大小、子树的最大值和最小值，以及子树的总节点数。通过这些信息，我们能判断整棵树是否构成二叉搜索树，以及计算其作为二叉搜索树时的节点总数。

具体实现步骤如下：

1. **基础信息的初始化**：对于每个节点X，首先确定其作为树根时树的最大值和最小值，这通常是X的值，以及整棵树的大小，初始值为1（仅包括X本身）。
2. **左右子树的信息整合**：通过递归地处理左右子树，获取左右子树的信息。如果左子树和右子树均为二叉搜索树，且节点X的值大于左子树的最大值且小于右子树的最小值，那么以X为根的整棵树也构成二叉搜索树。此时，整棵树的大小为左右子树大小之和加上1。
3. **最大二叉搜索树子树的大小计算**：最大二叉搜索树子树的大小为左右子树中最大二叉搜索树子树的大小，以及当前节点X为根的二叉搜索树大小（如果条件满足）中的最大值。

通过上述步骤，我们可以递归地计算每个节点为根的子树中最大二叉搜索树的大小，并最终确定整棵树中最大的二叉搜索树子树的大小。这种方法不仅直观且高效，而且通过聚焦于每个节点如何贡献于整棵树的二叉搜索树属性，使得问题的解决变得既直观又高效。

```java
public class MaxSubBSTSize {
    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int value) {
            this.value = value;
        }
    }
    public static class Info{
        public int MaxSubBSTSize;
        public int max;
        public int min;
        public int size;

        public Info(int maxSubBSTSize, int max, int min, int size) {
            MaxSubBSTSize = maxSubBSTSize;
            this.max = max;
            this.min = min;
            this.size = size;
        }
    }
    private static Info process(Node root){
        if(root==null){
            return null;
        }
        Info leftInfo = process(root.left);
        Info rightInfo = process(root.right);
        int max=root.value;
        int min=root.value;
        int size=1;
        int maxSubBSTSize=0;
        if(leftInfo!=null){
            max= Math.max(leftInfo.max,max);
            min= Math.min(leftInfo.min,min);
            size+= leftInfo.size;
            maxSubBSTSize= leftInfo.MaxSubBSTSize;
        }
        if(rightInfo!=null){
            max= Math.max(rightInfo.max,max);
            min= Math.min(rightInfo.min,min);
            size+= rightInfo.size;
            maxSubBSTSize=Math.max(maxSubBSTSize, rightInfo.MaxSubBSTSize);
        }
        boolean leftBST = leftInfo == null ? true : (leftInfo.MaxSubBSTSize == leftInfo.size);
        boolean rightBST = rightInfo == null ? true : (rightInfo.MaxSubBSTSize == rightInfo.size);
        if(leftBST&&rightBST){
            boolean leftMaxLessValue=leftInfo==null?true:(leftInfo.max< root.value);
            boolean rightMaxLessValue=rightInfo==null?true:(rightInfo.min> root.value);
            if(leftMaxLessValue&&rightMaxLessValue){
                int leftSize = leftInfo == null ? 0 : leftInfo.size;
                int rightSize = rightInfo == null ? 0 : rightInfo.size;
                maxSubBSTSize = Math.max(maxSubBSTSize,leftSize + rightSize + 1);
            }
        }
        return new Info(maxSubBSTSize,max,min,size);
    }
    public static int maxSubBSTSize(Node root){
        if(root==null){
            return 0;
        }
        return process(root).MaxSubBSTSize;
    }
    
}
```

对`Info`类的构造器调用进行了更正，确保在根节点为`null`的情况下正确处理最大值和最小值

```java
private static Info process1(Node root){
        if(root == null){
            return new Info(0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0); // 使用Integer.MIN_VALUE和Integer.MAX_VALUE处理null的情况
        }
        Info leftInfo = process(root.left);
        Info rightInfo = process(root.right);

        // 更新当前节点的最大和最小值
        int max = Math.max(root.value, Math.max(leftInfo.max, rightInfo.max));
        int min = Math.min(root.value, Math.min(leftInfo.min, rightInfo.min));

        int size = 1 + leftInfo.size + rightInfo.size; // 当前树的节点总数

        // 判断左右子树是否是BST
        boolean isLeftBST = leftInfo == null || (leftInfo.MaxSubBSTSize == leftInfo.size && leftInfo.max < root.value);
        boolean isRightBST = rightInfo == null || (rightInfo.MaxSubBSTSize == rightInfo.size && rightInfo.min > root.value);

        int maxSubBSTSize = Math.max(leftInfo.MaxSubBSTSize, rightInfo.MaxSubBSTSize); // 默认为左右子树的最大BST大小

        // 如果当前节点的左右子树都是BST，并且当前节点值大于左子树的最大值，小于右子树的最小值
        if(isLeftBST && isRightBST){
            maxSubBSTSize = size; // 当前节点为根的树是BST，更新最大BST的大小
        }
        return new Info(maxSubBSTSize, max, min, size);
    }

```

# class13

## 1.二叉树是否是完全二叉树

**题目：**二叉树是否是完全二叉树（使用递归）

**分析：**在判断一个二叉树是否为完全二叉树时，需要从其左右子树中获取关键信息：是否为完全二叉树，是否为满二叉树，以及树的高度。这些信息对于决定当前节点所代表的树是否满足完全二叉树的条件至关重要。

完全二叉树的定义要求所有层都是满的，除了可能的最后一层。而在最后一层，所有的叶子都集中在左边，并且最后一层的叶子是连续的。基于这一定义，可以具体化为以下几点：

1. **左满右满，高度相等**：这种情况下的二叉树既是满二叉树也是完全二叉树。因为满二叉树自然满足完全二叉树的所有条件。
2. **左满右完全，高度相等**：这表示左子树已经填满，而右子树虽然不是满的，但是因为它是完全的并且与左子树高度相同，所以整棵树还是完全二叉树。
3. **左完全右满，左高度比右高度多1**：这是一个特殊情况，左子树是完全但不满，右子树是满的，并且左子树比右子树高一个层级，整棵树因此成为完全二叉树。这种情况考虑的是最后一层未完全填满的情况，但所有叶子都集中在左侧。
4. **左满右满，左高度比右高度多1**：这种情况下，虽然两边都是满二叉树，但由于左子树比右子树高一个层级，整体上，这棵树也满足完全二叉树的定义。

综合这些条件，可以设计一个递归算法，通过自底向上的方式，从叶子节点开始向根节点汇报信息，包括子树是否是完全二叉树、是否是满二叉树以及子树的高度。通过这些信息，能够判断出任意给定的二叉树是否是一个完全二叉树。

```java
public class IsCBT {
    public static class Node{
        public Node left;
        public Node right;
        Node(){}
    }
    public static class Info{
        public boolean isCBT;
        public boolean isFull;
        public int height;
        public Info(boolean isCBT, boolean isFull, int height) {
            this.isCBT = isCBT;
            this.isFull = isFull;
            this.height = height;
        }
    }
    public static Info process(Node root){
        if (root==null){
            return new Info(true,true,0);
        }
        Info leftInfo=process(root.left);
        Info rightInfo=process(root.right);
        boolean IsCBT=false;
        boolean IsFull=false;
        int height= Math.max(leftInfo.height, rightInfo.height)+1;
        if(leftInfo.isFull&&rightInfo.isFull){
            if(leftInfo.height==rightInfo.height){
                IsCBT=true;
                IsFull=true;
            }
            if(leftInfo.height-rightInfo.height==1){
                IsCBT=true;
            }
        }
        if(leftInfo.isCBT&&rightInfo.isFull&&leftInfo.height- rightInfo.height==1){
            IsCBT=true;
        }
        if(leftInfo.isFull&& rightInfo.isCBT&&leftInfo.height-rightInfo.height==1){
            IsCBT=true;
        }
        return new Info(IsCBT,IsFull,height);
    }
    public static boolean isCBT(Node root){
        return process(root).isCBT;
    }

}
```

## 2.二叉树中最大的二叉搜索子树的头节点

**题目：**二叉树中最大的二叉搜索子树的头节点

**分析：**本题目的是找到给定二叉树中最大的二叉搜索子树（BST）的根节点。为了实现这一目标，需要采用自底向上的递归策略，从每个节点收集特定的信息，这些信息包括：

1. **最大二叉搜索子树的根节点**：该信息指明了以当前节点为根的子树中，最大的BST的根节点。
2. **最大二叉搜索子树的节点数量**：这是用于比较和判断的关键数据，帮助我们确定哪个子树包含的BST节点最多。
3. **当前子树的最大值和最小值**：这些值用于判断当前子树是否满足BST的条件，即所有左子节点的值都小于根节点的值，所有右子节点的值都大于根节点的值。

其中优化了是否是BST的判断以及树的全部节点数量，可以通过其他信息进行推测。

通过整合左右子树的信息，可以判断当前节点的子树是否为BST。如果当前节点满足以下条件，则认为它是BST的根节点：

- 当前节点的值大于左子树的最大值且小于右子树的最小值。
- 左右子树都是BST（通过左右最大二叉搜索子树的根节点是否是其左右节点）。

在这种情况下，当前节点的子树是BST，我们更新最大BST的相关信息，包括根节点、最大和最小值、以及节点数量（左子树的节点数量加右子树的节点数量再加一）。

如果当前节点的子树不满足BST的条件，我们则需要比较左右子树的最大BST节点数量，选择较大者作为当前最大BST的代表。

通过这种方式，我们不仅能找到最大的BST的根节点，还能确保算法的效率，因为每个节点仅被访问和处理一次。这个过程从树的底部开始，逐级向上，直至整棵树被递归处理完成。

```java
package com.lxy.class13;

public class MaxSubBSTHead {
    public static class Node{
        public int value;
        public Node left;
        public Node right;

        public Node(int value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
    public static class Info{
        public int maxSubBSTSize;
        public Node maxSubBSTHead;
        public Integer max;
        public Integer min;

        public Info(int maxSubBSTSize, Node maxSubBSTHead, Integer max, Integer min) {
            this.maxSubBSTSize = maxSubBSTSize;
            this.maxSubBSTHead = maxSubBSTHead;
            this.max = max;
            this.min = min;
        }
        public static Info process(Node root){
            if(root==null){
                return new Info(0,null,Integer.MAX_VALUE,Integer.MIN_VALUE);
            }
            Info leftInfo=process(root.left);
            Info rightInfo=process(root.right);
            int max= Math.max(root.value,Math.max(leftInfo.max,rightInfo.max));
            int min= Math.min(root.value, Math.min(leftInfo.min, rightInfo.min ));
            int maxSubBSTSize= Math.max(leftInfo.maxSubBSTSize, rightInfo.maxSubBSTSize);
            Node maxSubBSTHead=leftInfo.maxSubBSTSize> rightInfo.maxSubBSTSize?leftInfo.maxSubBSTHead:rightInfo.maxSubBSTHead;
            if(leftInfo.maxSubBSTHead==root.left&&rightInfo.maxSubBSTHead==root.right&&leftInfo.max<root.value&&rightInfo.min> root.value){
                maxSubBSTHead=root;
                maxSubBSTSize=leftInfo.maxSubBSTSize+ rightInfo.maxSubBSTSize+1;
            }
            return new Info(maxSubBSTSize,maxSubBSTHead,max,min);
        }
        public static Node maxSubBSTHead(Node root){
            return process(root).maxSubBSTHead;
        }
    }
}
```

## 3.返回最低公共祖先

**题目：**给定一棵二叉树的头节点head和另外两个节点a、b，返回a和b的最低公共祖先

**分析：**

1. **信息收集**：对于任意一个节点X（作为当前考察的根节点），我们需要收集以下三个关键信息：
   - 该节点的子树中是否存在节点a。
   - 该节点的子树中是否存在节点b。
   - 该节点的子树中是否已经找到了节点a和b的最低公共祖先（LCA）。

2. **递归逻辑**：递归地对每个节点的左右子树进行上述信息的收集。基于收集到的信息，我们可以按照以下逻辑更新当前节点的状态：
   - 如果当前节点即为a或b，那么我们直接更新该节点的子树中包含a或b的相关信息。
   - 如果当前节点不是a或b，我们则需要根据其左右子树的信息来判断当前节点是否是a和b的最低公共祖先。

3. **判断最低公共祖先**：
   - 如果当前节点是a或b之一，并且其左子树或右子树中包含另一个节点，则当前节点是LCA。
   - 如果当前节点不是a或b，但其左右子树分别包含a和b，则当前节点同样是LCA。
   - 如果左子树或右子树已经找到了LCA，则这个LCA也是当前节点的LCA。

4. **返回结果**：每个节点根据上述逻辑处理后，会返回一个包含三个关键信息的对象（或结构），用于向其父节点报告。整个过程从树的底部开始，逐层向上直到根节点，最终找到并返回最低公共祖先。

```java
import com.sun.xml.internal.ws.message.RootElementSniffer;

public class LowestAncestor {
    public static class Node{
        public int value;
        public Node left;
        public Node right;

        public Node(int value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }
    public static class Info{
        public boolean hasA;
        public boolean hasB;
        public Node lowestAncestor;

        public Info(boolean hasA, boolean hasB, Node lowestAncestor) {
            this.hasA = hasA;
            this.hasB = hasB;
            this.lowestAncestor = lowestAncestor;
        }
    }
    public static Info process(Node root,Node a,Node b){
        if(root==null){
            return new Info(false,false,null);
        }
        Info leftInfo=process(root.left,a,b);
        Info rightInfo=process(root.right,a,b);
        boolean hasA=root==a|| leftInfo.hasA|| rightInfo.hasA;
        boolean hasB=root==b|| leftInfo.hasB|| rightInfo.hasB;
        Node lowestAncestor=null;
        if(leftInfo.lowestAncestor!=null){
            lowestAncestor=leftInfo.lowestAncestor;
        } else if(rightInfo.lowestAncestor!=null){
            lowestAncestor=rightInfo.lowestAncestor;
        }else {
            if(hasA&&hasB){
                lowestAncestor=root;
            }
        }
        return new Info(hasA,hasB,lowestAncestor);
    }
    public static Node lowestAncestor(Node root,Node a,Node b){
        return process(root,a,b).lowestAncestor;
    }
}
```

## 4.派对的最大快乐值

**题目：**公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。

Employee 类如下：

```java
class Employee {
    public int happy; // 这名员工可以带来的快乐值
    List<Employee> subordinates; // 这名员工有哪些直接下级
}
```

这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

- 如果某个员工来了，那么这个员工的所有直接下级都不能来
- 派对的整体快乐值是所有到场员工快乐值的累加
- 你的目标是让派对的整体快乐值尽量大

给定一棵多叉树的头节点boss，请返回派对的最大快乐值。

**分析：**

**算法思想**

1. **对于任意一个节点（员工）X**，我们考虑两种情况：
   - **X参加派对**：此时，X的直接下属都不能参加。因此，X带来的快乐值是X自己的快乐值加上所有直接下属不参加派对时带来的最大快乐值之和。
   - **X不参加派对**：此时，X的直接下属可以自由选择参加或不参加。因此，对于每个直接下属，我们都需要选择其参加派对和不参加派对时快乐值的较大者，并将这些值累加起来。
2. **基础情况**：如果X没有下属，那么X参加派对的最大快乐值就是X自己的快乐值，X不参加派对的最大快乐值为0。
3. **递归实现**：通过递归地处理每个节点（员工）和其所有下属，我们可以计算出根节点（即公司老板）参加或不参加派对时的最大快乐值，并从中选择较大者作为整个公司派对的最大快乐值。

**实现细节**

- 对于每个员工，我们定义一个`Info`类（或结构），其中包含两个字段：`comeMaxHappy`和`noComeMaxHappy`，分别表示员工参加派对和不参加派对时的最大快乐值。
- 通过递归地计算每个员工的这两个值，我们可以构建出一个动态规划的过程，自底向上地解决问题。

```java
import java.util.List;

public class MaxHappy {
    public static class Employee {
        public int happy; // 这名员工可以带来的快乐值
        List<Employee> subordinates; // 这名员工有哪些直接下级
    }
    public static class Info{
        public int comeMaxHappy;
        public int noNomeMaxHappy;

        public Info(int comeMaxHappy, int noNomeMaxHappy) {
            this.comeMaxHappy = comeMaxHappy;
            this.noNomeMaxHappy = noNomeMaxHappy;
        }
    }
    public static Info process(Employee employee){
        if(employee==null){
            return new Info(0,0);
        }
        int comeMaxHappy= employee.happy;
        int noComeMaxHappy=0;
        for (Employee e:employee.subordinates){
            Info info=process(e);
            comeMaxHappy+=info.noNomeMaxHappy;
            noComeMaxHappy+=Math.max(info.noNomeMaxHappy,info.comeMaxHappy);
        }
        return new Info(comeMaxHappy,noComeMaxHappy);
    }
    public static int maxHappy(Employee employee){
        Info info=process(employee);
        return Math.max(info.comeMaxHappy,info.noNomeMaxHappy);
    }
}
```

## 5.贪心算法（自然智慧）

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法策略。贪心算法在解决某些优化问题时非常有效，但它不保证总是达到最优解。关键在于能够通过局部最优解确保全局最优解，或者得到一个足够接近全局最优解的解。

### 贪心算法的特点

1. **局部最优选择**：在解决问题的每一步，贪心算法都会从当前可能的选择中寻找最优解，而不考虑整体问题的解决方案。
2. **无回溯**：一旦作出了选择，就不再改变。
3. **构造型算法**：通常用于求解最优化问题，如最小生成树、哈夫曼编码等。

### 贪心算法的应用场景

- **资源分配问题**：如背包问题（在不同的场景下可能需要使用贪心算法、动态规划等不同策略）。
- **图的最小生成树**：如Prim算法和Kruskal算法。
- **图的最短路径问题**：如Dijkstra算法。
- **数据压缩**：如哈夫曼编码。

### 贪心算法的局限性

虽然贪心算法简单高效，但它并不总能得到全局最优解，因为它总是寻找局部最优解而忽略了全局视图。因此，当使用贪心算法时，关键是要确保局部最优选择能够导致全局最优解。

## 6.字符串拼接最小字典序

**题目：**给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果。

**分析**：

**贪心策略：**通过比较两个字符串`x`和`y`拼接的结果`x+y`与`y+x`的字典序，可以决定`x`和`y`在最终结果中的相对顺序。这种策略确保了当字符串数组完全按照这个规则排序后，整体的字典序是最小的。

**实现要点:**

- **自定义比较器**：实现`Comparator<String>`接口，自定义比较逻辑，使得数组根据字符串拼接后的字典序进行排序。
- **数组排序**：使用`Arrays.sort`方法和自定义比较器对字符串数组进行排序。
- **字符串拼接**：遍历排序后的数组，使用`StringBuilder`（或类似的字符串构建工具）将所有字符串拼接成一个总字符串。

**示例**

假设输入数组为`["a", "ab", "aba"]`。根据贪心策略：

- 比较`"a"`和`"ab"`，由于`"aab"`的字典序小于`"aba"`，所以`"a"`应该在`"ab"`前面。
- 比较`"ab"`和`"aba"`，由于`"ababa"`的字典序小于`"abaab"`，所以`"ab"`应该在`"aba"`前面。
- 因此，排序后的数组为`["a", "ab", "aba"]`，拼接后的字符串为`"aababa"`。

```java
import java.util.Arrays;
import java.util.Comparator;

public class LowestLexicography {
    public static class MyComparator implements Comparator<String> {

        @Override
        public int compare(String o1, String o2) {
            return (o1+o2).compareTo(o2+o1);
        }
    }
    public static String lowestLexicography(String[] strings){
        if (strings == null || strings.length == 0) {
            return "";
        }
        Arrays.sort(strings,new MyComparator());
        StringBuilder ans= new StringBuilder();
        for (String s:strings){
            ans.append(s);
        }
        return ans.toString();
    }
}
```

# class14

## 1.会议室安排

**题目：**一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间，来安排宣讲的日程，要求会议室进行的宣讲的场次最多。

**分析：**

**贪心策略：**优先选择那些结束时间最早的活动，以此确保尽可能多的活动可以被安排在有限的时间内。此方法的直觉逻辑是，结束得越早的活动越能为之后的活动留出更多的空间，从而增加总体可安排活动的数量。

**实现要点：**

1. **活动按结束时间排序**：首先，需要按照活动的结束时间对所有活动进行升序排序。这一步是实施贪心策略的前提，确保我们在选择活动时，总是有机会先考虑那些结束最早的活动。
2. **使用时间线记录时间状态**：引入一个“时间线”变量，用于记录当前时间状态，即已安排活动的最晚结束时间。这有助于我们判断新的活动是否与已安排的活动冲突。
3. **依次考察每个活动**：遍历排序后的活动列表，对于每个活动，只有当它的开始时间不早于时间线时，才将其加入到已安排活动中，并更新时间线为该活动的结束时间。

```java
package com.lxy.class14;

import java.util.Arrays;
import java.util.Comparator;

public class BestArrange {
    public static class Program{
        public int start;
        public int end;
        public Program(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
    public static class MyComparator implements Comparator<Program> {

        @Override
        public int compare(Program o1, Program o2) {
            return o1.end-o2.end;
        }
    }
    public static int bestArrange(Program[] programs){
        if(programs==null||programs.length==0){
            return 0;
        }
        Arrays.sort(programs,new MyComparator());
        int timeLine=0;
        int ans=0;
        for (Program program:programs){
            if(program.start>=timeLine){
                ans++;
                timeLine=program.end;
            }
        }
        return ans;
    }
}
```

## 2.最低成本分割金条

**题目：**一群人希望共同分享一整块金条，每个人需要得到特定长度的金条。将这块金条分割成若干个指定长度的小段时，每次切割所需的成本等同于被切割金条当前的长度。目标是确定一个分割方案，使得整个切割过程的总成本最低。

例如，假设有一个长度为60的金条，需要分割为长度分别为10、20、30的三段。可以有多种分割方式，每种方式的总成本不同。

- 一种方式是首先将60长度的金条切割为10和50的两段，此时成本为60铜板。然后，再将长度为50的段切割为20和30的两段，此时额外成本为50铜板。这种方案的总成本为110铜板。
- 另一种更高效的方式是首先将60长度的金条切割为两段30和30，成本为60铜板。接着，将一段30长度的金条进一步切割为10和20的两段，此时额外成本为30铜板。这种方案的总成本为90铜板，显然更为经济。

给定一个代表各个人所需金条长度的数组和金条总长度，求出完成分割所需的最小总成本。

**分析：**

**贪心策略：**每次选择两个最小的金条进行合并。这个策略的基础假设是，合并成本与金条的长度成正比，因此在每一步合并最小的两块金条可以保证当前步骤的成本最低。由于每次合并后形成的新金条在后续的合并中可能会被再次选择，因此尽早以最低成本进行合并可以帮助减少总体成本。

该贪心策略的正确性基于这样一个事实：合并操作的成本随合并的金条长度增加而增加，而每次合并最小的两个金条保证了每步操作的局部最优，也就是说，在每个可能的合并操作中选择了成本最低的。虽然贪心算法通常只能保证局部最优解，但在这个特定问题中，局部最优解的累加恰好构成了全局最优解。

**实现要点：**

1. **使用最小堆**：代码中使用了`PriorityQueue`，一个最小堆的数据结构，来动态管理待合并的金条。最小堆保证了每次从中取出的两个金条是当前所有待合并金条中长度最短的，符合贪心选择的要求。
2. **循环合并过程**：通过一个循环，每次从堆中取出两个最小的金条进行合并，然后将合并后的新金条的长度（即本次合并的成本）累加到总成本中，并将新金条重新放入堆中，以待后续的合并。这个过程一直持续到堆中只剩下一个金条为止，此时的总成本即为问题的解。
3. **成本计算**：每次合并产生的成本等于两个被合并金条的长度之和。总成本是所有合并步骤成本的累加值。

```java
package com.lxy.class14;

import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

public class LessMoneySplitGold {
    public static int lessMoneySplitGold(int[]arr){
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        for(int e:arr){
            heap.add(e);
        }
        int cur=0;
        int sum=0;
        while (heap.size()!=1){
            cur=heap.poll()+ heap.poll();
            sum+=cur;
            heap.add(cur);
        }
        return sum;
    }
}
```

## 3.IPO项目选择

**题目：**给定一定数量的项目（`k`），初始资本（`w`），以及每个项目的成本和利润。目标是通过最多完成 `k` 个项目，从初始资本 `w` 出发，找到可以累积的最大资本。

**分析：**

**贪心策略：**

- 在有限的初始资本（W）条件下，贪心策略的关键是如何在多个可选项目中做出最有利的选择。通过先关注成本确保项目的可行性，然后在可行的项目中选择利润最高的，这一策略充分利用了初始资本，实现了资本的快速增长。
- 每完成一个项目，都会增加可用的资本（W）。这种动态更新的特性，使得随着每个项目的完成，可能会有新的项目符合成本要求而成为候选，因此需要反复迭代此过程直至达到项目数上限或没有符合条件的项目为止。

**实现要点**：

- **优先队列使用**：利用小根堆（`minCost`）管理项目的成本，保证每次都能访问到当前成本最低的项目。而大根堆（`maxProfit`）则管理已经由成本筛选过的项目的利润，确保每次都能选出利润最大的项目。这种双堆结构的设计巧妙地平衡了成本和利润两个维度的决策。
- **成本与资本的动态匹配**：初始资本作为筛选条件，筛选出所有当前阶段可行的项目（即成本小于等于当前资本的项目），将它们移入利润队列（大根堆）中。这一步骤确保了每次从利润队列中选出的项目都是在当前资本条件下可行的项目。
- **迭代与更新**：通过迭代这一过程，不断更新可用资本，并从利润队列中选择下一个项目，直到达到项目数上限或没有更多符合条件的项目为止。

```java
import java.util.Comparator;
import java.util.PriorityQueue;

public class IPO {
    public static class Program{
        public int cost;
        public int profit;

        public Program(int cost, int profit) {
            this.cost = cost;
            this.profit = profit;
        }
    }
    public static class MinCostComparator implements Comparator<Program>{

        @Override
        public int compare(Program o1, Program o2) {
            return o1.cost-o2.cost;
        }
    }
    public static class MaxProfitComparator implements Comparator<Program>{

        @Override
        public int compare(Program o1, Program o2) {
            return o2.profit-o1.profit;
        }
    }
    public static int findMaximizedCapital(int k, int w, int[] profits, int[] costs) {
        PriorityQueue<Program> minCost = new PriorityQueue<>(new MinCostComparator());
        PriorityQueue<Program> maxProfit = new PriorityQueue<>();
        for (int i = 0; i < profits.length; i++) {
            minCost.add(new Program(costs[i],profits[i]));
        }
        for (int i = 0; i < k; i++) {
            while(!minCost.isEmpty()&&minCost.peek().cost<=w){
                maxProfit.add(minCost.poll());
            }
            if(maxProfit.isEmpty()){
                return w;
            }
            w+=maxProfit.poll().profit;
        }
        return w;
    }

}
```

## 4.点灯

**题目：**给定一个代表道路情况的字符串，其中`.`表示空地，`X`表示障碍物，需要在空地上放置最小数量的灯，使得每个空地都被照亮。灯可以照亮放置它的那个位置以及相邻的位置。

**分析：**

**贪心策略：**在遇到连续的空地（`.`）时，放置灯的最优位置是在这一段连续空地的尽头，具体来说，是在最后一个空地或是最后一个空地之前（连续三个空地）。这种方法不仅能够保证当前空地被照亮，同时也能照亮前一个空地（如果存在），以及后一个空地（如果下一个位置是空地且不是字符串的末尾）。

**实现要点：**

- **遍历道路**：从头开始遍历表示道路的字符串。使用一个变量（如`i`）来跟踪当前的位置。
- **障碍物处理**：如果当前位置是障碍物（`X`），直接移动到下一个位置（`i++`）。
- **空地处理**：如果当前位置是空地（`.`），则需要在此位置尽可能靠后的位置放置一盏灯。放置灯后，根据后续位置的情况决定`i`的增加量：
  - 如果`i+1`位置是障碍物（`X`），则已经在最佳位置放置了灯，`i`直接跳到`i+2`。
  - 如果`i+1`位置也是空地，由于放置在`i+1`位置的灯可以照亮`i`位置和`i+2`位置，因此`i`可以跳过下一个空地，直接移动到`i+3`（考虑到灯的照明范围）。
- **边界判断**：在实现时，要注意检查`i`的值是否超过了字符串的长度，以避免数组越界异常。

```java
package com.lxy.class14;

import java.util.Arrays;

public class Light {
    public static int minLight(String road){
        char[] tmp= road.toCharArray();
        int ans=0;
        int i=0;
        while (i < tmp.length) {
            if(tmp[i]=='X'){
                i++;
            }
            else{
                ans++;
                if(i+1==tmp.length){
                    break;
                }
                if(tmp[i+1]=='.'){
                    i+=3;
                }else{
                    i+=2;
                }
            }
        }
        return ans;
    }
}
```

## 5.并查集概念

并查集（Union-Find）是一种数据结构，主要用于处理一些不交集的合并及查询问题。它支持两种操作：

1. **查找（Find）**：确定某个元素属于哪个子集。这可以用来确定两个元素是否属于同一个子集。
2. **合并（Union）**：将两个子集合并成一个集合。

理想情况下，查找、合并操作的时间复杂度可以接近O(1)。

**并查集的基本思想**

并查集通过数组来表示，数组中的每个元素都有一个父节点的指针，如果元素是集合的代表（或称为根节点），则它指向自己。通过这种方式，一个集合的所有元素可以形成一个树状结构。

- **初始化**：初始时，每个元素构成一个单元素的集合，即每个元素都是自己所在集合的代表。
- **查找**：为了找到元素的集合代表，从指定元素出发，沿着父节点的指针向上移动，直到找到根节点。根节点的特点是指向自己。
- **路径压缩**：在执行查找操作的过程中，为了优化后续的查找效率，可以实行路径压缩，即将查找路径上的每个节点都直接连接到根节点，这样可以减少后续查找的层数。
- **合并**：将两个元素所在的集合合并为一个集合，通常是将一个集合的根节点指向另一个集合的根节点。为了避免树过高影响效率，可以采取将较小的树合并到较大的树下面的策略。

解决两大块区域的合并问题，常用在图等领域中。

### （1）map实现

```java
public static class UnionFindByMap<V> {
    public HashMap<V,V> parent;
    public HashMap<V,Integer> size;
    UnionFindByMap(List<V> values){
        parent=new HashMap<>();
        size=new HashMap<>();
        for (V value:values){
            parent.put(value,value);
            size.put(value,1);
        }
    }
    public V find(V cur){
        Stack<V> stack = new Stack<>();
        while(cur!=parent.get(cur)){
            stack.add(cur);
            cur= parent.get(cur);
        }
        while(!stack.isEmpty()){
            parent.put(stack.pop(), cur);
        }
        return cur;
    }
    public void union(V x,V y){
        V rootX=find(x);
        V rootY=find(y);
        if(rootY!=rootX){
            Integer rankX=size.get(rootX);
            Integer rankY=size.get(rootY);
            if(rankX>rankY){
                parent.put(rootY,rootX);
                size.put(rootX,rankX+rankY);
                size.remove(rootY);
            }else{
                parent.put(rootX,rootY);
                size.put(rootY,rankX+rankY);
                size.remove(rootX);
            }
        }
    }
    public boolean isSameSet(V x,V y){
        return find(x)==find(y);
    }
}
```

### （2）数组实现

```java
public static class UnionFindByArray{
    public int[] parent;
    public int[] size;
    public int[] help;
    UnionFindByArray(int n){
        parent=new int[n];
        size=new int[n];
        help=new int[n];
        for (int i = 0; i < n; i++) {
            parent[i]=i;
            size[i]=1;
        }
    }
    public int find(int x){
        int i=0;
        while(x!=parent[x]){
            help[i++]=x;
            x=parent[x];
        }
        for (i--; i >=0; i--) {
            parent[help[i]]=x;
        }
        return x;
    }
    public void union(int x,int y){
        int rootX = find(x);
        int rootY = find(y);
        if(rootY!=rootX){
            if(size[rootX]>size[rootY]){
                parent[rootY]=rootX;
                size[rootX]+=size[rootY];
            }else {
                parent[rootX]=rootY;
                size[rootY]+=size[rootX];
            }
        }
    }
    public boolean isSameSet(int x,int y){
        return find(x)==find(y);
    }
}
```

# class15

## 1.Friend Circles

**题目：**给定一个表示朋友关系的二维数组（或邻接矩阵）`M`，找出这个网络中朋友圈的数量。在这个问题中，`M[i][j]`为1表示第`i`个人和第`j`个人是朋友，为0则不是。朋友圈是一组相互间直接或间接认识的朋友。

**分析：**

- **初始化独立集合**：初始时，将每个人视为一个独立的朋友圈。这符合并查集的初始状态，即每个元素自成一个集合，这里的每个元素就是每个人。
- **发现朋友关系时合并朋友圈**：在遍历朋友关系矩阵时，每当发现两个人是朋友（即矩阵中的元素值为1），就将这两个人所在的朋友圈合并。这一过程正是并查集中`union`操作的体现。
- **朋友圈数量的动态更新**：每次成功合并两个不同的朋友圈时，总的朋友圈数减1。这一过程通过维护一个表示当前朋友圈总数的变量来实现，该变量在每次合并操作后更新。
- **效率考量**：使用并查集处理朋友圈问题的效率非常高，因为并查集的`find`和`union`操作的时间复杂度接近常数级别。尤其是在实现中采用路径压缩和按秩合并等优化技巧后，可以进一步提高效率。
- **空间优化**：通过使用数组而非更复杂的数据结构，此实现在空间使用上也非常高效，尽管数组的大小需要预先定义，但它为常数级别的操作提供了基础，并且其常数时间远小于其他复杂的数据结构（map）。

```java
package com.lxy.class15;

import com.lxy.class14.UnionFind;

public class FriendCircles {
    public static class UnionFind{
        public int[] parent;
        public int[] size;
        public int[] help;
        public int sets;
        UnionFind(int n){
            parent=new int[n];
            size=new int[n];
            help=new int[n];
            sets=n;
        }
        public int find(int x){
            int i=0;
            while(x!=parent[x]){
                help[i++]=x;
                x=parent[x];
            }
            for (i--;i>=0;i--){
                parent[help[i]]=x;
            }
            return x;
        }
        public void union(int x,int y){
            int rootX = find(x);
            int rootY = find(y);
            if(rootY!=rootX){
                sets--;
                int sizeX = size[rootX];
                int sizeY = size[rootY];
                if (sizeX>sizeY){
                    parent[rootY]=rootX;
                    size[rootX]=sizeX+sizeY;
                }else{
                    parent[rootX]=rootY;
                    size[rootY]=sizeX+sizeY;
                }
            }
        }
        public int getSets(){
            return sets;
        }
    }
    public static int friendCircleNum(int[][] matrix){
        int n=matrix.length;
        UnionFind unionFind = new UnionFind(n);
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                if(M[i][j]==1){
                    unionFind.union(i,j);
                }
            }
        }
        return unionFind.getSets();
    }
}
```

## 2.岛屿问题

**题目：**在给定的二维矩阵`matrix`中，每个元素要么是`1`（代表陆地），要么是`0`（代表水域）。当两个陆地单元格在水平或垂直方向上相邻时，它们被视为属于同一片岛屿。本题的目标是计算出矩阵`matrix`中总共有多少片这样的岛屿。请编写一个函数，返回矩阵中岛屿的总数量。

### （1）递归

**分析：**

1. **遍历网格**：通过双重循环遍历整个网格。
2. **发现岛屿**：每当遇到一个为`'1'`的单元格，岛屿计数器`islands`增加1，并调用`infect`方法来对这个岛屿进行“感染”处理。
3. **“感染”过程**：`infect`方法递归地将与当前单元格相连的所有`'1'`单元格标记为`'0'`，这个过程会遍历当前单元格的上下左右四个邻接单元格。这样做可以防止同一个岛屿被重复计数。

```java
public class NumberOfIslands {
    public static int numberOfIslands1(char[][]board){
        int islands=0;
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if(board[i][j]=='1'){
                    islands++;
                    infect(board,i,j);
                }
            }
        }
        return islands;
    }
    private static void infect(char[][] board, int i, int j) {
        if(i<0||j<0||i==board.length||j==board[0].length){
            return;
        }
        board[i][j]='0';
        infect(board,i-1,j);
        infect(board,i+1,j);
        infect(board,i,j-1);
        infect(board,i,j+1);
    }
}
```

### （2）并查集（map）

**分析：**在解决二维网格中的“岛屿数量”问题时，关键挑战之一在于如何有效地区分并管理各个岛屿单元格。采用基于映射的并查集，我们引入了一个轻量级的`Dot`类，利用每个`Dot`实例的唯一性（即其内存地址）来区别不同的单元格。这样，每个`'1'`（岛屿单元格）都被分配了一个对应的`Dot`实例，而这些实例随后存储于一个二维数组`dots`中，以便于管理和引用。

为了精确地构建并查集，仅那些代表岛屿的单元格（即值为`'1'`的单元格）会被初始化并加入到并查集中。这一步骤是至关重要的，因为它直接决定了并查集中集合的初始数量，并且排除了代表水域（即值为`'0'`的单元格）的单元格，从而避免了不必要的操作和资源消耗。

为了细致地处理边界条件，我们首先遍历网格的第一行和第一列，以确保这些边缘单元格中相邻的岛屿得以合并。随后，在遍历整个网格的其余部分时，我们对每个单元格进行检查，将当前单元格与其上方和左侧的单元格进行比较。如果当前单元格及其相邻单元格均为岛屿，则相应的`Dot`实例将在并查集中被合并。

通过这种方法，我们可以确保所有相互连接的岛屿单元格被有效地归入同一集合。并查集中的集合总数，因而直接对应于网格中岛屿的总数。这种基于映射的并查集实现不仅优化了岛屿管理的过程，而且提供了一种高效解决问题的策略，特别适合于处理大规模和复杂的二维网格场景。

```java
public static class Dot{}

public static int numberOfIslands2(char[][]board){
    int row=board.length;
    int col=board[0].length;
    List<Dot> dotList=new ArrayList<>();
    Dot[][] dots=new Dot[row][col];
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            if (board[i][j] == '1') {
                dots[i][j] = new Dot();
                dotList.add(dots[i][j]);
            }
        }
    }
    UnionFindByMap<Dot> unionFindByMap = new UnionFindByMap<>(dotList);
    for (int i=1;i<row;i++){
        if(board[i-1][0]=='1'&&board[i][0]=='1'){
            unionFindByMap.union(dots[i-1][0],dots[i][0]);
        }
    }
    for (int j = 1; j < col; j++) {
        if(board[0][j-1]=='1'&&board[0][j]=='1'){
            unionFindByMap.union(dots[0][j-1],dots[0][j]);
        }
    }
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            if(board[i-1][j]=='1'&&board[i][j]=='1'){
                unionFindByMap.union(dots[i-1][j],dots[i][j]);
            }
            if(board[i][j-1]=='1'&&board[i][j]=='1'){
                unionFindByMap.union(dots[i][j-1],dots[i][j]);
            }
        }
    }
    return unionFindByMap.getSets();
}
public static class UnionFindByMap<V> {
    public HashMap<V,V> parent;
    public HashMap<V,Integer> size;
    public int sets;
    UnionFindByMap(List<V> values){
        parent=new HashMap<>();
        size=new HashMap<>();
        for (V value:values){
            parent.put(value,value);
            size.put(value,1);
            sets++;
        }
    }
    public V find(V x){
        Stack<V> stack = new Stack<>();
        while(x!=parent.get(x)){
            stack.add(x);
            x= parent.get(x);
        }
        while(!stack.isEmpty()){
            parent.put(stack.pop(), x);
        }
        return x;
    }
    public void union(V x,V y){
        V rootX=find(x);
        V rootY=find(y);
        if(rootY!=rootX){
            sets--;
            Integer rankX=size.get(rootX);
            Integer rankY=size.get(rootY);
            if(rankX>rankY){
                parent.put(rootY,rootX);
                size.put(rootX,rankX+rankY);
                size.remove(rootY);
            }else{
                parent.put(rootX,rootY);
                size.put(rootY,rankX+rankY);
                size.remove(rootX);
            }
        }
    }
    public int getSets(){
        return sets;
    }
}
```

### （3）并查集（数组）

**分析：**在解决二维网格中岛屿数量的问题时，利用数组形式的并查集进行优化是一种高效的策略。该策略的核心在于如何有效地将二维网格映射为一维数组，以便使用并查集进行管理。这种映射可以通过一个简单的数学公式实现，即利用当前单元格的行索引（`i`）和列索引（`j`）计算出对应的一维数组索引，计算公式为`i * col + j`，其中`col`是网格的列数。这种映射确保了每个单元格在并查集中有一个唯一对应的索引。

在初始化并查集的过程中，特别注意需要区分岛屿（由`'1'`表示）和水域（由`'0'`表示）。仅对于岛屿单元格，我们才将其加入并查集并计入集合总数。这一步是关键的，因为它直接影响并查集最终统计出的岛屿数量，同时也避免了对水域单元格的不必要处理。

```java
public static int numberOfIslands3(char[][]board){
    int row=board.length;
    int col=board[0].length;
    UnionFindByArray unionFindByArray = new UnionFindByArray(board);
    for (int i=1;i<row;i++){
        if(board[i-1][0]=='1'&&board[i][0]=='1'){
            unionFindByArray.union(i-1,0,i,0);
        }
    }
    for (int j = 1; j < col; j++) {
        if(board[0][j-1]=='1'&&board[0][j]=='1'){
            unionFindByArray.union(0,j-1,0,j);
        }
    }
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            if(board[i-1][j]=='1'&&board[i][j]=='1'){
                unionFindByArray.union(i-1,j,i,j);
            }
            if(board[i][j-1]=='1'&&board[i][j]=='1'){
                unionFindByArray.union(i,j-1,i,j);
            }
        }
    }
    return unionFindByArray.getSets();
}
public static class UnionFindByArray{
    public int[] parent;
    public int[] size;
    public int[] help;
    public int col;
    public int sets;
    UnionFindByArray(char[][]board){
        int row=board.length;
        col=board[0].length;
        int n=col*row;
        parent=new int[n];
        size=new int[n];
        help=new int[n];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if(board[i][j]=='1'){
                    int x=index(i,j);
                    parent[x]=x;
                    size[x]=1;
                    sets++;
                }
            }
        }
    }
    public int index(int i,int j){
        return i*col+j;
    }
    public int find(int x){
        int i=0;
        while(x!=parent[x]){
            help[i++]=x;
            x=parent[x];
        }
        for (i--; i >=0; i--) {
            parent[help[i]]=x;
        }
        return x;
    }
    public void union(int i1,int j1,int i2,int j2){
        int x=index(i1,j1);
        int y=index(i2,j2);
        int rootX = find(x);
        int rootY = find(y);
        if(rootY!=rootX){
            sets--;
            if(size[rootX]>size[rootY]){
                parent[rootY]=rootX;
                size[rootX]+=size[rootY];
            }else {
                parent[rootX]=rootY;
                size[rootY]+=size[rootX];
            }
        }
    }
    public int getSets(){
        return sets;
    }
}
```

## 3.岛屿问题（动态岛屿）

**题目：**考虑到一个扩展的二维矩阵岛屿探索场景，初始状态下，该矩阵只有水域，引入了一个动态元素：空降行动。通过空降行动，可以选择任一水域单元，将其转化为陆地单元。

任务是开发一个算法，它不仅能处理初始的岛屿计数，还能适应一系列空降行动的影响。每次空降行动可以通过一对整数坐标来指定，分别对应矩阵中的行和列。算法应在每次空降后，实时计算并返回矩阵中的岛屿总数。

**分析：**

- **`connect`方法的引入**：通过在并查集中添加`connect`方法，可以高效地处理新增岛屿的空投操作。每次空投后，`connect`方法负责判断新增的陆地单元格是否与周围已存在的陆地单元格相连。这一步骤关键在于，它不仅能够识别并合并相邻的岛屿，还能够在新增的陆地单元格为独立岛屿时，适当增加岛屿总数。
- **集合数量的动态更新**：在初始全为水域的矩阵中，将并查集的集合数量初始化为0。随着陆地的逐步引入，每次通过`connect`方法处理新陆地时，根据该陆地是否与已有岛屿连通，相应地调整集合数量。在将新陆地加入并查集时，正确设置其`parent`（指向自己）和`size`（初始化为1）是必要的。这不仅有助于后续的并查集操作，也是后续合并判断的基础。如果新陆地与现有岛屿无法合并，集合数量增加1；如果能够合并，则保持集合数量不变。
- **重复空投的处理**：利用`size`数组来跟踪每个单元格的状态（即是否已经是陆地）是处理重复空投的关键。在`connect`方法中，通过检查目标单元格的`size`值，可以判断该单元格是否已经被转换为陆地。如果已经是陆地（`size[index] > 0`），则无需再次处理；否则，将其转换为陆地并尝试与周围的陆地单元格合并。

```java
package com.lxy.class15;
import java.util.ArrayList;
import java.util.List;

public class NumberOfIslandsⅡ {
    public static List<Integer> numberOfIslands(int row, int col, int[][]position){
        UnionFindByArray unionFindByArray = new UnionFindByArray(row, col);
        List<Integer> ans = new ArrayList<>();
        for(int[]e:position){
            ans.add(unionFindByArray.connect(e[0],e[1]));
        }
        return ans;
    }
    public static class UnionFindByArray{
        public int[] parent;
        public int[] size;
        public int[] help;
        public int col;
        public int row;
        public int sets;
        UnionFindByArray(int r,int c){
            col=c;
            row=r;
            sets=0;
            int n=c* r;
            parent=new int[n];
            size=new int[n];
            help=new int[n];
        }
        public int index(int i,int j){
            return i*col+j;
        }
        public int find(int x){
            int i=0;
            while(x!=parent[x]){
                help[i++]=x;
                x=parent[x];
            }
            for (i--; i >=0; i--) {
                parent[help[i]]=x;
            }
            return x;
        }
        public void union(int r1,int c1,int r2,int c2){
            if (r1 < 0 || r1 == row || r2 < 0 || r2 == row || c1 < 0 || c1 == col || c2 < 0 || c2 == col) {
                return;
            }
            int x=index(r1,c1);
            int y=index(r2,c2);
            if (size[x] == 0 || size[y] == 0) {
                return;
            }
            int rootX = find(x);
            int rootY = find(y);
            if(rootY!=rootX){
                sets--;
                if(size[rootX]>size[rootY]){
                    parent[rootY]=rootX;
                    size[rootX]+=size[rootY];
                }else {
                    parent[rootX]=rootY;
                    size[rootY]+=size[rootX];
                }
            }
        }
        public int getSets(){
            return sets;
        }
        public int connect(int r, int c){
            int index = index(r, c);
            if(size[index]==0){
                parent[index]=index;
                size[index]=1;
                sets++;
                union(r,c,r-1,c);
                union(r,c,r+1,c);
                union(r,c,r,c+1);
                union(r,c,r,c-1);
            }
            return sets;
        }
    }
}
```

## 4.岛屿问题（并行处理）

**题目：**给定一个极大的二维矩阵`matrix`，该矩阵由`0`和`1`组成，其中`0`代表水域，`1`代表陆地。相邻的陆地单元格（在水平或垂直方向上相连）被视为同一片岛屿。本题的目标是计算出该矩阵中岛屿的总数量。鉴于矩阵的规模可能非常大，要求使用并行处理技术来优化计算过程，以实现更快的处理速度。

**分析：**

1. **矩阵分割**：将整个矩阵分割为若干个子矩阵，每个子矩阵可以由一个独立的线程或进程来处理。分割策略需要确保能够正确处理位于子矩阵边界上的岛屿。
2. **局部岛屿计数**：每个线程计算其负责的子矩阵中的岛屿数量。当岛屿触及子矩阵的边界时，需要特殊处理以避免在最终的汇总过程中重复计数。
3. **边界处理**：通过并查集，在处理每个子矩阵时，对触及内部边界的岛屿进行识别并记录。接着，针对每对相邻的子矩阵，检查其共享边界上是否存在相连的陆地单元格。如果发现这样的陆地单元格对，则在并查集中将它们所属的岛屿合并。
4. **并行执行与结果汇总**：所有线程并行执行上述步骤，完成后，汇总各自的岛屿数量，并考虑边界处理的结果，以得到整个矩阵的总岛屿数量。

# class16

## 1.图

图（Graph）是一种复杂数据结构，用于表示多个对象之间的关系。它由节点（也称为顶点）和连接这些节点的边组成。图可以用来模拟现实世界中的许多不同类型的网络，比如社交网络中的人际关系、城市间的道路网络、网页之间的链接结构等。

### 图的基本概念

- **节点（Vertex）**：图中的一个对象，可以用来表示一个实体。
- **边（Edge）**：连接两个节点的线，表示节点之间的关系。边可以是有向的（表示关系的方向）或无向的。
- **邻接（Adjacency）**：如果两个节点通过一条边直接相连，则它们被称为邻接节点。
- **路径（Path）**：由边依次连接的一系列节点。
- **环（Cycle）**：起点和终点相同的路径。
- **加权图（Weighted Graph）**：图的边被赋予了权重，权重可以表示成本、距离等。
- **连通图（Connected Graph）**：在无向图中，如果任意两个节点都是连通的，则该图被称为连通图。
- **强连通图（Strongly Connected Graph）**：在有向图中，如果对于任意两个节点`u`和`v`，都存在从`u`到`v`以及从`v`到`u`的路径，则该图被称为强连通图。

### 图的分类

- **无向图（Undirected Graph）**：图中所有的边都是无向的，即边的方向不影响图的含义。
- **有向图（Directed Graph）**：图中的边具有方向，从一个节点指向另一个节点。
- **无权图（Unweighted Graph）**：图中的边没有权重。
- **有权图（Weighted Graph）**：图中的边具有权重。

### 图的表示

- **邻接矩阵（Adjacency Matrix）**：使用二维数组来表示图。如果节点`i`和节点`j`之间存在边，则`matrix[i][j]`和`matrix[j][i]`（无向图）被设置为1（或权重值，对于加权图）；否则被设置为0。
- **邻接列表（Adjacency List）**：对于每个节点，都有一个列表来存储它的邻接节点。这是一种更加紧凑的表示方法，特别适合于稀疏图。

图的算法和应用是计算机科学中的一个重要领域，包括寻找最短路径、检测图中的循环、网络流问题等。

### 图结构

```java
public class Graph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;
    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
    public class Edge {
        public int weight;
        public Node from;
        public Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
    public class Node {
        public int value;
        public int in;
        public int out;
        public ArrayList<Node> nexts;
        public ArrayList<Edge> edges;

        public Node(int value) {
            this.value = value;
            in = 0;
            out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }
}
```

## 2.图的遍历

#### （1）宽度优先

**分析：**宽度优先搜索（BFS）是一种用于遍历或搜索树和图的算法。对于图结构，BFS 通过使用队列这种先进先出（FIFO）的数据结构，确保了节点按照它们被发现的顺序进行访问。由于图中可能存在环，即一个节点可以通过多条路径被访问到，因此，为了防止无限循环和重复访问相同的节点，使用一个集合（如哈希集）来记录已经被访问过的节点是至关重要的。

```java
public class BFS {
    public static void bfs(Node start) {
        if(start==null){
            return;
        }
        Queue<Node> queue = new LinkedList<>();
        HashSet<Node> set=new HashSet<>();
        queue.add(start);
        set.add(start);
        while(!queue.isEmpty()){
            Node cur=queue.poll();
            System.out.println(cur.value);
            for(Node node:cur.nexts){
                if(!set.contains(node)){
                    queue.add(node);
                    set.add(node);
                }
            }
        }
    }
}
```

#### （2）深度优先

**分析：**在DFS中，栈的使用是模拟递归调用堆栈的一种方法，反映了后进先出的原则，确保了算法能够深入到每个可能的分支。通过将当前节点的邻接节点加入栈中，算法可以持续深入直至达到叶子节点，然后通过栈的回溯自然地探索其他分支。使用集合（`HashSet`）记录已访问的节点，是防止算法在含有环的图中陷入无限循环的关键。这个集合保证了每个节点在整个遍历过程中只被访问一次，从而提高了遍历的效率。

在实际编写中，在发现新的邻接节点时，先将当前节点重新压入栈中，然后将新发现的节点压入栈中，并使用`break`跳出当前的遍历循环，这实际上创建了一个显式的回溯点：

- **回溯点**：这种处理方式允许算法在探索完一个分支后回到分支的起点，继续探索其他可能的分支。这是通过在每次发现新节点时，将探索过程中的当前节点重新压入栈中来实现的。
- **深入探索**：将回溯点显式化使得算法更倾向于先深入探索一个方向上的节点，而不是在同一层次上广泛探索。这样的探索策略有助于尽快达到图的深层部分。

```java
import java.util.HashSet;
import java.util.Stack;

public class DFS {
    public static void dfs(Node start){
        if(start==null){
            return;
        }
        Stack<Node>stack=new Stack<>();
        HashSet<Node> set=new HashSet<>();
        stack.add(start);
        set.add(start);
        System.out.println(start);
        while(!stack.isEmpty()){
            Node cur=stack.pop();
            System.out.println(cur.value);
            for(Node node:cur.nexts){
                if(!set.contains(node)){
                    stack.add(cur);
                    stack.add(node);
                    System.out.println(node);
                    set.add(node);
                    break;
                }
            }
        }
    }
}
```

## 3.图的拓扑排序

拓扑排序是针对有向无环图（DAG）的一种排序方法，它会产生一个线性序列，满足图中每个有向边从序列的前面指向后面。这种排序方式在解决一些如项目构建、课程安排等需要处理依赖关系的问题中非常有用。

### （1）in属性判断

**分析：**

1. **构建入度表**：首先，为图中的每个节点创建一个入度映射（`inDegreeMap`），初始化所有节点的入度为0。然后，遍历图中的每个节点及其邻居，对每个邻居节点的入度加1。
2. **寻找入度为0的节点**：遍历入度表，将所有入度为0的节点加入队列。这些节点没有任何先修课程，可以作为拓扑排序的起点。
3. **广度优先搜索**：当队列不为空时，执行以下步骤：
   - 从队列中取出（`poll`）一个节点，将其添加到拓扑排序结果列表（`ans`）中。
   - 遍历这个节点的所有邻居，将每个邻居的入度减1（因为从图中移除了一个节点）。
   - 如果某个邻居节点的入度减至0，则将其加入队列中，因为所有指向它的依赖都已经被满足。
4. **生成拓扑排序**：重复上述过程，直到队列为空。最终，结果列表`ans`中的节点顺序就是图的一个拓扑排序。

```java
package com.lxy.class16;

import java.util.*;

public class TopologicalOrderBSF1 {
    public static class DirectedGraphNode {
        public int label;
        public ArrayList<DirectedGraphNode> neighbors;

        public DirectedGraphNode(int x) {
            label = x;
            neighbors = new ArrayList<DirectedGraphNode>();
        }
    }

    public static List<DirectedGraphNode>topologicalBSF(ArrayList<DirectedGraphNode> graph){
        HashMap<DirectedGraphNode,Integer> inDegreeMap=new HashMap<>();
        for(DirectedGraphNode node:graph){
            inDegreeMap.put(node,0);
        }
        for(DirectedGraphNode node:graph){
            for (DirectedGraphNode neighbor:node.neighbors){
                inDegreeMap.put(neighbor,inDegreeMap.get(neighbor)+1);
            }
        }
        Queue<DirectedGraphNode> queue=new LinkedList<>();
        for (DirectedGraphNode node:graph){
            if(inDegreeMap.get(node)==0){
                queue.add(node);
            }
        }
        List<DirectedGraphNode> ans=new ArrayList<>();
        while(!queue.isEmpty()){
            DirectedGraphNode node=queue.poll();
            ans.add(node);
            for(DirectedGraphNode neighbor:node.neighbors){
                inDegreeMap.put(neighbor,inDegreeMap.get(neighbor)-1);
                if(inDegreeMap.get(neighbor)==0){
                    queue.add(neighbor);
                }
            }
        }
        return ans;
    }
}
```

### （2）in属性判断（图的不同表达）

牛客测试连接：https://www.nowcoder.com/questionTerminal/88f7e156ca7d43a1a535f619cd3f495c

**分析：**

**主要变量**

- `MAXN`: 最大可能的节点数量，定义了数组的大小。
- `ans`: 存储拓扑排序结果的数组。
- `n`: 节点数量。
- `m`: 边数量。

`main` 方法

- 创建了用于读取标准输入的工具。
- 使用 `StreamTokenizer` 读取图的结构信息。
- 循环读取输入，构建图的邻接列表，直到遇到文件结束标记。
- 对图进行拓扑排序，然后根据结果输出排序数组或 `-1`（如果不能进行拓扑排序，通常意味着图中有环）。

**`topoSort` 方法**

- 创建一个数组 `inDegree` 用于跟踪每个节点的入度（即有多少边指向该节点）。
- 遍历图的邻接列表，计算所有节点的入度。
- 将所有入度为 `0` 的节点加入队列 —— 这些节点没有依赖，可以作为排序的起点。
- 进行BFS，每次从队列中取出一个节点，将其加入 `ans` 数组。
- 遍历取出节点的所有邻居，减少它们的入度，如果某邻居节点的入度变为 `0`，则将其加入队列中。
- 如果最后 `ans` 数组中填充的节点数量等于 `n`，则说明图中没有环，拓扑排序成功完成。

细节处理

- 使用 `ArrayList<ArrayList<Integer>>` 构建邻接列表表示图。`graph.get(from).add(to);` 表示 `from` 节点有一条边指向 `to` 节点。
- 在 `main` 方法中，通过 `while` 循环和 `if-else` 结构处理每组输入数据并输出结果。
- 使用 `PrintWriter` 将结果输出到标准输出。

```java
package com.lxy.class16;
import java.io.*;
import java.util.*;
public class TopologicalOrderBSF2 {
    public static int MAXN = 200001;
    public static int[]ans=new int[MAXN];
    public static int n;
    public static int m;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while(in.nextToken()!=StreamTokenizer.TT_EOF){
            n=(int)in.nval;
            in.nextToken();
            m=(int)in.nval;
            ArrayList<ArrayList<Integer>> graph=new ArrayList<>();
            //边界
            for (int i = 0; i <= n; i++) {
                graph.add(new ArrayList<Integer>());
            }
            for (int i = 0; i < m; i++) {
                in.nextToken();
                int from=(int)in.nval;
                in.nextToken();
                int to=(int)in.nval;
                graph.get(from).add(to);
            }
            if (!topoSort(graph)) {
                out.println(-1);
            } else {
                for (int i = 0; i < n - 1; i++) {
                    out.print(ans[i] + " ");
                }
                out.println(ans[n - 1]);
            }
            out.flush();
        }

    }

    private static boolean topoSort(ArrayList<ArrayList<Integer>> graph) {
        int[] inDegree=new int[MAXN];
        Queue<Integer> queue=new LinkedList<>();
        for(List<Integer>nexts:graph){
            for(Integer next:nexts){
                inDegree[next]++;
            }
        }
        //边界
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }
        int i=0;
        while (!queue.isEmpty()){
            Integer cur=queue.poll();
            ans[i++]=cur;
            for(Integer next:graph.get(cur)){
                if(--inDegree[next]==0){
                    queue.add(next);
                }
            }
        }
        return i==n;
    }
}

```

### （3）点次判断

```java
package com.lxy.class16;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;

public class TopologicalOrderDSF2 {
    public static class DirectedGraphNode {
        public int label;
        public ArrayList<DirectedGraphNode> neighbors;

        public DirectedGraphNode(int x) {
            label = x;
            neighbors = new ArrayList<DirectedGraphNode>();
        }
    }
    public static class Record{
        public DirectedGraphNode node;
        public long nodes;

        public Record(DirectedGraphNode node, long nodes) {
            this.node = node;
            this.nodes = nodes;
        }
    }
    public static class MyComparator implements Comparator< Record> {

        @Override
        public int compare( Record o1,  Record o2) {
            return Long.compare(o2.nodes, o1.nodes);
        }
    }
    public static ArrayList< DirectedGraphNode> topologicalOrderDSF1(ArrayList< DirectedGraphNode> graph){
        HashMap< DirectedGraphNode,  Record> order = new HashMap<>();
        for ( DirectedGraphNode cur : graph) {
            f(cur, order);
        }
        ArrayList< Record> recordArr = new ArrayList<>();
        for ( Record r : order.values()) {
            recordArr.add(r);
        }
        recordArr.sort(new  MyComparator());
        ArrayList< DirectedGraphNode> ans = new ArrayList< DirectedGraphNode>();
        for ( Record r : recordArr) {
            ans.add(r.node);
        }
        return ans;
    }
    public static  Record f( DirectedGraphNode cur, HashMap< DirectedGraphNode,  Record> order) {
        if (order.containsKey(cur)) {
            return order.get(cur);
        }
        long nodes = 0;
        for ( DirectedGraphNode next : cur.neighbors) {
            nodes +=  f(next, order).nodes;
        }
         Record ans = new  Record(cur, nodes+1);
        order.put(cur, ans);
        return ans;
    }
}
```

### （4）深度判断

```java
public static class DirectedGraphNode {
    public int label;
    public ArrayList<DirectedGraphNode> neighbors;

    public DirectedGraphNode(int x) {
        label = x;
        neighbors = new ArrayList<DirectedGraphNode>();
    }
}
public static class Record{
    public DirectedGraphNode node;
    public int deep;

    public Record(DirectedGraphNode node, int deep) {
        this.node = node;
        this.deep = deep;
    }
}
public static class MyComparator implements Comparator<Record> {

    @Override
    public int compare(Record o1, Record o2) {
        return o2.deep - o1.deep;
    }
}
public static ArrayList<DirectedGraphNode> topologicalOrderDSF1(ArrayList<DirectedGraphNode> graph){
    HashMap<DirectedGraphNode, Record> order = new HashMap<>();
    for (DirectedGraphNode cur : graph) {
        f(cur, order);
    }
    ArrayList<Record> recordArr = new ArrayList<>();
    for (Record r : order.values()) {
        recordArr.add(r);
    }
    recordArr.sort(new MyComparator());
    ArrayList<DirectedGraphNode> ans = new ArrayList<DirectedGraphNode>();
    for (Record r : recordArr) {
        ans.add(r.node);
    }
    return ans;
}
public static Record f(DirectedGraphNode cur, HashMap<DirectedGraphNode, Record> order) {
    if (order.containsKey(cur)) {
        return order.get(cur);
    }
    int follow = 0;
    for (DirectedGraphNode next : cur.neighbors) {
        follow = Math.max(follow, f(next, order).deep);
    }
    Record ans = new Record(cur, follow + 1);
    order.put(cur, ans);
    return ans;
}
```

## 4.最小生成树

在一个加权的无向图中找到一个边的子集，这个子集构成了一个树形结构，包含图中的所有顶点，并且所有边的权重之和最小。

### （1）Kruskal算法

克鲁斯卡尔算法是一种基于边的方法。算法的第一步是将图的所有边按权重进行排序。然后它会遍历排序后的边列表，选择最小的边，如果这条边不会与已经选择的边形成环路，则将其加入最小生成树中。

**分析：**

**贪心策略：**按照边的权重升序选择边，同时确保所选的边不会在已构建的子图中形成闭环。

**实现细节：**

1. **边的排序**：算法以权重为基准将图中的所有边进行排序，通常使用优先队列（小顶堆）来实现这一点，保证了每次可以高效地选取权重最小的边。
2. **环路的检测与集合的合并**：在选择一条边之前，算法会检查这条边的两个端点是否属于同一个集合。这一检测使用并查集数据结构来完成，允许快速查询两个节点是否在同一个集合中，以及快速合并集合。如果一条边的两个端点已经在同一个集合中，说明添加这条边会产生环路，因此这条边会被忽略。反之，如果不会形成环路，边的两个端点将被合并进同一个集合，这条边会被加入到最小生成树中。

```java
package com.lxy.class16;

import java.util.*;

public class Kruskal {
    public static class UnionFind<V>{
        public HashMap<V,V> parent;
        public HashMap<V,Integer> size;
        public UnionFind(Collection<V> nodes) {
            parent=new HashMap<>();
            size=new HashMap<>();
            for (V node : nodes) {
                parent.put(node, node);
                size.put(node, 1);
            }
        }
        public V find(V x){
            Stack<V> stack = new Stack<>();
            while(x!=parent.get(x)){
                stack.add(x);
                x= parent.get(x);
            }
            while(!stack.isEmpty()){
                parent.put(stack.pop(), x);
            }
            return x;
        }
        public void union(V x,V y){
            V rootX=find(x);
            V rootY=find(y);
            if(rootY!=rootX){
                Integer rankX=size.get(rootX);
                Integer rankY=size.get(rootY);
                if(rankX>rankY){
                    parent.put(rootY,rootX);
                    size.put(rootX,rankX+rankY);
                    size.remove(rootY);
                }else{
                    parent.put(rootX,rootY);
                    size.put(rootY,rankX+rankY);
                    size.remove(rootX);
                }
            }
        }
        public boolean isSameSet(V x,V y){
            return find(x)==find(y);
        }
    }
    public static class MyComparator implements Comparator<Edge>{

        @Override
        public int compare(Edge o1, Edge o2) {
            return o1.weight-o2.weight;
        }
    }
    public static Set<Edge> kruskal(Graph graph){
        PriorityQueue<Edge> heap=new PriorityQueue<>(new MyComparator());
        heap.addAll(graph.edges);
        UnionFind<Node> unionFind = new UnionFind<>(graph.nodes.values());
        Set<Edge> ans=new HashSet<>();
        while(!heap.isEmpty()){
            Edge cur=heap.poll();
            if(!unionFind.isSameSet(cur.to,cur.from)){
                ans.add(cur);
                unionFind.union(cur.to,cur.from);
            }
        }
        return ans;
    }
}
```

牛客链接：https://www.nowcoder.com/questionTerminal/c23eab7bb39748b6b224a8a3afbe396b

主要是图的表达方式不同

题目：一个有n户人家的村庄，有m条路连接着。村里现在要修路，每条路都有一个代价，现在请你帮忙计算下，最少需要花费多少的代价，就能让这n户人家连接起来。

```java
package com.lxy.class16;

import java.io.*;
import java.util.Comparator;
import java.util.PriorityQueue;


public class Kruskal2 {
    public static int MAXM = 100001;
    public static int n;
    public static int m;
    public static int[][]edge=new int[MAXM][3];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while(in.nextToken()!=StreamTokenizer.TT_EOF){
            n=(int)in.nval;
            in.nextToken();
            m=(int)in.nval;
            for (int i = 0; i < m; i++) {
                in.nextToken();
                edge[i][0]=(int)in.nval;
                in.nextToken();
                edge[i][1]=(int)in.nval;
                in.nextToken();
                edge[i][2]=(int)in.nval;
            }
            int cost=kruskal();
            out.println(cost);
            out.flush();
        }
    }
    public static class MyComparator implements Comparator<int[]>{
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[2]-o2[2];
        }
    }
    public static int kruskal(){
        PriorityQueue<int[]> heap = new PriorityQueue<>(new MyComparator());
        UnionFind unionFind = new UnionFind(n);
        for (int i = 0; i < m; i++) {
           heap.add(edge[i]);
        }
        int ans=0;
        while(!heap.isEmpty()){
            int[] cur = heap.poll();
            if(!unionFind.isSameSet(cur[0],cur[1])){
                ans+=cur[2];
                unionFind.union(cur[0],cur[1]);
            }
        }
        return ans;
    }
    public static class UnionFind{
        public int[] parent;
        public int[] size;
        public int[] help;
        UnionFind(int n){
            parent=new int[MAXM];
            size=new int[MAXM];
            help=new int[MAXM];
            //注意边界问题
            for (int i = 0; i <= n; i++) {
                parent[i]=i;
                size[i]=1;
            }
        }
        public int find(int x){
            int i=0;
            while(x!=parent[x]){
                help[i++]=x;
                x=parent[x];
            }
            for (i--; i >=0; i--) {
                parent[help[i]]=x;
            }
            return x;
        }
        public void union(int x,int y){
            int rootX = find(x);
            int rootY = find(y);
            if(rootY!=rootX){
                if(size[rootX]>size[rootY]){
                    parent[rootY]=rootX;
                    size[rootX]+=size[rootY];
                }else {
                    parent[rootX]=rootY;
                    size[rootY]+=size[rootX];
                }
            }
        }
        public boolean isSameSet(int x,int y){
            return find(x)==find(y);
        }
    }

}
```

### （2）Prim算法

普里姆算法从图中的某个顶点开始，逐渐增长最小生成树。在每一步，算法都会选择连接树与图中剩余部分的最小权重的边，然后将这条边以及它的顶点加入到树中。

**分析：**

贪心策略：始终选择连接已选顶点集合与剩余顶点集合的最小权重边，并且确保这种选择不会在树中形成环路。

实现要点：

1. **边的选择**：Prim算法从图中的某一顶点开始，然后在所有连接已选顶点和尚未选中顶点的边中选择一条权重最小的边。
2. **集合的更新**：每次选中一条边后，与之相连的新顶点会被添加到已选顶点集合中。
3. **环路的检测**：算法在选择边时必须确保新选择的边不会和已选择的边共同形成环路。为此，Prim算法利用集合来跟踪已访问的顶点。

具体实现中，Prim算法使用优先队列存储所有边界边（即连接已选顶点和未选顶点的边）。这个队列按边的权重排序，每次都从中取出权重最小的边。如果这条边连接的顶点尚未在树中，它就会被加入最小生成树，其权重会被累加到最小生成树的总权重中，否则这条边会被忽略。

此外，算法使用哈希集合来记录已经被添加到最小生成树中的顶点。这保证了算法能够在每次迭代时高效地确定顶点是否已被处理。

```java
package com.lxy.class16;

import java.util.Comparator;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;

public class Prim {
    public static class MyComparator implements Comparator<Edge>{

        @Override
        public int compare(Edge o1, Edge o2) {
            return o1.weight-o2.weight;
        }
    }
    public static Set<Edge> prim(Graph graph){
        PriorityQueue<Edge> heap=new PriorityQueue<>();
        HashSet<Node> nodesSet=new HashSet<>();
        Set<Edge> ans=new HashSet<>();
        for (Node node:graph.nodes.values()){
            if(!nodesSet.contains(node)){
                nodesSet.add(node);
                heap.addAll(node.edges);
                while(!heap.isEmpty()){
                    Edge cur=heap.poll();
                    Node toNode=cur.to;
                    if(!nodesSet.contains(toNode)){
                        ans.add(cur);
                        heap.addAll(toNode.edges);
                    }
                }
            }
        }
        return ans;
    }
}
```

牛客测试链接 : https://www.nowcoder.com/questionTerminal/c23eab7bb39748b6b224a8a3afbe396b

图表达式非常规情况下如何求解（同Kruskal算法）

关键在于使用了ArrayList<ArrayList<int[]>> graph，能够实现从点能找到边。

```java
import java.io.*;
import java.util.ArrayList;
import java.util.PriorityQueue;

public class Prim2 {
    public static int n;
    public static int m;
    public static void main(String[] args) throws IOException {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while(in.nextToken()!=StreamTokenizer.TT_EOF){
            ArrayList<ArrayList<int[]>> graph=new ArrayList<>();
            n=(int)in.nval;
            in.nextToken();
            m=(int)in.nval;
            for (int i = 0; i <=n ; i++) {
                graph.add(new ArrayList<>());
            }
            for (int i = 0; i < m; i++) {
                in.nextToken();
                int from=(int)in.nval;
                in.nextToken();
                int to=(int)in.nval;
                in.nextToken();
                int weight=(int)in.nval;
                //无向图
                graph.get(from).add(new int[]{to,weight});
                graph.get(to).add(new int[]{from,weight});
            }
            out.println(prim(graph));
            out.flush();
        }
    }
    public static int prim(ArrayList<ArrayList<int[]>> graph){
        PriorityQueue<int[]> heap=new PriorityQueue<>((o1,o2)->o1[1]-o2[1]);
        int ans=0;
        boolean[] visited=new boolean[n+1];
        heap.addAll(graph.get(1));
        visited[1]=true;
        while(!heap.isEmpty()){
            int[]cur=heap.poll();
            int weight=cur[1];
            int toNode=cur[0];
            if(!visited[toNode]){
                visited[toNode]=true;
                ans+=weight;
                heap.addAll(graph.get(toNode));
            }
        }
        return ans;
    }

}
```

## 5.图的最短路径（Dijkstra算法）

Dijkstra算法是一种在图中找到从单个源到所有其他节点的最短路径的算法。该算法适用于包含非负权重的有向图或无向图。

Dijkstra算法的核心思想是维护一个集合，该集合存储了从源点到图中每个顶点的最短路径估计。算法初始化时，除了源点自身的最短路径为0外，其余所有点的最短路径估计都设为无穷大。随后，算法逐步扩展这个集合，每一步都选择一个最短路径估计最小的顶点，更新其邻接顶点的最短路径估计，直到所有顶点都被处理过。

算法步骤

1. **初始化**：将所有顶点的最短路径值初始化为无穷大，除了源点自身设为0，因为从源点到自己的最短路径显然是0。所有顶点标记为未访问。

2. **选择最小距离顶点**：从未访问过的顶点集合中选择一个距离源点最近（即最短路径估计最小）的顶点。在初始阶段，这将是源点自身。

3. **更新邻接顶点的距离估计**：考虑当前顶点的所有未访问的邻接顶点，检查通过当前顶点到达它们是否可以缩短已知的到达它们的路径。如果可以，则更新它们的最短路径估计。

4. **标记为已访问**：将当前顶点标记为已访问。一旦顶点被标记为已访问，就意味着已经计算出了从源点到该顶点的最短路径，且此路径不会再被改变。

5. **重复**：重复步骤2至4，直到所有顶点都被访问过。

### （1）简单实现

**分析：**初始化一个距离映射（`distanceMap`），用于跟踪从源节点到图中每个节点的最短距离估计。同时使用一个节点集合（`nodesSet`）跟踪已经处理过的节点。然后，它进入一个循环，每次循环中选择一个当前距离最小且尚未处理的节点，更新其邻接节点的最短距离估计，直到所有节点都被处理。

```java
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

public class Dijkstra {
    public static HashMap<Node, Integer> dijkstra1(Node from) {
        HashMap<Node,Integer> distanceMap=new HashMap<>();
        distanceMap.put(from, 0);
        HashSet<Node> nodesSet=new HashSet<>();
        Node minNode=getMinDistanceAndUnselectedNode(distanceMap,nodesSet);
        while(minNode!=null){
            int distance=distanceMap.get(minNode);
            for(Edge e:minNode.edges){
                Node toNode=e.to;
                if(!distanceMap.containsKey(toNode)){
                    distanceMap.put(toNode,distance+e.weight);
                }else{
                    distanceMap.put(toNode,Math.min(distanceMap.get(toNode),distance+e.weight));
                }
            }
            nodesSet.add(minNode);
            minNode=getMinDistanceAndUnselectedNode(distanceMap,nodesSet);
        }
        return distanceMap;
    }

    private static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> nodesSet) {
        Node minNode=null;
        int minDistance=Integer.MAX_VALUE;
        for(Entry<Node,Integer> entry:distanceMap.entrySet()){
            Node node=entry.getKey();
            int distance=entry.getValue();
            if(!nodesSet.contains(node)&&distance<minDistance){
                minDistance=distance;
                minNode=node;
            }
        }
        return minNode;
    }
}
```

### （2）加强堆

**分析：**

1. **初始化**：创建一个 `NodeHeap` 实例和最终结果的 `HashMap`。
2. **添加源节点**：将起始节点以及其距离（0）添加到堆中。
3. **循环处理**：直到堆为空，不断地从堆中取出具有最小距离的节点（`NodeRecord`），**addOrUpdateOrIgnore**用于将节点添加到堆中、更新节点的距离（如果新的距离更短），或忽略（如果节点已经被处理）。，更新其相邻节点的距离（如果更短），并将更新后的节点加入堆中。
4. **结果收集**：每次从堆中取出节点时，将其及其距离记录到结果 `HashMap` 中。

```java
public static HashMap<Node, Integer> dijkstra2(Node from,int size) {
    NodeHeap nodeHeap = new NodeHeap(size);
    nodeHeap.addOrUpdateOrIgnore(from, 0);
    HashMap<Node, Integer> result = new HashMap<>();
    while (!nodeHeap.isEmpty()) {
        NodeRecord record = nodeHeap.pop();
        Node cur = record.node;
        int distance = record.distance;
        for (Edge edge : cur.edges) {
            nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
        }
        result.put(cur, distance);
    }
    return result;
}
public static class NodeRecord {
    public Node node;
    public int distance;

    public NodeRecord(Node node, int distance) {
        this.node = node;
        this.distance = distance;
    }
}
public static class NodeHeap {
    private Node[] nodes;
    private HashMap<Node, Integer> heapIndexMap;
    private HashMap<Node, Integer> distanceMap;
    private int size;

    public NodeHeap(int size) {
        nodes = new Node[size];
        heapIndexMap = new HashMap<>();
        distanceMap = new HashMap<>();
        size = 0;
    }

    public boolean isEmpty() {
        return size == 0;
    }
    public void addOrUpdateOrIgnore(Node node, int distance) {
        if (inHeap(node)) {
            distanceMap.put(node, Math.min(distanceMap.get(node), distance));
            insertHeapify(heapIndexMap.get(node));
        }
        if (!isEntered(node)) {
            nodes[size] = node;
            heapIndexMap.put(node, size);
            distanceMap.put(node, distance);
            insertHeapify(size++);
        }
    }

    public NodeRecord pop() {
        NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
        swap(0, size - 1);
        heapIndexMap.put(nodes[size - 1], -1);
        distanceMap.remove(nodes[size - 1]);
        // free C++同学还要把原本堆顶节点析构，对java同学不必
        nodes[size - 1] = null;
        heapify(0, --size);
        return nodeRecord;
    }

    private void insertHeapify(int index) {
        while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private void heapify(int index, int size) {
        int left = index * 2 + 1;
        while (left < size) {
            int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
                    ? left + 1
                    : left;
            smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
            if (smallest == index) {
                break;
            }
            swap(smallest, index);
            index = smallest;
            left = index * 2 + 1;
        }
    }

    private boolean isEntered(Node node) {
        return heapIndexMap.containsKey(node);
    }

    private boolean inHeap(Node node) {
        return isEntered(node) && heapIndexMap.get(node) != -1;
    }

    private void swap(int index1, int index2) {
        heapIndexMap.put(nodes[index1], index2);
        heapIndexMap.put(nodes[index2], index1);
        Node tmp = nodes[index1];
        nodes[index1] = nodes[index2];
        nodes[index2] = tmp;
    }
}
```

# class17

## 1.汉诺塔

汉诺塔是一个经典的递归问题，目的是将一系列不同大小的盘子从一个柱子移动到另一个柱子上，同时满足以下条件：

1. 一次只能移动一个盘子。
2. 任何时候，在小盘子上不能放大盘子。
3. 可以使用第三个柱子作为中转。

**分析：**

**Base case**（基准情形）：当只有一个盘子（`N == 1`）时，直接将这个盘子从起始柱子移动到目标柱子。

**Recursive case**

（递归情形）：当有多于一个盘子时，算法分为三个步骤：

1. 将上面的 `N-1` 个盘子从起始柱子移动到中间柱子。
2. 将最底下的盘子（第 `N` 个）直接从起始柱子移动到目标柱子（打印）。
3. 将之前移动到中间柱子的 `N-1` 个盘子从中间柱子移动到目标柱子。

```java
public class Hanoi {
    public static void hanoi(int n) {
        if (n > 0) {
            func(n, "left", "right", "mid");
        }
    }
    public static void func(int N, String from, String to, String other) {
        if (N == 1) { // base
            System.out.println("Move 1 from " + from + " to " + to);
        } else {
            func(N - 1, from, other, to);
            System.out.println("Move " + N + " from " + from + " to " + to);
            func(N - 1, other, to, from);
        }
    }
}
```

## 2.打印一个字符串的全部子序列

**题目：**打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

**分析：**

**Base case（基准情形）：**

当出现（`index == str.length`），代表达到字符串的末尾，已经考虑了所有可能的字符组合，当前累积的字符串 `path`（可以是空字符串或包含一些字符的字符串）被认为是一个子序列，并被添加到子序列集合 `subsequence` 中。

**Recursive case（递归情形）：**

当我们还没有达到字符串的末尾时（即还有字符可以考虑是否加入到当前子序列中），算法的递归情形分为两步：

1. **不包含当前字符**：首先，我们递归地处理剩下的字符串，不将当前字符加入到 `path` 中。这表示对于当前考虑的字符，我们选择不包含它在内的所有可能子序列。递归调用 `process(str, index+1, subsequence, path)` 实现了这一点。
2. **包含当前字符**：然后，我们再次递归地处理剩下的字符串，但这次我们将当前字符加入到 `path` 中。这表示对于当前考虑的字符，我们选择包含它在内的所有可能子序列。递归调用 `process(str, index+1, subsequence, path + str[index])` 实现了这一点。

```java
package com.lxy.class16;

import java.util.HashSet;

public class PrintAllSubsequences {
    public static void printallSubsequences(String string){
        char[]str=string.toCharArray();
        HashSet<String> subsequence=new HashSet<>();
        process(str,0,subsequence,"");
        for (String s:subsequence){
            System.out.println(s);
        }
    }

    private static void process(char[] str, int index, HashSet<String> subsequence, String path) {
        if(index==str.length){
            subsequence.add(path);
            return;
        }
        process(str,index+1,subsequence,path);
        process(str,index+1,subsequence,path+str[index]);
    }
}
```

## 3.打印一个字符串的全部排列

**题目：**打印一个字符串的全部排列，要求不要出现重复的排列

**分析：**

Base case（基准情形）：

当`index`等于字符串长度时，意味着已经考虑了字符串中的所有字符，当前字符串的一个排列已经形成。此时，该方法将当前排列的字符串形式添加到答案列表`ans`中。

**Recursive case（递归情形）：**

如果`index`小于字符串长度，表明还有字符需要被考虑用于排列。这时，方法执行以下步骤：

1. 初始化一个`boolean`数组`visited`，长度为256（假设字符集是ASCII），用于标记该字符是否在当前`index`位置被访问过，以避免产生重复的排列。
2. 遍历从`index`到字符串末尾的每个字符：
   - 如果当前字符尚未被访问过（即visited[str[i]]为false），则标记为已访问（visited[str[i]] = true），然后执行两次操作来生成排列：
     - **交换操作**：首先，交换当前索引`index`和循环变量`i`指向的字符，这样当前字符被放到了排列的当前位置。
     - **递归调用**：接着，递归调用`process2`，将`index`加1，以处理下一个位置的字符排列。
     - **还原交换**：递归调用返回后，再次交换`index`和`i`指向的字符，以恢复字符串的原始状态，这样就可以在下一次循环中正确地处理其他字符的排列。

```java
package com.lxy.class17;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

public class PrintAllPermutations {
    public static void printAllPermutations(String string) {
        char[] str = string.toCharArray();
        ArrayList<String> ans = new ArrayList<>();
        process2(str, 0, ans);
        for (String s : ans) {
            System.out.println(s);
        }
    }
    //未去重
    private static void process1(ArrayList<Character> rest, String path, List<String> ans) {
        if(rest.isEmpty()){
            ans.add(path);
            return;
        }
        for (int i = 0; i < rest.size(); i++) {
            char cur = rest.get(i);
            rest.remove(i);
            process1(rest, path + cur, ans);
            rest.add(i, cur);
        }
    }
    public static void swap(char[] chs, int i, int j) {
        char tmp = chs[i];
        chs[i] = chs[j];
        chs[j] = tmp;
    }
    public static void process2(char[] str, int index, List<String> ans) {
        if (index == str.length) {
            ans.add(String.valueOf(str));
        } else {
            boolean[] visited = new boolean[256];
            for (int i = index; i < str.length; i++) {
                if(!visited[str[i]]){
                    visited[str[i]]=true;
                    swap(str, index, i);
                    process2(str, index + 1, ans);
                    swap(str, index, i);
                }
            }
        }
    }
}
```

## 4.逆序栈

**题目：**通过递归实现了反转栈的功能，不使用任何额外的数据结构（如另一个栈或数组）。

**分析：**

`public static void reverse(Stack<Integer> stack)`

这是外部调用的方法，用于反转栈中的元素。它首先检查栈是否为空，如果为空，则不进行任何操作直接返回。如果不为空，它将通过调用`process`方法逐步移除并获取栈底元素（同时间接地反转了栈），然后通过递归调用自身来反转剩余的栈元素。最后，将之前获取的栈底元素压回到栈顶，完成反转过程。

`public static Integer process(Stack<Integer> stack)`

这个方法是递归的核心，负责移除并返回当前栈的栈底元素。它首先弹出栈顶元素。如果在这之后栈变空了，意味着这个元素实际上是栈底元素，直接返回它。如果栈不为空，则递归调用自身，直到找到栈底元素。在递归返回的过程中，它将之前弹出的元素重新压回栈中（但不包括当前的栈底元素），这样在返回到`reverse`方法中时，栈的顺序被逆转，除了最初的栈底元素。

在递归中，每当一个函数调用自身时，当前函数的状态（包括变量、参数等）都会被压入调用栈中，待到递归调用完成后再从栈中弹出，恢复状态。这一点与使用栈来暂存数据的操作非常相似。

也可以通过使用两个栈来简化问题，而这个过程也模拟了递归函数调用的工作方式，当我们使用栈来解决问题时，实质上是在模拟递归函数调用的过程，几个栈的使用同时也说明了需要使用几个递归。

```java
public class ReverseStackUsingRecursive {
    public static void reverse(Stack<Integer> stack){
        if(stack.isEmpty()){
            return;
        }
        int last=process(stack);
        reverse(stack);
        stack.push(last);
    }
    public static Integer process(Stack<Integer>stack){
        int result=stack.pop();
        if(stack.isEmpty()){
            return result;
        }
        else{
            Integer last = process(stack);
            stack.add(result);
            return last;
        }
    }
}
```

# class18

## 1.动态规划

动态规划的一个核心特点就是利用状态记录（也称为缓存或备忘录）来避免重复计算相同子问题的解，从而大幅提高算法的效率。这种方法体现了一种“记忆化”的策略，是解决重叠子问题的有效手段。

1. **问题分析与递归解法尝试**：首先通过分析问题，尝试找到一个递归的解法。这一步骤通常需要一定的直觉和经验，以识别问题是否可以分解为相似的子问题。递归方法的优点在于它能够直观地表达问题的结构，但它可能会导致大量的重复计算。
2. **识别重叠子问题**：在实现递归解法的过程中，识别是否存在重复求解的子问题。这是动态规划方法适用的关键因素之一。如果子问题的解被重复计算多次，那么就存在优化的空间。
3. **引入记忆化技术（自顶向下的动态规划）**：为了优化递归解法，可以引入记忆化技术，也就是缓存子问题的解，确保每个子问题只被解决一次。这一步骤是将递归方法转变为动态规划的关键。通过建立一个数据结构（通常是数组或哈希表）来存储已经计算过的子问题的解，每次求解一个子问题之前先检查其是否已经被解决过，从而避免重复计算。
4. **转换为迭代解法（自底向上的动态规划）**：虽然记忆化技术已经大幅提高了递归解法的效率，但递归方法本身可能会因为调用栈过深而导致效率问题或栈溢出。因此，进一步的优化是将递归方法转换为迭代方法，这通常称为自底向上的动态规划。在这个过程中，算法从最基本的子问题开始，逐步迭代计算更大的问题的解，直到达到最终问题的解。这种方法不仅避免了递归的开销，还可以更灵活地控制计算过程。

## 2.机器人移动

**题目：**有一个机器人位于一条长度为N的直线上，这条直线被划分为N个连续的位置，编号从1到N。机器人开始时位于位置M。机器人在每一步可以选择向左或向右移动一位，但存在边界限制：位于位置1时，只能向右移动到位置2；位于位置N时，只能向左移动到位置N-1。给定机器人必须移动K步，并且最终必须位于位置P的条件下，求机器人有多少种不同的移动方法。

问题的目标是计算在给定的直线长度N，起始位置M，步数K，和目标位置P的条件下，机器人达到目标位置的所有可能路径的数量。

### （1）暴力递归

**分析：**

在解决一个机器人行走问题中，我们定义了一个方法来计算机器人从给定的起始位置cur移动到目标位置P的所有可能路径数量，条件是机器人必须走rest步，且只能在一条长度为N的直线上移动。直线的位置编号从1到N。

**Basecase**：当没有剩余步数（`rest`为0）时，我们检查机器人是否已经在目标位置P。如果是，这条路径是有效的，返回1；如果不是，表示这条路径不能达到目标，返回0。

**Recursive ：**函数首先处理边界条件：

- 如果机器人当前在位置1（左端），它只能向右移动到2位置。
- 如果机器人当前在位置N（右端），它只能向左移动到N-1位置。

对于机器人处于中间位置的情况：

- 它既可以向左也可以向右移动。这里，我们将问题拆分为两个子问题：机器人向左或向右移动一步，并且剩余步数减少1，两者之和便是当前位置到目标位置的方法数。

```java
public class RobotWalk {
    public static int robotWalk(int N,int M,int K,int P){
        return process(M,K,N,P);
    }
    public static int process(int cur,int rest,int N,int P){
        if(rest==0){
            return cur==P?1:0;
        }
        if(cur==1){
            return process(cur+1,rest-1,N,P);
        }
        if(cur==N){
            return process(cur-1,rest-1,N,P);
        }
        return process(cur+1,rest-1,N,P)+process(cur-1,rest-1,N,P);
    }
}
```

### （2）优化1

**分析：**在优化递归解法以提高算法效率的过程中，我们首先需要识别两个关键问题：是否存在重复计算的子问题，以及递归函数的返回值由哪些参数决定。通过深入分析，我们发现：

1. **重复计算的存在**：在递归过程中，相同的状态（即相同的`cur`和`rest`值）可能会被多次计算，这导致了大量不必要的重复工作。

2. **状态的定义**：递归函数的结果完全由两个变量决定，这两个变量是当前位置`cur`和剩余步数`rest`。这意味着，我们可以使用这两个变量作为状态的标识，将它们映射到一个二维数组中，每个元素代表达到相应状态的方法数。

鉴于此，我们引入一个二维数组`int dp[][]`作为状态表，其中`dp[cur][rest]`存储了在`cur`位置，剩余`rest`步时，到达目标位置P的方法数。这种策略允许我们将计算过的状态结果存储起来，当再次遇到相同状态时，直接从状态表中获取结果，而无需重复计算。

通过引入记忆化存储，我们实现了自顶向下的动态规划。这种方法通过消除重复解，不仅显著提高了计算效率，也简化了问题的解决过程。此外，记忆化搜索作为一种优化技术，它桥接了纯递归和动态规划之间的差距，为解决复杂问题提供了一种灵活而强大的工具。

这种优化策略，即通过状态的记忆化来避免递归中的重复计算，是提高算法效率的关键步骤，尤其适用于解决具有重叠子问题特性的动态规划问题。

```java
public static int robotWalk1(int N,int M,int K,int P){
    int[][]dp=new int[N+1][K+1];
    for (int i = 0; i <= N; i++) {
        for (int j = 0; j <= K; j++) {
            dp[i][j]=-1;
        }
    }
    return process1(M,K,N,P,dp);
}
public static int process1(int cur,int rest,int N,int P,int[][]dp){
        if(dp[cur][rest]!=-1){
            return dp[cur][rest];
        }
        if(rest==0){
            dp[cur][rest]=cur==P?1:0;
            return dp[cur][rest];
        }
        if (cur == 1) {
            dp[cur][rest] = process1(cur + 1, rest - 1, N, P, dp); 
        } else if (cur == N) {
            dp[cur][rest] = process1(cur - 1, rest - 1, N, P, dp);
        } else {
            dp[cur][rest] = process1(cur + 1, rest - 1, N, P, dp) + process1(cur - 1, rest - 1, N, P, dp);
        }
        return dp[cur][rest];
    }
```

### （3）优化2

**分析：**在转换递归解法为顺序结构的动态规划时，我们创建了一个二维的动态规划表`dp`，其中`dp[i][j]`表示机器人从`i`位置走到目标位置，剩余`j`步时的路径数。这个转换的核心在于识别和利用状态之间的依赖关系来填充这个表。对于本问题，状态的转移依赖于两个方向的移动：

- **初始化**：在开始填表之前，需要正确初始化表格。特别是，当`j=0`（不需要移动时），除了目标位置`P`在`dp[P][0]=1`（如果机器人已经在目标位置上，则不需要移动即为一种方法），其他位置的路径数为0。

- **依赖关系**：对于非边界位置`i`，`dp[i][j]`的值依赖于其左上（`dp[i-1][j-1]`）和左下（`dp[i+1][j-1]`）两个位置的值的和。这反映了机器人可以从位置`i-1`向右移动到`i`，或者从位置`i+1`向左移动到`i`。
- **边界行为**：特别注意处理边界，即当机器人位于1位置或N位置时的行为。在1位置，机器人只能向右移动，所以`dp[1][j]`只依赖于`dp[2][j-1]`；类似地，在N位置，机器人只能向左移动，所以`dp[N][j]`只依赖于`dp[N-1][j-1]`。
- **按列遍历**：为了保证在计算`dp[i][j]`时，其依赖的状态已经被计算，我们按列（步数`j`）进行遍历。这意味着，在计算完所有位置在`j-1`步的路径数后，再计算它们在`j`步的路径数。

通过这种方法，我们逐步构建了整个`dp`表，每个表项`dp[i][j]`都基于其依赖的状态计算得到。最终，`dp[M][K]`即为从位置M出发，走K步到达任何位置的方法数，其中包含了到达目标位置P的所有可能路径数。这种自底向上的动态规划方法不仅提高了计算效率，避免了递归带来的重复计算和栈溢出问题，而且通过顺序构建和填充状态表，使得算法的逻辑清晰且易于实现。

```java
public static int robotWalk2(int N,int M,int K,int P){
    int[][]dp=new int[N+1][K+1];
    dp[P][0]=1;
    for (int rest = 1; rest <= K; rest++) {
        dp[1][rest] = dp[2][ rest - 1];
        for (int cur = 2; cur <N; cur++) {
            dp[cur][rest] = dp[cur + 1][ rest - 1] + dp[cur - 1][ rest - 1];
        }
        dp[N][rest] = dp[N - 1][ rest - 1];
    }
    return dp[M][K];
}
```

## 3.纸牌游戏

**题目：**在这个策略性的游戏中，有一排数值各不相同的纸牌。两位玩家——我们将他们称为玩家A和玩家B——轮流从这排纸牌的两端拿取一张牌。玩家A有先手优势，意味着他们将先于玩家B进行选择和行动。每位玩家在其回合时，可以选择拿走最左边或最右边的纸牌，并将该牌的数值累加到自己的得分中。这两位玩家都拥有极高的智慧和策略，因此他们在选择纸牌时总是以最优化自己总得分的方式进行。

目标是计算在这两位高度智慧的玩家进行游戏后，最终获胜者的分数。这意味着我们需要评估在玩家都采取最佳策略的情况下，游戏结束时各自的得分，以及由此产生的最高得分。

### （1）暴力递归

**分析：**

**Base Case：**

- **先手情况（`f`函数）**：当只剩下一张纸牌时（即`L == R`），先手玩家直接拿取这张牌，因为没有其他选择，所以返回该张纸牌的值作为得分。
- **后手情况（`g`函数）**：同样地，当只剩一张纸牌时，因为是后手，所以实际上没有剩余的牌可供选择，返回0分，表示后手玩家在这种情况下无法获得任何分数。

**递归逻辑：**

- **先手玩家**：在还有多张纸牌可以选择时，先手玩家会考虑两种情况——拿左边的牌或拿右边的牌。对于每种选择，先手玩家都会转而考虑自己在下一轮变成后手玩家时的情况。因此，先手玩家会计算在拿走左边或右边的牌后，对手作为后手玩家能给自己留下的分数（即调用`g`函数），并从这两种情况中选择得分较高的一种。这样的选择反映了先手玩家利用自己的优势，尽可能使自己的得分最大化。
- **后手玩家**：作为后手玩家，在对方拿走一张牌后，他们也面临两种选择。不过，由于是后手，先手玩家的决策会留给后手玩家一个相对不利的局面。因此，后手玩家在两种可能的选择中，预期自己能得到的分数将会是这两种选择中的较小值（即调用`f`函数），这反映了后手玩家在策略上尽可能减少损失的努力。

```java
public class CardsInLine {
    public static int cardsInLine(int[] arr){
        //先手
        int first=f(arr,0,arr.length-1);
        //后手
        int second=g(arr,0,arr.length-1);
        return Math.max(first,second);
    }
    public static int f(int[]arr,int L,int R){
        if(L==R){
            return arr[L];
        }
        return Math.max(arr[L]+g(arr,L+1,R),arr[R]+g(arr,L,R-1));
    }
    public static int g(int[]arr,int L,int R){
        if(L==R){
            return 0;
        }
        return Math.min(f(arr,L+1,R),f(arr,L,R-1));
    }
}
```

### （2）动态规划

**分析：**动态规划表（DP表）的构建实际上是将递归过程中的决策结果存储起来，以避免重复计算。直接从递归解法转换到动态规划（DP）是动态规划优化过程中一个常见且有效的策略。

- **递归到DP的直接映射**：在许多情况下，递归函数已经隐含了动态规划的状态转移逻辑。每一次递归调用，其实都是对一个子问题的求解，而这些子问题往往有重叠，这正是动态规划所能优化的地方。通过识别这些子问题及其依赖关系，可以直接将递归逻辑映射到一个或多个DP表上。
- **依赖关系决定遍历顺序**：在DP表中填入值的过程需要仔细选择，以确保在计算一个状态之前，它依赖的所有状态都已经被计算。这就要求我们理解各状态之间的依赖关系，从而确定DP表的填表顺序。对于许多问题，这意味着可能需要按特定顺序遍历表的行和列。
- **填表顺序的实际操作**：在上述纸牌游戏问题中，动态规划表的填表顺序是按对角线顺序进行的，这确保了在计算`fdp[L][R]`或`gdp[L][R]`时，`fdp[L+1][R]`、`gdp[L+1][R]`、`fdp[L][R-1]`和`gdp[L][R-1]`这些它依赖的状态都已经被计算过。这种填表策略直接源自于递归解法中对子问题求解的顺序。

```java
public static int cardsInLine1(int[] arr){
    int l=arr.length;
    int[][]fdp=new int[l][l];
    int[][]gdp=new int[l][l];
    for (int i = 0; i < l; i++) {
        fdp[i][i]=arr[i];
    }
    for (int col = 1; col < l; col++) {
        int L=0;
        int R=col;
        while(R<l){
            fdp[L][R]=Math.max(arr[L]+gdp[L+1][R],arr[R]+gdp[L][R-1]);
            gdp[L][R]=Math.min(fdp[L+1][R],fdp[L][R-1]);
            L++;
            R++;
        }
    }
    int first=fdp[0][l-1];
    int second=gdp[0][l-1];
    return Math.max(first,second);
}
```

# class19

## 1.背包问题

**题目：**背包问题，要求确定在给定重量限制下，如何选择物品组合以最大化背包内物品的总价值。有两个长度相等的数组`weights`和`values`，它们分别表示一系列物品的重量和价值，其中`weights[i]`是第`i`号物品的重量，而`values[i]`是其对应的价值。此外，我们还有一个参数`bag`，它代表一个背包的最大承重能力。

任务是在不超过背包承重限制的前提下，选择一组物品装入背包，使得这些物品的总价值尽可能大。每件物品只有一件，可以选择装入或不装入背包，不能拆分。需要计算在遵守重量限制的条件下，能够获得的最大价值总和。

### （1）递归

**分析：**

**Basecase：**

- **遍历结束**：当`index == w.length`时，意味着所有物品都已被考虑，不再有物品可以选择放入背包。这时返回0，表示没有更多的价值可以通过添加物品获得。
- **背包容量超重**：如果在某一步选择后，`restBag < 0`，说明这种选择使背包的重量超出了限制，因此这条路径不可行，返回-1。这种情况下的-1标记着一个失败的尝试，需要被上层调用逻辑排除。

**递归逻辑：**在每个递归过程中，面临两个选择：将当前的物品放入背包或不放入背包。这两种选择分别对应两个递归分支：

- **不放入背包**：直接跳过当前物品，考虑下一个物品（`index + 1`），而背包的剩余容量`restBag`保持不变。这一选择总是有效的，因为它不增加背包的负载。
- **放入背包**：尝试将当前物品加入背包，这意味着背包的剩余容量将减少当前物品的重量（`restBag - w[index]`），然后递归考虑下一个物品。这一选择可能因为背包超载而变得无效，这时递归调用将返回-1。

```java
public class Knapsack {
    public static int knapsack(int[] w, int[] v, int bag) {
        return process(w,v,0,bag);
    }
    public static int process(int[]w,int[]v,int index,int restBag){
        if(restBag<0){
            return -1;
        }
        if(index==w.length){
            return 0;
        }
        int p1=process(w,v,index+1,restBag);
        int p2=0;
        int tmp=process(w,v,index+1,restBag-w[index]);
        if(tmp!=-1){
            p2=v[index]+tmp;
        }
        return Math.max(p1,p2);
    }
}
```

### （2）动态规划

**分析：**

- **DP表的定义**：`dp[i][j]`表示考虑到第`i`个物品时（数组中的`i-1`位置，因为`dp`表的大小是`N+1`），对于容量为`j`的背包，可以获得的最大价值。动态规划表`dp`的大小是`(N+1) x (bag+1)`，其中`N`是物品数量，`bag`是背包的最大容量。表中的每个单元格最初都被初始化为0（Java数组默认初始化行为），这代表在没有任何物品或容量为0的情况下，最大价值为0。
- **遍历顺序**：从后向前遍历物品（即从最后一个物品开始考虑），对于每个物品，从背包的最大容量向下遍历到0。这种遍历顺序确保在计算`dp[index][restBag]`时，依赖的`dp[index+1][...]`值已经被计算。

```java
public static int knapsackByDp(int[] w, int[] v, int bag) {
    int N=w.length;
    int[][] dp=new int[N-1][N-1];
    for (int index = N-1; index >=0 ; index--) {
        for (int restBag=bag;restBag>=0;restBag--){
            int p1=dp[index+1][restBag];
            int p2=0;
            if(restBag-w[index]>=0)
            {
                p2=v[index]+dp[index+1][restBag-w[index]];
            }
            dp[index][restBag]=Math.max(p1,p2);
        }
    }
    return dp[0][bag];
}
```

## 2.数字字符串的解码

**题目：**根据一个特定的数字到字母映射规则，数字`1`到`26`分别对应英文字母`A`到`Z`，这种映射允许我们将一个纯数字字符串转换成一个或多个可能的字母组合，发现并计数一个给定数字字符串基于规则的所有可能的解码方式。

以字符串"111"为例，它可以被解码为多种字母组合，包括"AAA"（即`1-1-1`）、"KA"（即`11-1`）和"AK"（即`1-11`）。我们的目标是编写一个程序，该程序能够接受任意一个只包含数字字符的字符串作为输入，并计算出这个字符串可以被转换成多少种不同的字母组合。

### （1）递归

**分析：**

**Basecase：**

- **遍历完成**：当递归遍历到字符串的末尾时，表示已经成功找到了一种映射方式，因为在此之前的所有字符都已经按照规则成功映射成字母。这种情况下返回1，作为基本情况的成功标识。

**递归逻辑：**

- **当前字符为'0'**：由于'0'无法对应到任何字母，且不参与任何有效的双字符映射（如'10'对应'J'，'20'对应'T'），遇到'0'时应立即返回0，表示当前路径不可行。
- **单字符映射**：除了'0'之外的任何单个字符都可以直接映射到一个字母。这种情况下，继续递归处理下一个字符，即调用`process(str, index + 1)`。
- **双字符映射**：如果当前字符和紧随其后的一个字符组合在一起形成的数字小于或等于26，则这两个字符可以共同映射到一个字母。需要检查下一个字符是否存在（即`index + 1 < str.length`）并且组合成的数字有效（`<=26`）。如果条件满足，继续递归处理接下来的字符，即调用`process(str, index + 2)`。

```java
public class ConvertToLetterString {
    public static int convertToLetterString(String str) {
        return process(str.toCharArray(),0);
    }
    public static int process(char[]str,int index){
        if(index==str.length){
            return 1;
        }
        if(str[index]=='0'){
            return 0;
        }
        int p=process(str,index+1);
        if(index+1!=str.length&&(str[index]-'0')*10+str[index+1]-'0'<27){
            p+=process(str,index+2);
        }
        return p;
    }
}
```

### （2）动态规划

**分析：**

- **一维DP数组**：在这个问题中，每个状态（即每个字符串位置）的解只依赖于其后面位置的解。因此，可以使用一个一维DP数组来存储从当前位置到字符串末尾的所有可能的解码方式数量。这样，数组的每个元素`dp[i]`就代表从位置`i`开始到字符串末尾的子字符串的解码方式数量。DP数组的最后一个位置`dp[N]`（其中`N`为字符串长度）初始化为1，表示空字符串有一种“解码”方式，即不进行任何操作。这是递归到达字符串末尾时的终止条件的直接对应，也是DP填表过程的基础。
- **从后向前遍历**：动态规划解决方案的一个关键特点是从后向前填充DP数组。这种方法确保在计算当前位置的解码方式数量时，依赖的后续位置的解码方式数量已经被计算并存储在DP数组中。具体到这个问题，就是从字符串的最后一个字符开始，逐步向前计算每个位置的解码方式数量，直到达到字符串的起始位置。

```java
public static int convertToLetterStringByDp(String string) {
    int N=string.length();
    char[] str = string.toCharArray();
    int[]dp=new int[N+1];
    dp[N]=1;
    for (int index = N-1; index >=0 ; index--) {
        if(str[index]!='0'){
            int ways=dp[index+1];
            if(index+1!=N&&(str[index]-'0')*10+str[index+1]-'0'<27){
                ways+=dp[index+2];
            }
            dp[index]=ways;
        }
    }
    return dp[0];
}
```

## 3.贴纸拼字游戏

**题目：**在这个有趣的贴纸拼字游戏中，我们的目标是利用一系列提供的贴纸来拼凑出一个指定的目标字符串。每张贴纸包含了一些小写英文字母，且你可以将每张贴纸中的字母单独剪开使用。任务是确定最少需要使用多少张贴纸，才能组合出目标字符串。

给定：

- 一个目标字符串`str`，由小写英文字母组成。
- 一个字符串数组`arr`，每个元素代表一张贴纸，包含的字符也都是小写英文。

你需要从`arr`中选择并“剪切”字母，以拼凑出`str`。每张贴纸可以被选择多次，但每次使用时可以任意选择剪切其中的一个或多个字母。考虑到贴纸的数量可能有限，找出完成拼凑`str`所需的最小贴纸数量。

例如，对于目标字符串`"babac"`和贴纸数组`["ba", "c", "abcd"]`，最少需要2张贴纸。可能的最优解包括使用两次`"abcd"`贴纸或一次`"abcd"`加一次`"ba"`贴纸。

任务：编写一个程序，返回实现上述目标所需的最少贴纸数量。

### （1）递归

**分析：**

**Basecase：**当目标字符串`target`变为空时，这意味着我们已经成功使用一系列贴纸组合出了目标字符串，不再需要更多的贴纸。因此，在这种情况下返回0，表示当前路径不需要额外的贴纸。

**递归逻辑：**对于给定的目标字符串和一组贴纸，我们尝试每一张贴纸，看看它能如何贡献于目标字符串的构建。通过“剪切”掉贴纸上存在的字符，我们得到一个新的目标字符串（即`rest`字符串），这个新目标较之前的目标减少了一些字符。

对于每张尝试的贴纸，我们递归地计算剩余目标字符串`rest`所需的最小贴纸数量。通过比较所有贴纸带来的结果，选择使得剩余目标字符串所需贴纸数量最小的贴纸。因为我们每次都至少使用了一张贴纸，所以在得到最小值后需要将其加一（代表当前贴纸的使用）。

**字符减法逻辑**：实现目标字符串减去贴纸字符的功能通过计数数组完成。首先，我们统计目标字符串中每个字符的出现频率。然后，对于尝试的每张贴纸，减少相应字符的计数。如果计数大于0，意味着该字符在剩余目标字符串中仍然需要被构建，因此我们将这些字符重新组合成新的剩余目标字符串。

```java
public static int minStickers(String[] stickers, String target) {
    int ans=process(stickers,target);
    return ans==Integer.MAX_VALUE?-1:ans;
}
public static int process(String[]stickers,String target){
    if(target.isEmpty()){
        return 0;
    }
    int min=Integer.MAX_VALUE;
    for (String sticker:stickers){
        String rest=minus(target,sticker);
        if(target.length() != rest.length()){
            min=Math.min(process(stickers,rest),min);
        }
    }
    return min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min+1;
}
public static String minus(String s1,String s2){
    char[] str1 = s1.toCharArray();
    char[] str2= s2.toCharArray();
    int[] count=new int[26];
    for(char c:str1){
        count[c-'a']++;
    }
    for(char c:str2){
        count[c-'a']--;
    }
    StringBuilder rest = new StringBuilder();
    for (int i = 0; i < count.length; i++) {
        while(count[i]-->0){
            rest.append(i + 'a');
        }
    }
    return rest.toString();
}
```

### （2）递归剪枝

**剪枝策略**：在这个方法中，采用了一个精巧的剪枝策略，极大地提高了效率。这个策略基于一个观察：如果当前贴纸不包含目标字符串的第一个字符，那么在这一步使用这张贴纸对于目标第一个字符是没有意义的，而且如果这张贴纸包含目标字符串的后续字符，那么也会在拥有第一个目标字符串第一个字符的贴纸后续使用，并且对于本题，使用贴纸的先后顺序不影响结果，可以减少重复计算。因此，我们只考虑那些至少包含目标字符串第一个字符的贴纸，这样做可以显著减少搜索空间，加快寻找最少贴纸数量所需的时间。

**数组优化：**此外，通过将贴纸转换为一个字符计数的二维数组，这种方法不仅使得剪枝更加容易实施（因为可以直接检查贴纸是否包含目标字符串的首字母），而且在执行“字符减法”以计算使用贴纸后剩余的目标字符串时，也提供了极大的便利。这种数组优化手段允许我们快速地进行字符的添加和删除操作，从而高效地更新目标字符串，推进解题过程。

```java
public static int minStickers1(String[] stickers, String target) {
    int N=stickers.length;
    int[][] count=new int[N][26];
    for (int i = 0; i < N; i++) {
        char[] str = stickers[i].toCharArray();
        for(char c:str){
            count[i][c-'a']++;
        }
    }
    int ans=process1(count,target);
    return ans==Integer.MAX_VALUE?-1:ans;
}

private static int process1(int[][] stickers, String t) {
    if(t.isEmpty()){
        return 0;
    }
    char[] target = t.toCharArray();
    int[] tcounts = new int[26];
    for (char cha : target) {
        tcounts[cha - 'a']++;
    }
    int min=Integer.MAX_VALUE;
    for (int[] sticker:stickers){
        //剪枝
        if(sticker[target[0]-'a']!=0){
            StringBuilder rest = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                if (tcounts[i] > 0) {
                    for (int j = 0; j < tcounts[i] - sticker[i]; j++) {
                        rest.append((char)('a' + i));
                    }
                }
            }
            min=Math.min(min,process1(stickers,rest.toString()));
        }
    }
    return min==Integer.MAX_VALUE?Integer.MAX_VALUE:min+1;
}
```

### （3）动态规划

将上述问题的解决方案从递归结构改为顺序结构（动态规划）的直接转换可能不是非常直观，因为问题的本质是高度递归的，并涉及到对每个子问题字符串的处理。在递归解法中，通过记忆化递归（即`HashMap<String, Integer> dp`）已经是向动态规划过渡的一种方式，因为它缓存了子问题的结果来避免重复计算。

要将此问题转换为完全的顺序结构，理论上需要能够按照某种方式顺序地遍历所有可能生成的子字符串，并为它们计算所需的最少贴纸数量。然而，由于子字符串的生成依赖于贴纸的具体组合，而这些组合又是指数级增长的，因此直接构建一个顺序遍历所有子字符串状态的动态规划表格是不可行的。

因此使用记忆化搜索（一种自顶向下的动态规划方法）来优化贴纸拼字问题的解决方案。这种方法利用一个映射表（`HashMap`）来存储和重用之前已经计算过的子问题的结果，从而避免重复计算。

```java
public static int minStickers2(String[] stickers, String target) {
    int N=stickers.length;
    int[][] count=new int[N][26];
    for (int i = 0; i < N; i++) {
        char[] str = stickers[i].toCharArray();
        for(char c:str){
            count[i][c-'a']++;
        }
    }
    HashMap<String,Integer> dp = new HashMap<>();
    dp.put("", 0);
    int ans=process2(count,target,dp);
    return ans==Integer.MAX_VALUE?-1:ans;
}
public static int process2(int[][] stickers, String t, HashMap<String, Integer> dp) {
    if (dp.containsKey(t)) {
        return dp.get(t);
    }
    char[] target = t.toCharArray();
    int[] tcounts = new int[26];
    for (char cha : target) {
        tcounts[cha - 'a']++;
    }
    int N = stickers.length;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < N; i++) {
        int[] sticker = stickers[i];
        if (sticker[target[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                if (tcounts[j] > 0) {
                    int nums = tcounts[j] - sticker[j];
                    for (int k = 0; k < nums; k++) {
                        builder.append((char) (j + 'a'));
                    }
                }
            }
            String rest = builder.toString();
            min = Math.min(min, process2(stickers, rest, dp));
        }
    }
    int ans = min + (min == Integer.MAX_VALUE ? 0 : 1);
    dp.put(t, ans);
    return ans;
}
```

## 4.最长公共子序列的长度

**题目：**在这个问题中，我们需要寻找两个给定字符串的最长公共子序列（LCS，Longest Common Subsequence）的长度。一个字符串的子序列是指在该字符串中删除某些字符（也可能一个都不删除）后剩余字符形成的新字符串。公共子序列则是指两个或多个字符串共有的子序列。

具体来说，给定两个字符串`str1`和`str2`，我们的任务是找到它们之间的最长公共子序列，并返回这个子序列的长度。

例如，给定`str1 = "a12b3c456d"`和`str2 = "1ef23ghi4j56k"`，这两个字符串的最长公共子序列是`"123456"`。因此，对于这个例子，你的程序应该返回长度`6`，这表示找到的最长公共子序列包含六个字符。

### （1）递归

**分析：**

**基本情况和边界处理**

- **基础情形**：当两个字符串的指针`i`和`j`都指向各自字符串的起始位置时，即考虑两个字符串的第一个字符，如果这两个字符相等，则最长公共子序列的长度为1；如果不相等，则为0。

- **边界处理**：
  - **当`i`为0但`j`不为0**：此时只有`str1`的第一个字符可用。如果`str1[0]`与`str2[j]`不相等，继续探索`str2`的前一位置。如果相等，返回1，因为找到了一个公共字符。
  - **当`j`为0但`i`不为0**：处理逻辑同上，但角色互换，探索`str1`的前一位置或返回1。

**递归逻辑和解决方案的可能情况**

在解决LCS问题时，可以通过考虑以下四种情况来穷尽所有可能的子序列组合：

1. **不以`str1[i]`和`str2[j]`结尾**：实际上它的结果被情况2和3覆盖，因为任何不包含`str1[i]`或`str2[j]`的子序列都不能比包含其中之一的子序列更长。

2. **可能以`str1[i]`结尾，但不以`str2[j]`结尾**：这考虑了`str1[i]`对LCS的贡献，但不考虑`str2[j]`，寻找`str1[0...i]`与`str2[0...j-1]`的LCS。

3. **不以`str1[i]`结尾，但可能以`str2[j]`结尾**：这与情况2相反，考虑了`str2[j]`的潜在贡献，寻找`str1[0...i-1]`与`str2[0...j]`的LCS。

4. **同时以`str1[i]`和`str2[j]`结尾**：只有当`str1[i]`与`str2[j]`相等时，才考虑这种情况，此时LCS长度增加1。这种情况下的LCS长度一定至少和情况2或情况3一样长，因为它包含了一个额外的公共字符。

对于上述情况，我们可以再次进行优化（在递归版本中，使用的是下面的优化）

- **当`str1[i]`与`str2[j]`相等时**：在这种情况下，我们确定`str1[i]`和`str2[j]`可以作为当前的最长公共子序列的一部分。因此，我们计算以`str1[i-1]`和`str2[j-1]`结尾的最长公共子序列长度，并将这个长度加1（即`process(s1, s2, i-1, j-1) + 1`）。这一加法反映了`str1[i]`和`str2[j]`的匹配为当前LCS贡献了一个额外的长度。
- **当`str1[i]`与`str2[j]`不相等时**：在这种情况下，当前字符`str1[i]`和`str2[j]`不能同时作为LCS的一部分。因此，我们需要探索两个分支：一个是保持`str1[i]`固定并向前探索`str2[j-1]`的可能性（`process(s1, s2, i, j-1)`），另一个是保持`str2[j]`固定并向前探索`str1[i-1]`的可能性（`process(s1, s2, i-1, j)`）。我们选取这两个分支中LCS长度较大的一个，以确保不丢失潜在的更长公共子序列。

这种方法通过分析所有可能的字符组合和递归探索，找到了两个字符串之间的最长公共子序列。这种详细的分解和分类有助于深入理解问题，并指导我们设计有效的递归解决方案。通过进一步引入记忆化技术，可以优化递归过程，减少重复计算，提高解题效率。

```java
package com.lxy.class19;

public class LongestCommonSubsequence {
    public static int longestCommonSubsequence(String s1, String s2) {
        return process(s1.toCharArray(),s2.toCharArray(),s1.length()-1,s2.length()-1);
    }

    private static int process(char[] s1, char[] s2, int i, int j) {
        if(i==0&&j==0){
            return s1[i] == s2[j] ? 1 : 0;
        }else if(i==0){
            return s2[j]!=s1[i]?process(s1,s2,i,j-1):1;
        }else if(j==0){
            return s2[j]!=s1[i]?process(s1,s2,i-1,j):1;
        }else{
            int p1=process(s1,s2,i,j-1);
            int p2=process(s1,s2,i-1,j);
            int p3=s1[i]==s2[j]?process(s1,s2,i-1,j-1)+1:0;
            return Math.max(p1,Math.max(p2,p3 ));
        }
    }
}
```

### （2）动态规划

**动态规划表的初始化**

- 初始化`dp[0][0]`：比较`str1`和`str2`的第一个字符，如果它们相等，`dp[0][0]`设置为1，否则设置为0。
- 初始化第一列`dp[i][0]`：对于`str1`中的每个字符，如果它与`str2`的第一个字符不相等，就沿用上一个单元格的值（即`dp[i-1][0]`），反映到目前为止的最长公共子序列长度。如果相等，则这一列的剩余部分都设置为1，因为找到了一个公共字符。
- 初始化第一行`dp[0][j]`：对于`str2`中的每个字符，采取与第一列相同的逻辑。

**动态规划表的填充**

对于`dp`矩阵中的每个其他单元格（即`i > 0`且`j > 0`的情况）：

- 如果`str1[i]`与`str2[j]`相等，那么`dp[i][j]`的值是左上角单元格的值`dp[i-1][j-1]`加1，因为找到了一个新的公共字符，可以将LCS的长度增加1。
- 如果`str1[i]`与`str2[j]`不相等，那么`dp[i][j]`的值是左边`dp[i][j-1]`和上边`dp[i-1][j]`单元格值中的较大者。这表示LCS要么来自不包含当前`str1[i]`字符的序列，要么来自不包含当前`str2[j]`字符的序列。

```java
public static int longestCommonSubsequenceByDp(String str1, String str2) {
    char[]s1=str1.toCharArray();
    char[]s2=str2.toCharArray();
    int N= s1.length;
    int M= s2.length;
    int[][]dp=new int[N][M];
    dp[0][0]=s1[0] == s2[0] ? 1 : 0;
    for (int i = 1; i < N; i++) {
        dp[i][0]=s2[0]!=s1[i]?dp[i-1][0]:1;
    }
    for (int j = 1; j < M; j++) {
        dp[0][j]=s2[j]!=s1[0]?dp[0][j-1]:1;
    }
    for (int i = 1; i < N; i++) {
        for (int j = 1; j < M; j++) {
            if (s1[i] == s2[j]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]);
            }
        }
    }
    return dp[N-1][M-1];
}
```

# class20

## 1.最长回文子序列

**题目：**找到给定字符串的最长回文子序列的长度。回文子序列是指，从原字符串中删除一些（也可以不删除）字符后，所形成的序列正读和反读都相同。与回文子串不同的是，子序列不需要元素在原字符串中连续。

比如 ： str = “a12b3c43def2ghi1kpm”，最长回文子序列是“1234321”或者“123c321”，返回长度7

**分析：**这个问题深入探讨了寻找给定字符串中最长回文子序列长度的方法，揭示了其与最长公共子序列问题的关联性。通过反转原字符串并求取两者之间的最长公共子序列，我们可以巧妙地找到最长的回文子序列。这种方法不仅充分利用了已有的算法框架，也为解决问题提供了一个新颖的视角。

除此之外，本问题还可以通过直接解决的方式来处理。这种直接解决方法基于动态规划中的范围模型，主要考虑字符串两端字符是否应该被包含在求解过程中。在这一策略下，我们将通过一种较为直观的递归方法来尝试解决问题，虽然这可能是最初级和直接的尝试，但它能够确保问题被全面地探索。

### （1）递归

**Basecase：**

- 当字符串只包含一个字符时，它本身就是一个长度为1的回文子序列。
- 当字符串包含两个字符时，如果这两个字符相等，则构成长度为2的回文子序列；如果不相等，则最长回文子序列的长度为1。

**递归逻辑：**对于更长的字符串，我们考虑四种情况：只考虑左边字符、只考虑右边字符、同时考虑两边字符、或者两边字符都不考虑。通过递归地应用这四种情况，我们可以覆盖所有可能的子序列。

尽管其中一些情况可能会被其他情况所覆盖，但在初步尝试时包含它们有助于确保我们不遗漏任何可能的子序列。

```java
public class LongestPalindromeSubsequence {
    public static int longestPalindromeSubsequence(String s){
        return process(s.toCharArray(),0,s.length()-1);
    }
    public static int process(char[]str,int L,int R){
        if(L==R){
            return 1;
        }
        if(L==R-1){
            //当有两个字符时，如果它们相等则为2，不等则为1
            return str[L]==str[R]?2:1;
        }
        int p1=process(str,L,R-1);
        int p2=process(str,L+1,R);
        int p3=process(str,L+1,R-1);
        int p4=str[L]==str[R]?process(str,L,R-1)+2:0;
        return Math.max(Math.max(p1, p2), Math.max(p3, p4));
    }
}
```

### （2）动态规划

在进一步探索动态规划方法时，我们可以通过分析`dp`表格中元素的依赖关系来获得洞见。特别是，在观察表格中的单元格时，我们注意到每个单元格的值取决于它相邻的左侧、正下方和左下方单元格的值。这种依赖关系的探讨揭示了一个重要的发现：任何给定单元格的“下方”值实际上代表了其下方单元格的左侧、正下方和左下方值的最大值。因此，可以得出结论，正下方的值总是大于或等于左下方的值。同样地，左侧的值也总是大于或等于左下方的值，这意味着在决策过程中，左下方的值可以被忽略，因为它不会比左侧和正下方的值提供更优的解。

这一洞察点对于简化决策逻辑尤为重要。它表明，在考虑如何填充`dp`表时，我们可以优化我们的逻辑，排除那些已被其他选项覆盖的冗余情况。具体到我们的问题中，即找到字符串的最长回文子序列，这意味着“左不考虑、右不考虑”的情况可以被省略，因为它在逻辑上已经包含在“只考虑左边”和“只考虑右边”的情况中了。这样的优化不仅使问题解决过程更为高效，也使得动态规划表的填充过程更加直观。

总之，这种方法展示了通过细致分析问题的结构，我们可以有效地简化和优化解决方案。记忆化搜索提供了一种通过缓存中间结果来避免重复计算的策略，而严格定义的表结构则进一步优化了问题解决策略，确保了高效和准确。在解决复杂问题时，这些技巧和策略的应用，不仅加深了我们对问题本质的理解，也提高了解决问题的效率。

```java
public static int longestPalindromeSubsequenceByDp(String s){
        char[]str=s.toCharArray();
        int N = str.length;
        int[][]dp=new int[N][N];
        for (int i = 0; i < N; i++) {
            dp[i][i]=1;
        }
        for (int i = 0; i < N-1; i++) {
            dp[i][i+1]=str[i]==str[i+1]?2:1;
        }

        for (int L = N-3; L >=0; L--) {
            //也可以斜着填表
            for (int R =L+2 ; R <N ; R++) {
                dp[L][R]=Math.max(dp[L][R-1], dp[L+1][R]);
                if(str[L]==str[R]){
                    dp[L][R]=Math.max(dp[L][R],dp[L+1][R-1]+2);
                }
            }
        }
        return dp[0][N-1];
    }
```

## 2.象棋

**题目：**考虑将一个标准的象棋棋盘置于第一象限内，使得棋盘的最左下角坐落于坐标原点(0,0)。这样配置下的棋盘由9条垂直线和10条水平线划分，形成了象棋的标准竞技场。在这个设置中，我们专注于探索象棋中的“马”在这样的棋盘上的运动。

具体地，给定三个参数：x，y，和k，我们的目标是计算“马”从原点(0,0)出发，经过恰好k步后，准确落在点(x,y)的不同路径数量。

### （1）递归

**Basecase：**当剩余步数为0时，我们检查“马”是否正好位于目标位置(a,b)。如果是，这条路径被视为一种有效的解决方案，因此返回1；否则，表示这不是一条可行的路径，返回0。

**边界行为：**在每次递归调用中，我们首先检查“马”是否越出棋盘界限。如果“马”位置(x, y)超出了棋盘的范围（横坐标0到9，纵坐标0到8），则当前路径不可行，返回0。

**递归逻辑：**“马”的移动特性决定了它有8种不同的行进方向。对于每一个可能的方向，我们递减剩余步数并递归地计算到达目标位置的路径数量。所有这些方向的路径数累加起来，就构成了从当前位置出发，剩余给定步数内到达目标位置的总路径数。

这种方法通过枚举“马”可能的所有行进方向，并递归地探索每种方向可能达到的位置，从而实现了对问题空间的全面搜索。

```java
public class HorseJump {
    public static int horseJump(int a,int b,int k){
        return process(a,b,k,0,0);
    }
    public static int process(int a,int b,int rest,int x,int y){
        if(rest==0){
            return a==x&&b==y?1:0;
        }
        if(x < 0 || x > 9 || y < 0 || y > 8){
            return 0;
        }
        int ways=process(a,b,rest-1,x+1,y+2);
        ways+=process(a,b,rest-1,x+2,y+1);
        ways+=process(a,b,rest-1,x+2,y-1);
        ways+=process(a,b,rest-1,x+1,y-2);
        ways+=process(a,b,rest-1,x-1,y-2);
        ways+=process(a,b,rest-1,x-2,y-1);
        ways+=process(a,b,rest-1,x-2,y+1);
        ways+=process(a,b,rest-1,x-1,y+2);
        return ways;
    }
}
```

### （2）动态规划

**分析：**考虑到“马”的跳跃可以由三个变量（`x`，`y`，`rest`）定义，我们构建一个三维动态规划表`dp[x][y][rest]`来储存从原点到达`(x, y)`位置，剩余`rest`步时的路径数量。

1. **初始化**：根据递归逻辑初始化动态规划表。
2. **填表逻辑**：动态规划表的填充遵循特定的顺序，即从表的“底部”开始填充，逐步向“顶部”移动。这里，“底部”指的是`rest = 0`的层，而“顶部”则对应于`rest = k`的情况。这样的顺序确保在计算任一`dp[x][y][rest]`值时，其依赖的`dp[x'][y'][rest - 1]`（即下一层）的值已经被计算和存储。

```java
public static int pick(int[][][] dp, int rest,int x, int y) {
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    return dp[x][y][rest];
}
public static int horseJumpByDp(int a,int b,int k){
    int[][][]dp=new int[10][9][k+1];
    dp[a][b][0]=1;
    for (int rest = 1; rest < k+1; rest++) {
        for (int x = 0; x < 10; x++) {
            for (int y = 0; y < 9; y++) {
                int ways=pick(dp,rest-1,x+1,y+2);
                ways+=pick(dp,rest-1,x+2,y+1);
                ways+=pick(dp,rest-1,x+2,y-1);
                ways+=pick(dp,rest-1,x+1,y-2);
                ways+=pick(dp,rest-1,x-1,y-2);
                ways+=pick(dp,rest-1,x-2,y-1);
                ways+=pick(dp,rest-1,x-2,y+1);
                ways+=pick(dp,rest-1,x-1,y+2);
                dp[x][y][rest]=ways;
            }
        }
    }
    return dp[0][0][k];
}
```

## 3.排队泡洗咖啡

**题目：**探索一个与咖啡相关的优化问题，旨在找到最快的方式让一组人群享用咖啡并清洗所有的咖啡杯。具体地，我们有以下条件和资源：

1. **咖啡机泡咖啡时间**：一个数组`arr`，其中`arr[i]`表示第`i`号咖啡机泡制一杯咖啡所需的时间。每台咖啡机在任一时刻只能服务一个人，且各台咖啡机可以同时工作。

2. **人数**：一个正整数`N`，代表等待享用咖啡的人数。每个人拿到咖啡后会立即饮用完毕。

3. **清洗时间**：一个正整数`a`，表示用咖啡机清洗一个咖啡杯所需的时间。咖啡杯清洗过程是串行的，即一次只能清洗一个咖啡杯。

4. **自然挥发时间**：一个正整数`b`，表示咖啡杯自然挥发干净所需的时间。不同的咖啡杯可以同时自然挥发。

目标是确定所有人都喝完咖啡且所有咖啡杯都变干净的最短总时间。这包括泡咖啡的时间、人们等待和喝咖啡的时间，以及最后清洗或挥发咖啡杯的时间。考虑到咖啡杯可以选择机洗或自然挥发，找到一个最优的清洗策略，以最小化完成整个过程所需的时间。

### （1）递归

**分析：**若要找到最快的方式让一组人群享用咖啡并清洗所有的咖啡杯，我们可以先探寻最优的排队享用咖啡贪心策略，然后再探寻最优的清洗咖啡时间。

由于排队多个咖啡，这是并行的，可以考虑递归，但这里进行优化，使用贪心算法，我们可以采用的贪心策略是比较咖啡机的工作时间以及咖啡机目前空闲的时间点之和，即当前人排队且泡完咖啡的时间，具体实现是利用小根堆，创建这一信息，每次从小根堆取出的便是，最小的当前人排队且泡完咖啡的时间，并且我们记录这一时间放入drinkOutTimePoint数组，表示当前人喝完咖啡的时间点，注意每个人喝咖啡时间可以当作0。

在洗咖啡的过程种，使用咖啡清洗机是串行的，但挥发是并行的，这里想不到很好的贪心策略，使用递归，基本情况是drinkOutTimePoint遍历结束，不需要再洗了，返回0。递归逻辑为，如果用咖啡清洗机洗，那么需要判断开始洗的时间，因为咖啡清洗机未必准备就绪，然后由于木桶效应，需要在这次用咖啡清洗机洗结束的时间与剩余人咖啡清洗后的时间取最大值，一般情况下是剩余人咖啡清洗后的时间时间大，但也存在咖啡清洗机清洗时间大于最后一人清洗咖啡杯选择挥发时间的情况，然后如果不洗的话，也是根据木桶效用，比较咖啡通过挥发清洗后的时间和剩余人咖啡清洗后的时间取最大值，然后将洗与不洗的时间取最小值，找到当前情况下最优时间。

针对如何安排一群人使用有限数量的咖啡机的问题，可以使用一个基于贪心算法的策略。该策略通过构建一个小根堆来管理每台咖啡机完成工作的时间点，确保每次都能优先使用最早空闲的咖啡机。这样的安排最小化了整体等待和制备咖啡的时间，从而实现了咖啡制备过程的高效管理。

1. **贪心选择**：通过比较各咖啡机当前的空闲时间点加上其工作时间（即泡制一杯咖啡所需时间），选择最早能提供服务的咖啡机为下一位顾客制作咖啡。
2. **记录完成时间**：每个人获取咖啡后立即饮用，因此饮用时间可以忽略不计。记录每个人喝完咖啡的时间点到`drinkOutTimePoint`数组中，为后续的清洗策略提供必要的信息。

对于咖啡杯清洗问题，由于清洗机的串行工作特性和咖啡杯自然挥发的并行特性，直接应用贪心算法变得复杂。因此，采用递归方法来探索最优清洗策略变得十分必要。

1. **基本情况**：当所有咖啡杯都考虑完毕，即`drinkOutTimePoint`数组遍历结束时，返回0，表示没有更多的清洗需求。

2. **递归逻辑**：对于每个咖啡杯，考虑两种情况——使用清洗机清洗与自然挥发。

   **清洗机清洗**：当选择使用清洗机清洗咖啡杯时，我们需要计算开始清洗的具体时间点。这个时间点取决于两个因素：一是咖啡杯使用完毕的时间点，二是清洗机变得空闲的时间点。实际的开始清洗时间是这两者中的较大值，因为我们既不能在咖啡杯还未使用完之前开始清洗，也不能在清洗机还在忙碌时开始下一轮清洗。

   - **考虑清洗所需时间**：从开始清洗的时间点起，加上清洗机清洗一次所需的固定时间`wash`，便得到了这个咖啡杯清洗完成的时间点。
   - **递归计算剩余咖啡杯的最优清洗时间**：在当前咖啡杯选择机洗并计算出清洗完成时间之后，递归地对剩余的咖啡杯进行相同的决策过程，直到所有咖啡杯都被考虑完毕。

   **自然挥发：**对于自然挥发的情况，由于这一过程是并行发生的，每个咖啡杯的挥发完成时间独立于其他咖啡杯。因此，对于每个咖啡杯，其挥发完成的时间点简单地等于它被使用完毕的时间点加上自然挥发所需的时间`air`。

   - **并行挥发的优势**：考虑到挥发是并行的，这意味着多个咖啡杯可以同时进行挥发处理，对于整体流程的时间消耗没有累积效应。

   在计算出每个咖啡杯采用清洗机清洗和自然挥发两种方式下的完成时间后，选择二者中时间最短的方案。这一选择旨在对于每个咖啡杯都找到最快变干净的方法。

```java
public class Coffee {
    public static class Machine{
        public int workTime;
        //可用的时间点（咖啡机空闲的时间点）
        public int freeTimePoint;

        public Machine(int workTime, int freeTimePoint) {
            this.workTime = workTime;
            this.freeTimePoint = freeTimePoint;
        }
    }
    public static class MyComparator implements Comparator<Machine>{

        @Override
        public int compare(Machine o1, Machine o2) {
            return (o1.freeTimePoint+o1.workTime)-(o2.freeTimePoint+o2.workTime);
        }
    }
    public static int minTime(int[] arr, int n, int a, int b){
        PriorityQueue<Machine> heap = new PriorityQueue<>(new MyComparator());
        for (int i = 0; i < arr.length; i++) {
            heap.add(new Machine(arr[i],0));
        }
        int[] drinkOutTimePoint=new int[n];
        for (int i = 0; i < n; i++) {
            Machine cur = heap.poll();
            cur.freeTimePoint+=cur.workTime;
            drinkOutTimePoint[i]=cur.freeTimePoint;
            heap.add(cur);
        }
        return process(drinkOutTimePoint,0,a,b,0);
    }
    //drinkOutTimePoint[index,.....]最优洗咖啡杯的时间
    public static int process(int[]drinkOutTimePoint,int index,int wash,int air,int MachineFreePoint){
        if(index==drinkOutTimePoint.length){
            return 0;
        }
        //洗
        int startCleanTimePoint=Math.max(drinkOutTimePoint[index], MachineFreePoint);
        int endCleanTimePoint1=Math.max(startCleanTimePoint+wash,process(drinkOutTimePoint,index+1,wash,air,startCleanTimePoint+wash));
        //不洗
        int endCleanTimePoint2=Math.max(drinkOutTimePoint[index]+air,process(drinkOutTimePoint,index+1,wash,air,MachineFreePoint));
        return Math.min(endCleanTimePoint1,endCleanTimePoint2);
    }
}
```

### （2）动态规划

**分析：**在构建二维动态规划表时，`index`轴代表处理到的咖啡杯索引，而`machineFreePoint`轴代表清洗机可用的时间点。`machineFreePoint`的具体范围需要根据实际情况来预估和设定，因为它直接影响到动态规划表的大小和边界处理，属于业务模型。

估计`machineFreePoint`的最大值可以基于所有人喝完咖啡的时间加上每个人使用清洗机清洗咖啡杯所需时间的最大可能总和。这个估计需要保守一些，以确保所有可能的清洗时间都能被覆盖，但同时也要注意不要过度估计，以避免造成空间浪费。

在填充动态规划表时，确实可能会遇到`machineFreePoint`超出预设最大值的情况。这要求我们在实现时加入适当的边界检查逻辑，以防止数组越界访问错误。当`startCleanTimePoint + wash`超出`maxMachineFreePoint`时，可以选择跳出当前循环或采取其他合理的处理策略，以保证程序的鲁棒性。

由于每个状态的最优解可能依赖于后续状态（即更后面的咖啡杯和更晚的清洗机空闲时间点）的解，动态规划表的填充顺序应该从`index`的最大值（即最后一个咖啡杯）开始，向`index`为0（即第一个咖啡杯）逐步递减。对于每个`index`，`machineFreePoint`的遍历则从0开始，逐步增加，直到`maxMachineFreePoint`。

以下优化只是想法，目前还并没有实现

考虑到每个`index`对应的`machineFreePoint`在业务逻辑上有其特定的范围限制，我们可以通过这种业务逻辑来进一步优化动态规划的实现。例如，在处理第一个咖啡杯时（即`index = 0`），清洗机初始空闲时间点`machineFreePoint`应当是0，因为此时尚未进行任何清洗活动。这意味着在开始时，不存在等待清洗机变为空闲的延迟。

随着`index`的增加，如果每次都选择使用清洗机进行清洗，那么对于任一特定的`index`，`machineFreePoint`的实际取值范围会因前面所有咖啡杯的清洗决策而累积。这意味着对于某个`index`，并不需要考虑所有理论上可能的`machineFreePoint`值，而只需要考虑到该`index`为止，选择清洗机清洗所能达到的最大`machineFreePoint`值，并且该`machineFreePoint`不一定是连续的。

```java
public static int minTimeByDp(int[] arr, int n, int wash, int air){
    PriorityQueue<Machine> heap = new PriorityQueue<>(new MyComparator());
    for (int i = 0; i < arr.length; i++) {
        heap.add(new Machine(arr[i],0));
    }
    int[] drinkOutTimePoint=new int[n];
    for (int i = 0; i < n; i++) {
        Machine cur = heap.poll();
        cur.freeTimePoint+=cur.workTime;
        drinkOutTimePoint[i]=cur.freeTimePoint;
        heap.add(cur);
    }
    int maxMachineFreePoint=0;
    for (int i = 0; i < n; i++) {
        maxMachineFreePoint=Math.max(maxMachineFreePoint,drinkOutTimePoint[i])+wash;
    }
    int[][] dp=new int[n+1][maxMachineFreePoint+1];
    for (int index = n-1; index >=0 ; index--) {
        for (int machineFreePoint = 0; machineFreePoint <=maxMachineFreePoint ; machineFreePoint++) {
            //洗
            int startCleanTimePoint=Math.max(drinkOutTimePoint[index], machineFreePoint);
            if(startCleanTimePoint+wash>maxMachineFreePoint){
                break;
            }
            int endCleanTimePoint1=Math.max(startCleanTimePoint+wash,dp[index+1][startCleanTimePoint+wash]);
            //不洗
            int endCleanTimePoint2=Math.max(drinkOutTimePoint[index]+air,dp[index+1][machineFreePoint]);
            dp[index][machineFreePoint]=Math.min(endCleanTimePoint1,endCleanTimePoint2);
        }
    }
    return dp[0][0];
}
```

# class21

## 1.旅行者问题

**题目：**考虑一个位于二维网格上的旅行者。旅行者的起点位于网格的左上角，目标是到达位于右下角的终点。为了到达终点，旅行者只能向右或向下移动，每次移动可以进入相邻的单元格。每个单元格内都有一个数字表示通过该单元格所需的距离消耗。旅行者的目标是选择一条路径，使得从起点到终点的总距离消耗最小。

具体来说，给定一个二维数组`matrix`，其中包含了表示每个单元格距离消耗的数字，任务是找到一条从左上角（`matrix[0][0]`）到右下角（`matrix[m-1][n-1]`）的路径，使得沿途经过的单元格的数字之和最小，并返回这个最小的累加和。

**分析：**简单二维表dp问题

```java
public class MinPathSum {
    public static int minPathSum(int[][]m){
        int row=m.length;
        int col=m[0].length;
        int[][]dp=new int[row][col];
        dp[0][0]=m[0][0];
        for (int i = 1; i < row; i++) {
            dp[i][0]=dp[i-1][0]+m[i][0];
        }
        for (int j = 1; j < col; j++) {
            dp[0][j]=dp[0][j-1]+m[0][j];
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+m[i][j];
            }
        }
        return dp[row-1][col-1];
    }
}
```

下面我们可以进行空间压缩。

在动态规划解决方案中，每个单元格的最小路径和实际上只依赖于其“上方”和“左侧”的单元格。因此，当我们逐行（或逐列）更新路径和时，对于任何给定的单元格，我们只需要知道直接上方单元格的最小路径和（即在一维`dp`数组中对应位置的值，此时还并为更新，代表上一行的该列），以及当前行中当前单元格左侧单元格的最小路径和（即在一维`dp`数组中当前位置左侧的值，此时已经更新，代表这一行该列的左侧）。

- **一维`dp`数组**：使用一个长度等于列数（或行数，如果是按列更新）的一维`dp`数组足以存储至当前行为止每个位置的最小路径和。这种方法显著降低了空间复杂度，从原来的`O(row * col)`减少到了`O(col)`。
- **更新规则**：
  - 对于`dp`数组的第一个元素（即每行的第一个单元格），它只依赖于其上方的单元格，因此我们直接在原有基础上累加当前单元格的值。
  - 对于`dp`数组中的其他元素（即当前行的其他单元格），每个元素的值由其上方（`dp[j]`在更新前）和左侧（`dp[j-1]`在更新后）的单元格的最小路径和加上当前单元格的值决定。

```java
public static int minPathSum1(int[][]m){
        int row=m.length;
        int col=m[0].length;
        int[]dp=new int[col];
        dp[0]=m[0][0];
        for (int j = 1; j < col; j++) {
            dp[j]=dp[j-1]+m[0][j];
        }
        for (int i = 1; i < row; i++) {
            dp[0]=dp[0]+m[i][0];
            for (int j = 1; j < col; j++) {
                dp[j]=Math.min(dp[j],dp[j-1])+m[i][j];
            }
        }
        return dp[col-1];
    }
```

在某些动态规划问题中，当前状态的值不仅取决于其直接上方和左侧的状态，还可能取决于左上方的状态。这种依赖关系通常见于需要比较或合并两个序列的问题中，比如计算两个序列的最长公共子序列（LCS）或编辑距离时。

为了在空间压缩后的一维`dp`数组更新过程中保留这种斜对角依赖，可以使用一个变量`prev`来保存进入当前状态之前左上方状态的值。在每次更新`dp[j]`（当前状态）之前，`prev`保存的是`dp[j-1]`（左侧状态）的旧值，它在更新过程中将被用作左上方状态的值。

让我们分别修饰这三个题目的语言，并进行命名，然后解释它们之间的区别。

## 2.不同货币组合问题

> 以下这三种问题反映了动态规划和组合计数问题在处理“唯一性”、“数量无限制”和“区分度”这三个维度时的不同策略和方法。

**题目**：给定一个由正整数组成的数组`arr`，表示不同的货币面额，以及一个正整数`aim`代表目标金额。尽管数组中可能包含相同的值，但每个值都被视为一张独立的货币。求有多少种方法可以使用这些货币组合成目标金额`aim`。

**示例**：如果`arr = [1,1,1]`且`aim = 2`，那么可以通过以下三种组合方式达到目标金额：第0张和第1张、第1张和第2张、第0张和第2张。因此，总共有3种不同的组合方法来实现目标金额，所以答案是3。

**分析：** **不同货币组合问题**关注的是每张货币都是唯一的，即使面额相同。这要求我们考虑组合中货币的具体身份。

```java
public class CoinsWayEveryPaperDifferent {
    public static int coinsWays(int[]arr,int aim){
        return process(arr,0,aim);
    }
    public static int process(int[]arr,int index,int rest){
        if(index==arr.length){
            return rest==0?1:0;
        }
        int p=process(arr,index+1,rest);
        if(arr[index]<=rest){
            p+=process(arr,index+1,rest-arr[index]);
        }
        return p;
    }
    public static int coinsWaysByDp(int[]arr,int aim){
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        dp[N][0] = 1;
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest] = dp[index + 1][rest] + (rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : 0);
            }
        }
        return dp[0][aim];
    }
}

```

## 3.无限货币面值组合问题
**题目**：给定一个由正整数组成的数组`arr`，表示不同的货币面额，以及一个正整数`aim`代表目标金额。数组中的每个值代表一种货币面额，假设每种面额的货币数量是无限的。求有多少种方法可以使用这些货币面额组合成目标金额`aim`。

**示例**：如果`arr = [1,2]`且`aim = 4`，那么可以通过以下三种组合方式达到目标金额：1+1+1+1、1+1+2、2+2。因此，总共有3种不同的组合方法来实现目标金额，所以答案是3。

**分析：** **无限货币面值组合问题**假设每种面额的货币数量是无限的。这意味着，组合方法只依赖于面额种类，而不是具体的货币数量。

```java
package com.lxy.class21;

public class CoinsWayNoLimit {
    public static int coinsWays(int[]arr,int aim){
        return process(arr,0,aim);
    }
    public static int process(int[]arr,int index,int rest){
        if(index==arr.length){
            return rest==0?1:0;
        }
        int ways=0;
        for (int count = 0; count*arr[index]<=rest; count++) {
            ways+=process(arr,index+1,rest-count*arr[index]);
        }
        return ways;
    }
    public static int coinsWaysByDp(int[]arr,int aim){
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        dp[N][0]=1;
        for (int index = N-1; index >=0 ; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                for (int count = 0; count*arr[index]<=rest; count++) {
                    dp[index][rest]+=dp[index+1][rest-count*arr[index]];
                }
            }
        }
        return dp[0][aim];
    }
}
```

动态规划的严格表结构和记忆化搜索都是解决重复子问题的有效策略。记忆化搜索通常以递归的形式实现，严格表结构则倾向于使用迭代方法和表格来存储子问题的解。虽然它们在实现方式上有所不同，但都旨在通过存储已解决子问题的结果来减少计算量，从而提高算法的效率，在没有枚举行为的情况下，这两种方法在处理问题的效率是相同的。

在实现动态规划时，有时可能引入不必要的枚举和计算。通过对严格表结构的深入理解，我们可以发现更优的状态转移关系，从而减少这种枚举的需要。具体到本题中，通过仔细观察可以发现，每个单元格的值不仅与其直接下方的单元格值有关，还与其左边的单元格值有直接关联。

在题目中的货币组合问题中，我们观察到，当考虑到达特定金额（`rest`）时，当前考虑的单元格可以通过查看左边的单元格加上下边的单元格来更新。这意味着，每个`dp[index][rest]`的值实际上可以通过`dp[index+1][rest]`（即下方单元格）和`dp[index][rest-arr[index]]`（即左方单元格）来计算。

```java
public static int coinsWaysByDp1(int[]arr,int aim){
    int N = arr.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0]=1;
    for (int index = N-1; index >=0 ; index--) {
        dp[index][0]=dp[index+1][0];
        for (int rest = 1; rest <= aim; rest++) {
            dp[index][rest]=dp[index+1][rest]+rest-arr[index]>=0?dp[index][rest-arr[index]]:0;
        }
    }
    return dp[0][aim];
}
```

## 4.有限货币面值组合问题

**题目**：给定一个由正整数组成的数组`arr`，表示不同的货币面额，以及一个正整数`aim`代表目标金额。数组中每种面额的货币被视为相同的，不区分具体是哪一张。求有多少种方法可以使用这些货币面额组合成目标金额`aim`。

**示例**：如果`arr = [1,2,1,1,2,1,2]`且`aim = 4`，那么可以通过以下三种组合方式达到目标金额：1+1+1+1、1+1+2、2+2。尽管货币数组中含有多张相同面额的货币，但是组合时这些相同面额的货币被视为没有区别的。因此，总共有3种不同的组合方法来实现目标金额，所以答案是3。

**分析：** **有限货币面值组合问题**与第一个问题相似，考虑的是有限数量的货币，但是假设相同面额的货币在组合时没有区别。

关键解决策略——将货币的数量作为参数传入递归函数并加以限制，通过将每种货币的使用次数限制在其可用数量内，这种方法确保了不会使用超过所给数量的货币来组合目标金额。

```java
public class CoinsWaySameValueSamePaper {
    public static class Info {
        public int[] coins;
        public int[] counts;

        public Info(int[] coins, int[] counts) {
            this.coins = coins;
            this.counts = counts;
        }
    }

    public static Info getInfo(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int value : arr) {
            if (!map.containsKey(value)) {
                map.put(value, 1);
            } else {
                map.put(value, map.get(value) + 1);
            }
        }
        int N = map.size();
        int[] coins = new int[N];
        int[] counts = new int[N];
        int index = 0;
        for (Entry<Integer, Integer> entry : map.entrySet()) {
            coins[index] = entry.getKey();
            counts[index++] = entry.getValue();
        }
        return new Info(coins, counts);
    }

    public static int coinsWays(int[]arr,int aim){
        if (arr == null || arr.length == 0 || aim < 0) {
            return 0;
        }
        Info info = getInfo(arr);
        return process(info.coins,info.counts,0,aim);
    }
    public static int process(int[]coins,int[]counts,int index,int rest){
        if(index==coins.length){
            return rest==0?1:0;
        }
        int ways=0;
        for (int count = 0; count <= counts[index]&&count*coins[index]<=rest; count++) {
            ways+=process(coins,counts,index+1, rest-count*coins[index]);
        }
        return ways;
    }
}
```

同样，我们观察发现，这也可以通过严格的表结构进行优化，但是与之不同的点是，这次由于面值相同的货币数量有限制，那么则一个表格的左边的格子实际上比他左边多扩了一个格子，但右边又少一个格子，不过我们还是可以通过计算去确定这个行为即， dp index][rest]=dp index+1][rest]+dp index][rest-coins[index]]-dp index+1][rest-(counts[index]+1)*coins[index]]

由于每种货币的使用数量受到限制，所以相比于无限制的情况，我们在计算时需要更精细地处理每个`dp`格子的依赖关系。这种依赖关系不仅体现在直接使用或不使用当前货币上，还体现在通过数量限制导致的组合方法数的增减上。

对于每种货币，我们不仅需要考虑不使用它的情况（即`dp[index+1][rest]`），还要考虑使用它的情况（`dp[index][rest-coins[index]]`）。不同之处在于，由于每种货币的数量是有限的，所以我们还需要从总方法数中减去超出该货币数量限制的组合方法数（即`dp[index+1][rest-(counts[index]+1)*coins[index]]`）。

因此，动态规划表的更新公式为：
$dp[index][rest] = dp[index+1][rest] + dp[index][rest-coins[index]] - dp[index+1][rest-(counts[index]+1)*coins[index]] $

```java
public static int coinsWays1(int[]arr,int aim){
        if (arr == null || arr.length == 0 || aim < 0) {
            return 0;
        }
        Info info = getInfo(arr);
        int[]coins=info.coins;
        int[] counts = info.counts;
        int N = counts.length;
        int[][] dp = new int[N + 1][aim + 1];
        dp[N][0]=1;
        for (int index = N-1; index >=0 ; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest]=dp[index+1][rest];
                if(rest-coins[index]>=0){
                    dp[index][rest]+=dp[index][rest-coins[index]];
                }
                if(rest-(counts[index]+1)*coins[index]>=0){
                    dp[index][rest]-=dp[index+1][rest-(counts[index]+1)*coins[index]];
                }
            }
        }
        return dp[0][aim];
    }
```





## 5.醉汉Bob存活概率

**题目：**在一个`N`行`M`列的区域内，醉汉Bob最初位于坐标(`row`, `col`)。Bob计划随机行走`k`步，每一步他都有相同的概率向上、下、左、右四个方向移动一个单位。如果在任何时刻Bob走出了这个`N*M`的区域，他将会立即“死亡”。求在Bob完成`k`步行走之后，他仍然留在`N*M`区域内的概率是多少。

**分析：**在分析“醉汉Bob存活概率”的问题时，我们的目标是计算在走完指定的`k`步之后，Bob仍然留在`N*M`区域内的概率。这个概率可以通过将Bob存活的路径数除以Bob所有可能的行走路径数（即`4^k`，因为每步都有四种可能的行走方向）来计算得出。注意一点，即使Bob在过程中出界了，按照题目的要求，我们仍然视为他继续行走直到完成所有`k`步，以确保统计的路径数包含了所有可能的情况。

```java
public class BobDie {
    public static double livePossibility(int row, int col, int k, int N, int M) {
        return process(row,col,k,N,M);
    }
    //存活的总数
    public static int process(int row,int col,int rest,int N,int M){
        if(row>=N||row<0||col>=M||col<0){
            return 0;
        }
        if (rest == 0) {
			return 1;
		}
        int ways=0;
        ways+=process(row+1,col,rest-1,N,M );
        ways+=process(row,col+1,rest-1,N,M );
        ways+=process(row-1,col,rest-1,N,M );
        ways+=process(row,col-1,rest-1,N,M );
        return ways;
    }
}
```

Bob的当前位置（由两个坐标`row`和`col`确定）以及他还剩下的步数`k`。为了有效解决这个问题，可以采用动态规划（DP）的方法构建一个三维DP表来进行求解。

构建一个三维DP表，其中`dp[row][col][k]`代表从位置`(row, col)`出发，剩余`k`步时，Bob存活（即留在`N*M`区域内）的概率。这种表结构允许我们细致地追踪每一步的所有可能走法，并计算出对应的存活概率。

```java
 public static int pick(int[][][] dp, int N, int M, int r, int c, int rest) {
        if (r < 0 || r == N || c < 0 || c == M) {
            return 0;
        }
        return dp[rest][r][c];
    }
public static double livePossibilityByDp(int r, int c, int k, int N, int M) {
    int[][][]dp=new int[k+1][N][M];
    for (int row = 0; row < N; row++) {
        for (int col = 0; col < M; col++) {
            dp[0][row][col]=1;
        }
    }
    for (int rest = 1; rest <=k; rest++) {
        for (int row = 0; row < N; row++) {
            for (int col = 0; col < M; col++) {
                dp[rest][row][col]+=pick(dp,N,M,row-1,col,rest-1);
                dp[rest][row][col]+=pick(dp,N,M,row,col-1,rest-1);
                dp[rest][row][col]+=pick(dp,N,M,row+1,col,rest-1);
                dp[rest][row][col]+=pick(dp,N,M,row,col+1,rest-1);
            }
        }
    }
    return dp[k][r][c]/Math.pow(4,k);
}
```

# class22

## 1.英雄砍怪兽概率计算

**题目：**在一个幻想场景中，一位英雄面对着一只怪兽。怪兽初始有`N`滴血。在接下来的战斗中，英雄将对怪兽进行`K`次打击，每一次打击将使怪兽流失`0`到`M`滴血，其中流失的具体血量是等概率随机的。现在的问题是，计算英雄在`K`次打击后刚好将怪兽砍死（使其血量达到或降至0）的概率。

**分析：**当我们考虑英雄对怪兽的攻击时，我们面对的是一个有`0`到`M`滴血量流失的等概率事件。对于每一次攻击，我们需要考虑所有这些可能性，并累加起来，以计算出砍死怪兽的总方法数。

注意以下几个关键点：

- **怪兽血量降至零或以下**：当怪兽的血量降至零或以下时，我们不再需要详细考虑接下来的每一次攻击如何减少血量，因为怪兽已经被视为“死亡”。在这种情况下，针对剩余的攻击次数`rest`，可以直接采用公式`(M+1)^rest`来快速计算出所有可能的攻击组合数。这一计算反映了在剩余的`rest`次攻击中，每次攻击都有`M+1`种可能的血量流失结果。
- **怪兽血量正好为零的处理**：即便怪兽的血量已经准确降至零，我们同样可以采取递归的方法继续处理后续的攻击，主要是确保算法逻辑的一致性和完整性。
- **处理逻辑的层级选择**：将决定是否继续详细计算或直接应用快速计算公式的逻辑放在递归的上层处理，有助于保持递归逻辑的清晰和算法的整体一致性。此外，这种策略为将来可能的动态规划优化提供了灵活性和便利性。

```java
public class KillMonster {
    public static double killMonsterPossibility(int N,int K,int M){
        if (N < 1 || M < 1 || K < 1) {
            return 0;
        }
        return (double) process(N,K,M)/Math.pow(M+1,K);
    }
    public static long process(int restHp,int rest,int M){
        if(rest==0){
            return restHp==0?1:0;
        }
        long ways=0;
        for (int i = 0; i <= M; i++) {
            if(restHp-i>=0){
                ways+=process(restHp-i,rest-1,M);
            }else{
                ways+= (long) Math.pow(M+1,rest-1);
            }
        }
        return ways;
    }
}
```

由于上面算法的一致性，动态规划的改写也同样简单，下面是优化后的动态规划。

在构建动态规划解法的过程中，一个核心的发现是当前状态（或称为“表格”）的计算不仅仅依赖于其前一个状态，而是一个更综合的依赖关系。具体而言，`dp[rest][hp]`，即在剩余`rest`次攻击下，怪兽剩余`hp`血量时，成功砍死怪兽的方法数，可以通过以下方式计算得出：

- **累加左侧状态的值**：`dp[rest][hp-1]`提供了在相同攻击次数但血量少一点的所有成功情况。
- **加上上侧状态的值**：`dp[rest-1][hp]`反映了在多一次攻击机会时，针对同一血量所能带来的额外成功方法数。
- **减去限制条件下过多计算的方法数**：`dp[rest-1][hp-M-1]`是必须被减去的部分，它表示在给定攻击次数下，由于M的限制而导致的不应计入的成功次数。

为了简化实现，当怪兽血量为零的状态直接赋予`(long)Math.pow(M+1, rest)`，这一步骤有效减少了对`hp-1`的特殊判断，因为`hp-1<0`的情况唯一发生在`hp==0`时。基于对怪兽血量情况的深刻理解，我们发现`dp[rest][1]`也能采取类似的简化处理方法，同时对于`hp-M-1`的处理也不必纠结于`hp-M-1==0`的具体情况。

```java
public static double killMonsterPossibilityByDp(int N,int K,int M){
        if (N < 1 || M < 1 || K < 1) {
            return 0;
        }
        long[][]dp=new long[K+1][N+1];
        dp[0][0]=1;
        for (int rest = 1; rest <=K ; rest++) {
            dp[rest][0]=(long)Math.pow(M+1, rest);
            for (int hp = 1; hp <=N ; hp++) {
                dp[rest][hp]+=dp[rest-1][hp]+dp[rest][hp-1];
                if(hp-M-1>=0){
                    dp[rest][hp]-=dp[rest-1][hp-M-1];
                }else{
                    dp[rest][hp]-=(long)Math.pow(M+1, rest-1);
                }
            }
        }
        return (double)dp[K][N]/Math.pow(M+1,K);
    }
```

## 2.最少货币组合

**题目：**给定一个代表不同面额的正整数数组`arr`，其中没有重复的值，以及一个目标金额`aim`。假设每种面额的货币数量是无限的，求组合出目标金额`aim`所需的最少货币数量。

**分析：**本问题的核心不再是寻找所有可能的货币组合方法，而是确定组合出特定金额`aim`时所需的最小硬币数量。这一目标导致了算法设计的关键转变：

- **基础情况的重新定义**：当遍历完所有硬币面额（即`index == arr.length`）时，如果剩余金额`rest`正好为0，意味着当前组合方案成功。与之前方法数计数的情况不同，此时我们的目标是最小化使用的硬币数量，因此在`rest == 0`的情况下返回0，表示没有更多硬币需要使用，而不是表示方法数的增加。
- **无效方法的处理**：在递归实现中，我们通过返回`Integer.MAX_VALUE`来标记一个方案的无效性，区别于返回0，后者仅表示成功的方案中不需要任何硬币。在计算过程中，对于每个递归调用返回的值，我们需仔细判断其有效性。如果一个递归调用返回了`Integer.MAX_VALUE`，即表示该路径无法成功组合出目标金额，应将其视为无效并在后续计算中排除。
- **递归逻辑的精细处理**：在确定下一步递归调用的返回值时，只有当这个值不为`Integer.MAX_VALUE`时才考虑其作为有效方案进行后续的最小值比较。这一判断避免了将无效方案误计入最小硬币数量的比较中，确保了算法结果的准确性。

```JAVA
public class MinCoinsNoLimit {
    public static int minCoins(int[]arr,int aim){
        int ans=process(arr,0,aim);
        return ans==Integer.MAX_VALUE?-1:ans;
    }
    public static int process(int[]arr,int index,int rest){
        if(index==arr.length){
                return rest==0?0:Integer.MAX_VALUE;
        }
        int min=Integer.MAX_VALUE;
        for (int count = 0; count*arr[index] <=rest ; count++) {
            int next=process(arr,index+1,rest-arr[index]*count);
            if(next!=Integer.MAX_VALUE){
                min=Math.min(min,next+count);
            }
        }
        return min;
    }
}
```

对于动态规划表中的任一单元格`dp[index][rest]`，它表示使用从`index`索引开始的硬币面额组成`rest`金额所需的最少硬币数量。通过观察，我们发现该单元格的最优解不仅取决于其直接下方的单元格（即`dp[index+1][rest]`，代表不使用当前硬币面额时的最少硬币数量），还与其左侧单元格（即`dp[index][rest-arr[index]]`，代表使用一枚当前硬币后剩余金额所需的最少硬币数量）紧密相关。

基于上述观察，我们可以得出状态转移方程：
$dp[index][rest] = \min(dp[index+1][rest], dp[index][rest-arr[index]] + 1) $

当我们考虑使用当前硬币（即硬币面额为`arr[index]`）对`dp[index][rest]`的影响时，我们实际上是在尝试解决一个更小的问题：如果我们已经决定使用一枚当前硬币，那么剩余的问题变成了使用相同的硬币集合组成新的金额`rest-arr[index]`所需的最少硬币数量。这里的`+1`操作正是因为我们决定使用了一枚硬币，因此，对应地，需要在原有的最少硬币数量基础上加一。（其实并没有想这么多，观察就知道了）

在应用上述状态转移方程时，我们必须仔细处理无效值的情况。因为在某些情况下，`dp[index][rest-arr[index]]`可能为`Integer.MAX_VALUE`，表示无法使用当前硬币面额组合出`rest-arr[index]`金额。在这种情况下，直接应用方程会导致错误地将无效解视为有效解。因此，在实际计算时，必须先判断`dp[index][rest-arr[index]]`是否为无效值，以确保只有在有效解的基础上才进行`+1`操作和最小值的选择。

当然，如果限制货币的个数，这个题目会更加困难，因为与求组合方式不同，可以减去多余的部分，但此时是最小值，没有办法加减，后续会通过滑动窗口解决这一问题。

```JAVA
 public static int minCoinsByDp(int[]arr,int aim){
        if (aim == 0) {
            return 0;
        }
        int N = arr.length;
        int[][]dp=new int[N+1][aim+1];
        dp[N][0] = 0;
        for (int rest = 1; rest <=aim ; rest++) {
            dp[N][rest]=Integer.MAX_VALUE;
        }
        for (int index = N-1; index >=0 ; index--) {
            for (int rest = 0; rest <=aim ; rest++) {
                dp[index][rest]=dp[index+1][rest];
                if(rest-arr[index]>=0&& dp[index][rest - arr[index]] != Integer.MAX_VALUE){
                    dp[index][rest]=Math.min(dp[index][rest],dp[index][rest- arr[index]]+1);
                }
            }
        }
        return dp[0][aim]==Integer.MAX_VALUE?-1:dp[0][aim];
    }
```

该题每种货币使用数量没有限制，但当我们在考虑限制每种货币使用数量的情况时，最少硬币组合问题的复杂度显著增加。这种限制带来的挑战在于，与寻找组合方法数的问题不同，我们不能简单地通过增加或减少特定组合中的货币数量来调整结果。在寻求最少使用货币数量的目标下，简单的加减操作不再适用，因为我们的目标是确定组合中硬币的最小可能数量，而不仅仅是找到所有可能的组合。

为了应对这一挑战，后续我们将探索使用滑动窗口技术来解决问题。滑动窗口技术能够在保持算法效率的同时，适当地考虑每种货币数量的限制，为我们提供了一种在限制条件下寻找最少硬币数量解决方案的有效途径。通过精心设计的滑动窗口，我们可以在不断变化的限制条件下，灵活调整并优化我们的计算过程，从而有效地解决了这一较为困难的问题。

## 3.数字裂开方法数

**题目：**给定一个正整数`n`，寻找所有可能的裂开方法数，使得每个裂开的序列满足后续的数不小于前面的数。例如，数字`4`可以裂开为`1+1+1+1`、`1+1+2`、`1+3`、`2+2`、`4`，共有5种裂开方法。

**分析：**我们面对的问题是找出一个正整数`n`的所有有效分解方法，其中每个分解后的序列都必须遵循一个规则：序列中的任意后续数字不得小于它前面的数字。为了实现这一目标，关键步骤在于维持对前一个分解数字的追踪，以及对剩余部分进行精确管理。

当我们没有剩余的数字需要分解，即`rest == 0`时，这表明我们找到了一种有效的分解方法。在这种情况下，我们将这种特定的分解路径计为成功一次，因而返回1以表示成功找到一种方法。

通过尝试每一种可能的分解数`pre`至`rest`的范围内的数字作为序列的下一个数字，我们逐步构建符合条件的序列。对于每一个尝试，我们递归地调用处理函数，进一步分解剩余的数目，直至满足基本情况。

每次递归调用的返回值代表从当前状态出发，满足条件的分解方法数。通过累加这些返回值，我们可以得到总的方法数，这就是从初始状态到当前状态下，满足分解规则的所有可能方法的总和。

```java
public class SplitNumber {
    public static int splitNumberWays(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return process(1, n);
    }
    private static int process(int pre, int rest) {
        if(rest==0){
            return 1;
        }
        int ways=0;
        for (int i = pre; i <=rest ; i++) {
            ways+=process(i,rest-i);
        }
        return ways;
    }
}
```

- **DP数组定义**：`dp[pre][rest]`代表在当前可分解的最小数为`pre`，需要分解的剩余数为`rest`时的分解方法数。
- **基础情况填充**：对于所有`pre`，当`pre`等于`rest`或`rest`为0时，分解方法数为1。这是因为，如果`pre`等于`rest`，则只有一种分解方法，即`rest`本身；如果`rest`为0，则只有一种分解方式，即不进行任何分解。
- **DP表填充逻辑**：
  - 逆序遍历`pre`从`n-1`到0，正序遍历`rest`从`pre+1`到`n`。
  - `dp[pre][rest]`的值由两部分组成：不包含当前`pre`作为分解部分的方法数`dp[pre+1][rest]`和包含至少一个`pre`作为分解部分的方法数`dp[pre][rest-pre]`。
- **返回结果**：`dp[1][n]`代表以1作为可分解的最小数，需要分解的数为`n`时的分解方法数，也就是问题的解。

```java
public static int splitNumberWaysByDp(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    int[][]dp=new int[n+1][n+1];
    for (int pre = 0; pre < n+1; pre++) {
        dp[pre][pre]=1;
        dp[pre][0]=1;
    }
    for (int pre = n-1; pre >=0 ; pre--) {
        for (int rest = pre+1; rest <n+1 ; rest++) {
            dp[pre][rest]=dp[pre+1][rest]+dp[pre][rest-pre];
        }
    }
    return dp[1][n];
}
```

# class23

## 1.公平分割数组

**题目：**给定一个由正整数组成的数组`arr`，目标是将`arr`分割成两个集合，使得这两个集合的累加和尽可能接近。求在最接近的情况下，较小集合的累加和是多少。

**分析：**目标是在给定的正整数数组`arr`中，找到两个集合，使它们的累加和尽可能接近。要精确地寻求解决方案，我们可以将原问题转化为寻找一个不超过整个数组累加和一半的最大累加和。

```java
package com.lxy.class23;

public class SplitSumClosed {
    public static int splitSumClosed(int[]arr){
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int sum=0;
        for(int e:arr){
            sum+=e;
        }
        return process(arr,0,sum/2);
    }
    public static int process(int[]arr,int index,int rest){
        if(index==arr.length){
            return 0;
        }
        int p1=process(arr,index+1,rest);
        int p2=0;
        if(rest-arr[index]>=0){
            p2=process(arr,index+1,rest-arr[index])+arr[index];
        }
        return Math.max(p1,p2);
    }
    public static int splitSumClosedByDp(int[]arr){
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int sum=0;
        for(int e:arr){
            sum+=e;
        }
        int N = arr.length;
        int[][]dp=new int[N+1][sum/2+1];
        for (int index = N-1; index >=0 ; index--) {
            for (int rest = 0; rest <=sum/2; rest++) {
                int p1=dp[index+1][rest];
                int p2=0;
                if(rest-arr[index]>=0){
                    p2=dp[index+1][rest-arr[index]]+arr[index];
                }
                dp[index][rest]=Math.max(p1,p2);
            }
        }
        return dp[0][sum/2];
    }
}
```

## 2.限制数量公平分割数组

**题目：**对于一个给定的正整数数组`arr`，请将其分割成两个集合。如果`arr`的长度为偶数，那么这两个集合中包含的元素数量应相同；如果`arr`的长度为奇数，那么这两个集合中包含的元素数量之差必须为一。任务是使这两个集合的累加和尽可能接近，并返回在最接近的情况下，较小集合的累加和。

**分析：**在面对增加了数量限制的问题时，我们的任务是将给定的正整数数组`arr`分成两个集合，要求这两个集合的累加和尽可能接近，同时考虑到数组长度可能是奇数或偶数，集合中元素的数量也受到相应的限制。

- **偶数长度数组**：对于长度为偶数的数组，问题可以转化为从数组中选取一半数量的元素，这些元素的累加和尽量接近整个数组累加和的一半的最大值。这一转化考虑到了集合中元素数量的限制，即选取的元素数量恰好为数组长度的一半。
- **奇数长度数组**：对于长度为奇数的数组，情况稍微复杂，因为无法将数组平均分成两个相同数量的集合。在这种情况下，我们需要寻找两种可能的分割方案：一种方案中一个集合包含`n/2`个元素（向下取整），另一个包含`n/2 + 1`个元素；另一种方案则反之。我们的目标是在这两种方案中找到一个使两个集合的累加和最接近的方案，并从中选取较大集合的累加和作为最终结果。

```java
public class SplitSumClosedSizeHalf {
    public static int splitSumClosedSizeHalf(int[] arr){
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int sum=0;
        for(int e:arr){
            sum+=e;
        }
        if ((arr.length & 1) == 0) {
            return process(arr, 0, arr.length / 2, sum / 2);
        } else {
            return Math.max(process(arr, 0, arr.length / 2, sum / 2), process(arr, 0, arr.length / 2 + 1, sum / 2));
        }
    }
    public static int process(int[]arr,int index,int picks,int rest){
        if(index== arr.length){
            return picks==0?0:-1;
        }
        int p1=process(arr,index+1,picks,rest);
        int p2=-1;
        int next=-1;
        if(rest-arr[index]>=0){
            next=process(arr,index+1,picks-1,rest-arr[index]);
        }
        if (next!=-1){
            p2=arr[index]+next;
        }
        return Math.max(p1,p2);
    }
}
```

在动态规划数组`dp`的初始化过程中，每个单元格最初被设置为`-1`，这表示在给定条件下的累加和是无效的或尚未计算。这种初始化方式有助于我们区分那些已经被计算并确认为有效的累加和与那些不可能实现或还未被计算的累加和。

当处理每个状态时，我们首先检查当前状态是否已经被计算（即检查其是否不等于初始值`-1`）。这种做法确保了每次递归调用或状态转移都基于有效的、可行的解。特别地，对于累加和为`rest`的集合，如果当前考虑的元素`arr[i]`加入后可以形成一个有效的累加和，则更新当前状态。这种方法使得我们能够有效过滤出不可能的情况，只关注那些有望达到目标累加和的方案。

递归的基条件`if(index == arr.length)`时返回的结果是基于`picks`是否为0来决定的，隐式地遵循了`(picks - 1 >= 0)`的规则。因此在动态规划中要显示的进行判断。

```java
public static int splitSumClosedSizeHalfByDp(int[] arr){
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int sum = 0;
        for (int num : arr) {
            sum += num;
        }
        sum /= 2;
        int N = arr.length;
        int M = (N + 1) / 2;
        int[][][] dp = new int[N + 1][M + 1][sum + 1];
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= M; j++) {
                for (int k = 0; k <= sum; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        for (int rest = 0; rest <= sum; rest++) {
            dp[N][0][rest] = 0;
        }
        for (int i = N - 1; i >= 0; i--) {
            for (int picks = 0; picks <= M; picks++) {
                for (int rest = 0; rest <= sum; rest++) {
                    int p1 = dp[i + 1][picks][rest];
                    // 就是要使用arr[i]这个数
                    int p2 = -1;
                    int next = -1;
                    if (picks - 1 >= 0 && arr[i] <= rest) {
                        next = dp[i + 1][picks - 1][rest - arr[i]];
                    }
                    if (next != -1) {
                        p2 = arr[i] + next;
                    }
                    dp[i][picks][rest] = Math.max(p1, p2);
                }
            }
        }
        if ((arr.length & 1) == 0) {
            return dp[0][arr.length / 2][sum];
        } else {
            return Math.max(dp[0][arr.length / 2][sum], dp[0][(arr.length / 2) + 1][sum]);
        }
    }
```

## 3.N皇后问题的解法数量

**题目：**N皇后问题是一个经典的棋盘布局问题，要求在一个`N x N`的棋盘上摆放`N`个皇后，使得任何两个皇后都不处于同一行、同一列，也不在同一条对角线上。给定一个整数`n`，返回能够满足条件的N皇后摆放方案的总数。例如，当`n=1`时，只有一种摆法；而`n=2`或`n=3`时，不存在有效的摆放方案，返回0；对于`n=8`，共有92种有效摆放方案。

**分析：**为了解决N皇后问题，通常需要使用一个N×N的棋盘来记录每个皇后的位置。然而，通过一种巧妙的优化，我们可以仅使用一个长度为N的数组`record`来达成同样的目的。在这个数组中，每个元素的索引代表棋盘的行数，元素的值则代表相应行皇后的列位置。例如，`record[i] = j`表示第i行的皇后位于第j列。

`process`函数核心逻辑是通过递归尝试在当前行`index`的每一列上放置皇后。如果`index`等于`n`，则说明所有皇后均已合法摆放，此时应返回1表示找到了一个有效解。对于每个列位置，我们利用`isValid`函数来检查放置皇后是否会导致冲突。如果当前列有效，皇后位置被设定，然后继续递归处理下一行。通过这种方式，算法不断累加找到的合法方案。

`isValid`函数则是用来确保当前选择的列位置不会与之前已放置的皇后冲突。它通过检查每一对皇后是否处于同一列或者同一对角线上来实现这一点。对角线冲突的判定依据是行索引差与列索引差的绝对值是否相等。

```java
public class NQueens {
    public static int nQueens(int n) {
        int[] record = new int[n];
        return process(record, 0, n);
    }

    public static int process(int[] record, int index, int n) {
        if (n == index) {
            return 1;
        }
        int ways = 0;
        for (int col = 0; col < n; col++) {
            if (isValid(record, index, col)) {
                record[index] = col;
                ways += process(record, index + 1, n );
            }
        }
        return ways;
    }

    private static boolean isValid(int[] record, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (record[i] == col || Math.abs(record[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;
    }
}
```

利用整型变量的比特位来标记皇后的位置，从而支持最多32个皇后的计算（整数有32位）。这种方法极大地提高了空间和时间效率。

在`nQueens1`函数中，首先检查传入的皇后数量`n`是否在合法范围内（1至32）。接着，它计算一个初始的标志变量`flag`，这个变量的比特位中的每个1都代表对应位置上可以放置皇后。如果`n`等于32，使用`-1`（即所有位都是1）作为`flag`；否则，通过`(1<<n)-1`生成一个低`n`位全为1的二进制数。

`process1`函数是递归的核心，它接收当前的列限制`colLimit`、左斜线限制`leftLimit`和右斜线限制`rightLimit`。这三个参数使用比特位来标记不能放置皇后的列和对角线。如果`colLimit`与`flag`相等，说明所有行都已成功放置了皇后，这时函数返回1表示找到了一种解决方案。

在递归过程中，`pos`变量计算当前能放置皇后的所有位置，即那些既不在`colLimit`、`leftLimit`、`rightLimit`中标记的位置。通过位运算`flag & ~(colLimit | leftLimit | rightLimit)`得到`pos`。

接着，循环检查`pos`中的每个1（即每一个可能的位置），通过`pos & (~pos + 1)`取出`pos`中最低的1（表示下一个可放置皇后的位置），然后从`pos`中移除这个位置。对于每个有效的位置，递归调用`process1`，同时更新列限制和两个对角线限制。左对角线限制通过左移一位来更新，右对角线限制通过逻辑右移一位来更新，确保每递归到下一行，对角线的限制都相应地移动一位。

```java
 public static int nQueens1(int n) {
        if (n < 1 || n > 32) {
            return 0;
        }
        int flag=n==32?-1:(1<<n)-1;
        return process1(flag, 0,0 ,0);
    }
    public static int process1(int flag,int colLimit,int leftLimit,int rightLimit){
        if(flag==colLimit){
            return 1;
        }
        int pos=flag&~(colLimit|leftLimit|rightLimit);
        int ways=0;
        while(pos!=0){
            int num=pos&(~pos+1);
            pos=pos-num;
            ways+=process1(flag,colLimit|num,(leftLimit|num)<<1,(rightLimit|num)>>>1);
        }
        return ways;
    }
```

## 4.动态递归总结

### 1. 设计暴力递归：
首先，需要构建一个基于递归的暴力解法。这不仅是为了验证解决方案的可行性，还是因为递归方法易于理解和实现。在设计递归时，应考虑以下重要原则和四种常见的尝试模型：

**重要原则**：

- **简化可变参数**：每个可变参数尽量简单，最好不超过整型。
- **允许的复杂度突破**：如果必须使用更复杂的类型，如一维数组，确保它是唯一的可变参数。
- **记忆化**：对于复杂参数类型，实现记忆化搜索以优化性能。
- **参数数量**：尽量减少递归函数的参数数量。

**尝试模型**：

- **从左向右的尝试**：逐步解决问题，每步决策依赖于前一步。
- **范围尝试**：确定问题的起点和终点，通常需要斜向填表。
- **多样本位置全对应**：针对多个样本进行决策，通常关注最后的位置或状态。
- **寻找业务限制**：根据实际问题的业务规则设计状态。

### 2. 分析是否存在重复解：
通过绘制递归调用的树状图，分析是否有重复的解调用。这通常很直观，可以通过观察是否有重叠的子问题来确认。

### 3. 递归到动态规划：
- **记忆化搜索**：对于发现有重复解的递归函数，可以通过缓存已解决的子问题（记忆化）来避免重复计算。
- **严格表结构动态规划**：定义一个表格以缓存所有子问题的解，表的大小由参数的变化范围决定。确定依赖关系后，从基本案例开始填表，直到解决整个问题。对于有枚举行为的决策过程，进一步优化。

### 4. 进一步优化：
考虑以下优化策略，以提高动态规划的效率：
- **空间压缩**：尝试减少动态规划所需的空间复杂度，例如，通过滚动数组。
- **状态化简**：简化状态转移方程，减少不必要的状态。
- **四边形不等式**：在特定类型的问题中应用，以优化决策过程。
- **其他优化技巧**：根据问题特性，应用合适的数学和算法技巧。

# class24

## 1.滑动窗口概念

滑动窗口是一种常用的算法技术，主要用于处理数组或列表中的区间问题，例如寻找最大值或最小值、求解最长连续子数组或满足特定条件的子序列等。该技术通过在线性时间内处理这些问题，有效避免了采用嵌套循环所引发的高时间复杂度问题。

在实践中，滑动窗口涉及到维护一个窗口，这通常是数组或字符串中的一个连续子区间。根据具体问题的需求，窗口的两端可以向前滑动，以此遍历整个数组或字符串的所有子区间。在窗口滑动的过程中，可以实时更新和计算窗口内元素的统计信息，如元素之和、最大值或最小值。

窗口的右边界向右移动时（记为 R++），新的元素从右侧进入窗口。当窗口的左边界向右移动（记为 L++），则意味着元素从左侧离开窗口。在这一过程中，双端队列可以用于有效地维护窗口内的数据结构，特别是在需要快速获取最大值或最小值时。

例如，如果需要维护窗口中的最大值，我们可以让队列从头到尾部逆序排列。此时，新元素从尾部进入（即执行 R++ 操作），如果新元素大于尾部元素，就替换掉它。这样，窗口的最大值始终可以保持在队列的头部。最小值的维护采用类似的逻辑。

```java
while(!minWindow.isEmpty()&&arr[minWindow.peekLast()]>=arr[R]){
    minWindow.pollLast();
}
minWindow.add(R);
while(!maxWindow.isEmpty()&&arr[maxWindow.peekLast()]<=arr[R]){
    maxWindow.pollLast();
}
maxWindow.add(R);
if(L==minWindow.peekFirst()){
    minWindow.pollFirst();
}
if(L==maxWindow.peekFirst()){
    maxWindow.pollFirst();
}
```

通过这种方法，滑动窗口算法不仅提高了效率，还简化了数据的处理过程，使得对动态变化的数据区间问题可以快速响应和解决。

## 2. 滑动窗口的最大值
**题目：**给定一个整数数组 `arr` 和一个固定的窗口大小 `W`，随着窗口从数组的左端滑动到右端，需要返回每次滑动后窗口中的最大值。

**分析：** 本实现通过创建一个双端队列来维护窗口内的最大值状态。这里，`LinkedList<Integer>` 被用作双端队列（`queueMax`），用于存储元素的索引，而非元素的实际值。此方法确保了在窗口滑动过程中，窗口的最大值可以迅速更新。

对于窗口的维护，在窗口右端每向右移动一步时（即每次循环），首先从队尾开始，移除所有不大于当前元素 `arr[R]` 的元素的索引，这是因为新加入的元素比之前的元素出队列时间晚，并且还大于之前的元素，那么之前的元素就永远不可能成为最大值，保证队列中的元素索引对应的数组值是递减的。随后，当前元素的索引被加入队尾。如果队列头部的索引已经不在窗口中（即索引等于 `R-w`），则从队列头部移除该索引。这种处理确保了队列头部始终保留的是当前窗口中最大值的索引。

此外，使用索引而非值存储在队列中，可以方便地维护和调整窗口的移动，即通过索引快速访问数组中的值，并对窗口进行相应的更新。这种方式不仅提高了窗口操作的效率，也简化了代码的复杂性。

```java
package com.lxy.class24;

import java.util.LinkedList;

public class SlidingWindowMaxArray {
    public static int[] slidingWindowMaxArray(int[] arr, int w) {
        if(arr==null|| w < 1 || arr.length < w){
            return null;
        }
        LinkedList<Integer> queueMax=new LinkedList<>();
        int[]res=new int[arr.length-w+1];
        int index=0;
        for (int R = 0; R < arr.length; R++) {
            while(!queueMax.isEmpty()&& arr[queueMax.peekLast()]<=arr[R]){
                queueMax.pollLast();
            }
            queueMax.add(R);
            if(queueMax.peekFirst()==R-w){
                queueMax.pollFirst();
            }
            if(R>=w-1){
                res[index++]=arr[queueMax.peekFirst()];
            }
        }
        return res;
    }
    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * (maxValue + 1));
        }
        return arr;
    }
}
```

## 3. 最大最小值差的子数组
**题目：**给定一个整型数组 `arr` 和一个整数 `num`。数组中的子数组 `sub` 满足条件：`sub` 中的最大值和最小值之差不大于 `num`。需要返回满足此条件的子数组的数量。

**分析：**为了有效地维护子数组的最大值和最小值，我们采用了两个滑动窗口：一个用于追踪最大值，另一个用于追踪最小值。

首先，我们需要认识到当数组范围扩大时，最大值只可能会变大，而最小值只可能会减少，因此最大值与最小值之差只可能变大；相反，当数组范围缩小时，最大值只可能变小，最小值只能变大，最大值与最小值之差只可能减小。基于这一观察，如果某个子数组不满足条件，那么在其边界进一步扩展的任何更大的子数组也同样不会满足条件，同样如果某个子数组满足条件，那么边界进一步减小仍满足条件。

我们定义子数组的边界为 `[L, R)`，其中 `L` 是子数组的起始点，`R` 是终点（不包括 `R`）。在遍历过程中，`L` 从 0 至 `n-1`，并且对每一个 `L`，`R` 逐步向右移动。我们使用滑动窗口技术来记录此时窗口内的最大值和最小值。如果在某个点窗口不再满足条件（即 `max - min > num`），`R` 停止移动。

此时，以 `L` 开始的、满足条件的子数组数量等于 `R-L`。值得注意的是，如果 `R` 没有移动，这表示当前窗口的范围在缩小，但是依然可能满足条件，因为减小的数组范围可以导致最大值与最小值之差减小。同时，我们需要检查窗口的边界索引，判断是否需要将窗口的头部元素移出窗口。

整个遍历过程结束后，我们可以得到所有满足条件的子数组数量。该方法的时间复杂度为 O(n)，因为每个元素最多进入和退出窗口各一次，确保了效率。

```java
package com.lxy.class24;

import java.util.LinkedList;

public class AllLessNumSubArray {
    public static int allLessNumSubArray(int[] arr, int num) {
        if (arr == null || arr.length == 0 || num < 0) {
            return 0;
        }
        int N = arr.length;
        int count = 0;
        LinkedList<Integer> maxWindow = new LinkedList<>();
        LinkedList<Integer> minWindow = new LinkedList<>();
        int R=0;
        for (int L = 0; L < N; L++) {
            while(R<N){
                while(!minWindow.isEmpty()&&arr[minWindow.peekLast()]>=arr[R]){
                    minWindow.pollLast();
                }
                minWindow.add(R);
                while(!maxWindow.isEmpty()&&arr[maxWindow.peekLast()]<=arr[R]){
                    maxWindow.pollLast();
                }
                maxWindow.add(R);
                if(arr[maxWindow.peekFirst()]-arr[minWindow.peekFirst()]<=num){
                    R++;
                }else{
                    break;
                }
            }
            count+=R-L;
            if(L==minWindow.peekFirst()){
                minWindow.pollFirst();
            }
            if(L==maxWindow.peekFirst()){
                maxWindow.pollFirst();
            }
        }
        return count;
    }
}
```

## 4. 加油站的良好出发点
**题目：**有一系列加油站，每个加油站有一定量的汽油，并且到下一个加油站有一定的距离。问题是找到一个加油站作为起点，车辆能够绕一圈回到起点。

**分析：** 这个问题在一个环形路线上寻找能够作为起点并成功环绕一圈回到出发点的加油站。核心思想是利用前缀和数组追踪从任意加油站出发时的累计油量状态，并通过扩展这一前缀和数组来模拟环形路径。

1. **计算每站的净油量**：首先计算每个加油站的净油量 `rest[i] = gas[i] - distance[i]`，这表示从第 `i` 个加油站出发到达下一个加油站后剩余的油量。这是构建前缀和数组的基础。

2. **模拟环形路径的前缀和**：构建一个基本的前缀和数组 `prefix`，其中 `prefix[i]` 累加了从起点到第 `i` 个加油站的净油量。为了模拟环形路线，并处理从任意加油站出发的情况，我们将 `rest` 数组再次累加到 `prefix` 数组后，从而将其长度扩展到原来的两倍。这样，`prefix[i + n] - prefix[i]` 表示从任一加油站 `i` 出发，经过一圈后回到该起点的油量状态。

3. **有效性的判断**：核心判断基于扩展的前缀和数组。检查从任一起点 `i` 开始的下一个 `n` 个加油站构成的子数组中的最小前缀和是否大于等于零。如果是，表示从该加油站出发可以成功环绕一圈回到起点。

4. **应用滑动窗口技术**：为了提高计算效率，我们使用滑动窗口来维护每个可能起点的 `n` 个加油站的最小前缀和。这种方法避免了为每个起点重复计算，将整个过程的时间复杂度优化至 O(n)。

通过上述技术，我们不仅确保了算法的准确性，还大幅提升了效率，特别适合处理大规模数据集。这种结合前缀和与滑动窗口的策略，为环形数组问题提供了一个高效且直观的解决方案。

```java
package com.lxy.class24;

import java.util.LinkedList;

public class GasStation {
    public static boolean[] gasStation(int[] gas, int[] distance) {
        int n = gas.length;
        boolean[] ans=new boolean[n];
        int m=n<<1;
        int[] prefix=new int[m];
        for (int i = 0; i < n; i++) {
            prefix[i]=gas[i]-distance[i];
            prefix[i+n]=gas[i]-distance[i];
        }
        //前缀和
        for (int i = 1; i < m; i++) {
            prefix[i]+=prefix[i-1];
        }
        LinkedList<Integer> windowMin=new LinkedList<>();
        for (int i = 0; i < n; i++) {
            while (!windowMin.isEmpty() && prefix[windowMin.peekLast()] >= prefix[i]) {
                windowMin.pollLast();
            }
            windowMin.addLast(i);
        }
        int R=n;
        int pre=0;
        int index=0;
        while(R<m){
            if(prefix[windowMin.peekFirst()]-pre>=0){
                ans[index]=true;
            }
            while (!windowMin.isEmpty() && prefix[windowMin.peekLast()] >= prefix[R]) {
                windowMin.pollLast();
            }
            windowMin.add(R);
            if(index==windowMin.peekFirst()){
                windowMin.pollFirst();
            }
            pre=prefix[index];
            index++;
            R++;
        }
        return ans;
    }
}
```

## 5. 最少货币数组合
**题目**给定一个正整数数组 `arr`，代表不同面额的货币，和一个正整数 `aim`，表示目标金额。每种面额的货币可以使用任意次数。需要计算出组成目标金额的最少货币数。

**分析：**本代码首先处理一个经典的背包问题，通过递归方法考虑每种硬币的使用情况。在此过程中，数组 `arr` 被分析以确定每种硬币的面额及其对应的数量，这是对输入数据的一种优化整理。在递归解法中，特别重要的是处理基准情况，即当索引 `index` 等于 `value` 数组的长度时，此时需要检查剩余金额 `rest`。如果 `rest` 为零，则返回零表示找到了一个有效的硬币组合；否则返回 `Integer.MAX_VALUE`，表示无法组合出目标金额。这一处理是关键的，因为它直接影响了递归过程中上层的决策判断。

对于动态规划的实现，代码巧妙地采用了将下一行的同列值直接赋给当前行的同列的策略，这个操作反映了一个基础的状态转移——即考虑不使用当前硬币的情况。这种做法不仅保证了状态转移的完整性，还有效减少了变量的冗余使用，增强了代码的效率和可读性。每一次迭代更新都是基于前一状态的最优解，从而确保了动态规划解法的正确性和高效性。

```java
public class MinCoinsOnePaper {
    public static class Info {
        public int[] value;
        public int[] count;

        public Info(int[] value, int[] count) {
            this.value = value;
            this.count = count;
        }
    }

    public static int minCoins(int[] coins, int aim) {
        if (aim == 0) {
            return 0;
        }
        Info info = getInfo(coins);
        int[] counts = info.count;
        int[] value = info.value;
        return process(value,counts,0,aim);
    }
    public static int process(int[]value,int[]counts,int index,int rest){
        if(index==value.length){
            return rest==0?0:Integer.MAX_VALUE;
        }
        int min=Integer.MAX_VALUE;
        for (int  count= 0;  count<=counts[index]&&count*value[index]<=rest ; count++) {
            int next=process(value,counts,index+1,rest-count*value[index]);
            if(next!=Integer.MAX_VALUE){
                min=Math.min(min,next+count);
            }
        }
        return min;
    }
    public static int minCoinsByDp(int[] coins, int aim) {
        if (aim == 0) {
            return 0;
        }
        Info info = getInfo(coins);
        int[] counts = info.count;
        int[] value = info.value;
        int n = value.length;
        int[][] dp=new int[n+1][aim+1];
        dp[n][0]=0;
        for (int rest = 1; rest <= aim; rest++) {
            dp[n][rest] = Integer.MAX_VALUE;
        }
        for (int index = n-1; index >=0 ; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest]=dp[index+1][rest];
                for (int count= 1;  count<=counts[index]&&count*value[index]<=rest ; count++) {
                    if(dp[index+1][rest-count*value[index]]!=Integer.MAX_VALUE){
                        dp[index][rest]=Math.min(dp[index][rest],dp[index+1][rest-count*value[index]]+count);
                    }
                }
            }
        }
        return dp[0][aim];
    }
    public static Info getInfo(int[] coins) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int c : coins) {
            if (!map.containsKey(c)) {
                map.put(c, 1);
            } else {
                map.put(c, map.get(c) + 1);
            }
        }
        int[] value = new int[map.size()];
        int[] count = new int[map.size()];
        int index = 0;
        for (Entry<Integer, Integer> entry : map.entrySet()) {
            value[index] = entry.getKey();
            count[index] = entry.getValue();
            index++;
        }
        return new Info(value, count);
    }
}
```

当硬币的使用数量受限时，不能简单地对所有可能的金额进行更新，因为每种硬币的使用次数受到限制。这意味着，对于每种硬币，可能的使用次数形成了一个「窗口」，这个窗口随着目标金额的增加而滑动。因此，可以使用一个滑动窗口来维护每个金额状态所需的最小硬币数。

**窗口的更新逻辑：**

1. **最小值窗口的维护：** 使用双端队列来维护当前金额能够达到的最小硬币数的索引。窗口中的值表示在不超过硬币使用次数的条件下，达到某个特定金额的最小硬币数。
2. **补偿计算：** 因为窗口维护的是索引，所以在计算最小硬币数时需要进行补偿。补偿的大小为 `(rest - 窗口中的索引) / value[index]`，这表示从窗口中的金额到当前金额所需要额外增加的硬币数，即当前状态下使用的货币数量。

**队尾进数：**

- 在队尾添加新的金额索引前，需要比较新索引对应的硬币数是否小于队尾的值。如果新计算的硬币数更少，那么可以替换队尾的值，这样做可以保证窗口始终包含最优的金额状态。

- 在更新窗口时，如果队列中的值因硬币数量限制而变得无效（即为 `Integer.MAX_VALUE`），这些值应从队尾移除。这是因为无效值可能会阻碍窗口正确地反映最小硬币数。

在填充动态规划表时，需要继续关注无效值。如果从窗口中得到的最小值是无效的（即 `Integer.MAX_VALUE`），当前金额的状态也应该设置为无效。这样可以避免无效状态影响后续的计算。

在处理金额时，应该根据硬币的面额 `value[index]` 逐步增加，确保每一步都基于可行的硬币组合进行更新。此外，处理余额时务必确保总额不超过目标金额 `aim`，以防止进行无效或冗余的计算。因此取其最小值，这种方法确保了遍历过程的效率和准确性，避免了不必要的资源浪费。

```java
public static int minCoinsByDp1(int[] coins, int aim) {
        if (aim == 0) {
            return 0;
        }
        Info info = getInfo(coins);
        int[] counts = info.count;
        int[] value = info.value;
        int n = value.length;
        int[][]dp=new int[n+1][aim+1];
        dp[n][0]=0;
        for (int rest = 1; rest <=aim; rest++) {
            dp[n][rest]=Integer.MAX_VALUE;
        }
        for (int index = n-1; index >=0 ; index--) {

            for (int mod = 0; mod < Math.min(aim+1,value[index]); mod++) {
                LinkedList<Integer> w=new LinkedList<>();
                w.add(mod);
                dp[index][mod]=dp[index+1][mod];
                for (int rest = mod+value[index]; rest <=aim ; rest+=value[index]) {
                    while(!w.isEmpty()&&(dp[index+1][w.peekLast()]==Integer.MAX_VALUE||dp[index+1][w.peekLast()]+(rest-w.peekLast())/value[index]>=dp[index+1][rest])){
                        w.pollLast();
                    }
                    w.addLast(rest);
                    if(w.peekFirst()==rest-(counts[index]+1)*value[index]){
                        w.pollFirst();
                    }
                    if(dp[index+1][w.peekFirst()]!=Integer.MAX_VALUE){
                        dp[index][rest]=dp[index+1][w.peekFirst()]+(rest-w.peekFirst())/value[index];
                    }else{
                        dp[index][rest]=Integer.MAX_VALUE;
                    }
                }
            }
        }
        return dp[0][aim];
    }
```

总结：

![cc59c3bc08a84792db87a118e96d751](D:\笔记\算法\image\cc59c3bc08a84792db87a118e96d751.jpg)

# class25

## 1.单调栈

单调栈是一种专门为解决特定问题而设计的数据结构，特别适用于处理以下类型的数组问题：

假设有一个数组 `arr`，该数组可能包含重复的元素。对于数组中任一位置 `i` 的元素 `arr[i]`，我们通常需要确定两类关键信息：
1. **左侧邻近最小（或最大）元素**：在 `i` 的左侧，哪个最接近的元素比 `arr[i]` 小（或大）？
2. **右侧邻近最小（或最大）元素**：在 `i` 的右侧，哪个最接近的元素比 `arr[i]` 小（或大）？

目标是找到一种方法，可以尽可能高效地为数组 `arr` 中的每个位置 `i` 提供这两项信息。使用单调栈，我们可以在 O(n) 的时间复杂度内完成这一任务，因为每个元素最多只被处理两次（一次推入栈，一次弹出栈）。这种方法不仅提高了数据处理的速度，还优化了整个查询过程的效率。

**单调栈实现（查找邻近较小值）**

**分析：** 要为数组中每个位置 `i` 找到左右邻近的小于 `arr[i]` 的元素，可以有效地使用单调栈结构来完成。这种方法的时间复杂度为 \(O(N)\)，即只需要线性时间。具体操作流程如下：

1. **栈操作**：遍历数组中的每个元素，将其索引 `i` 压入栈中。在压入之前，首先检查栈顶元素。如果栈不为空且栈顶元素对应的数组值大于当前元素 `arr[i]`，则说明栈顶元素的右侧邻近较小值已找到，即为当前考虑的元素 `arr[i]`，将栈顶元素弹出，标记右侧邻近较小值。
2. **确定左侧邻近较小值**：当栈顶元素弹出后，新的栈顶元素（如果存在）即为该位置左侧的邻近较小值。如果栈为空，则表示左侧没有较小值，因此赋值为 -1。
3. **处理剩余元素**：数组所有元素遍历完成后，栈中可能仍有元素。这些元素的右侧不存在较小值，因此对于这些仍在栈中的索引，其右侧邻近较小值应赋值为 -1。对于左侧邻近较小值，如果栈顶元素下面还有元素，则为该栈顶下面的元素，否则为 -1。

这种单调栈的应用不仅高效而且简洁，能够在遍历数组一次的过程中解决问题。通过维护一个单调递增的栈结构，可以确保每个元素的索引被及时处理，从而快速定位到每个元素左右两侧的邻近较小值。

注意此方法主要是针对无重复值的情况。

```java
package com.lxy.class25;

import java.util.ArrayList;
import java.util.Stack;
import java.util.function.LongFunction;

public class MonotonousStack {
    public static int[][] getNearLessNoRepeat(int[] arr) {
        int n=arr.length;
        int[][]res=new int[n][2];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            while(!stack.isEmpty()&&arr[stack.peek()]>arr[i]){
                int index=stack.pop();
                int leftLessIndex=stack.isEmpty()?-1:stack.peek();
                res[index][1]=i;
                res[index][0]=leftLessIndex;
            }
            stack.push(i);
        }
        while(!stack.isEmpty()){
            int index=stack.pop();
            res[index][1]=-1;
            res[index][0]=stack.isEmpty()?-1:stack.peek();
        }
        return res;
    }
}
```

在实现单调栈时，处理包含重复值的数组需要特别的结构调整。为了有效处理重复数据，我们可以修改栈结构以存储索引的链表（或列表）。这种方法保证了即使数组中有重复值，我们也能准确找到每个元素的左右邻近较小值。

1. **栈的处理**：
    - **遍历数组**：逐个处理数组中的每个元素，将它们的索引 `i` 压入栈中。
    - **条件检查**：在将索引压入栈之前，检查栈顶元素。如果栈不为空，并且栈顶的链表中任一位置（通常取第一个，因为所有位置的值相同）的元素值大于当前元素 `arr[i]`，则说明找到了栈顶元素链表中所有索引的右侧邻近较小值，即为当前元素 `arr[i]`。

2. **确定左侧邻近较小值**：
    - **弹出操作**：一旦确定了右侧邻近较小值，栈顶元素（链表）将被弹出。此时，如果栈不为空，新的栈顶元素链表的最后一个索引（尾部）即表示弹出元素的左侧邻近较小值的位置。
    - **无左侧值处理**：如果栈为空，则表示没有左侧较小值，赋值为 -1。

3. **元素压栈**：
    - **重复值处理**：如果当前元素 `arr[i]` 等于栈顶元素链表中的值，直接将索引 `i` 添加到栈顶链表中。
    - **新链表创建**：如果 `arr[i]` 不等于栈顶元素，或栈为空，则创建一个新的链表，将索引 `i` 添加到链表中，并将链表压入栈。

4. **处理剩余元素**：
    - **栈清空**：遍历完成后，栈内可能仍存有未处理的元素。对这些元素，由于它们的右侧没有较小值，它们的右侧邻近较小值应赋值为 -1。
    - **左侧较小值赋值**：对于左侧邻近较小值，如果栈顶元素下方还有其他元素，则取下方元素链表的最后一个索引，否则赋值为 -1。

这种单调栈的实现方式不仅能有效处理数组中的重复元素，还能在线性时间内完成对每个元素左右邻近较小值的查找，优化了算法的效率和实用性。

```java
 public static int[][] getNearLess(int[] arr) {
        int n=arr.length;
        int[][]res=new int[n][2];
        Stack<ArrayList<Integer>> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            while(!stack.isEmpty()&&arr[stack.peek().get(0)]>arr[i]){
                ArrayList<Integer> pop = stack.pop();
                int leftLessIndex=stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);
                for(Integer index:pop){
                    res[index][1]=i;
                    res[index][0]=leftLessIndex;
                }
            }
            if(!stack.isEmpty() &&arr[stack.peek().get(0)]==arr[i]){
                stack.peek().add(i);
            }else{
                ArrayList<Integer> list = new ArrayList<>();
                list.add(i);
                stack.push(list);
            }
        }
        while(!stack.isEmpty()){
            ArrayList<Integer> pop= stack.pop();
            int leftLessIndex=stack.isEmpty()?-1:stack.peek().get(stack.peek().size()-1);
            for(Integer index:pop){
                res[index][1]=-1;
                res[index][0]= leftLessIndex;
            }
        }
        return res;
    }
```

## 2. 子数组的最大乘积值
**题目**: 给定一个只包含正数的数组 `arr`，对于 `arr` 中的任何一个子数组 `sub`，可以计算 `(sub累加和) * (sub中的最小值)`。请找出所有子数组中，这个乘积值最大的一个，并返回这个最大值。

**分析：**在解析子数组的最大乘积值问题时，我们关注的是计算每个可能子数组的累加和与该子数组中的最小值的乘积。本问题的关键在于快速确定以数组中任一位置 `i` 为最小值时，该子数组的最大可能范围。为了实现这一点，我们可以利用单调栈的特性来高效地找出每个元素左右两侧的第一个较小值，这两个较小值之间的区间就是以 `i` 为最小值的子数组的最大范围。

**前缀和**：通过构建前缀和数组，我们可以在常数时间内计算任意子数组的累加和，这极大地提升了求解效率。

**子数组的最大乘积**：对于数组中的每一个元素 `arr[i]`，利用前缀和及单调栈确定的边界来计算以 `i` 为最小值的子数组的累加和，然后将这个和与 `arr[i]` 相乘得到一个乘积值。

**重复值**：尽管数组中可能存在重复值，单调栈的处理流程保证每个元素的位置都得到正确的处理。问题求解时聚焦于获取最大乘积值，重复元素的存在不会导致最终结果的误差，只会影响中间计算步骤的复杂度，因此不需要额外处理。

**时间复杂度**：由于每个元素最多被推入和弹出栈一次，整个算法的时间复杂度保持在 \(O(n)\)，使得这种方法在处理大规模数据时表现出色。

```java
package com.lxy.class25;

import java.util.Stack;

public class AllTimesMinToMax {
    public static long max(int[] arr) {
        int n = arr.length;
        long[]prefix=new long[n];
        prefix[0]=arr[0];
        for (int i = 1; i < n; i++) {
            prefix[i]=prefix[i-1]+arr[i];
        }
        Stack<Integer> stack=new Stack<>();
        long res=Long.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            while(!stack.isEmpty()&&arr[stack.peek()]>=arr[i]){
                int index=stack.pop();
                res=Math.max(res,(stack.isEmpty()?(prefix[i-1]):(prefix[i-1]-prefix[stack.peek()]))*arr[index]);
            }
            stack.push(i);
        }
        while(!stack.isEmpty()){
            int index=stack.pop();
            res=Math.max(res,(stack.isEmpty()?(prefix[n-1]):(prefix[n-1]-prefix[stack.peek()]))*arr[index]);
        }
        return res;
    }
}
```

## 3. 直方图的最大矩形面积
**题目**: 给定一个非负整数数组 `height`，它表示一个直方图（即每个元素表示柱子的高度）。请找出直方图中能够勾勒出的最大矩形的面积。

**分析：**为了解决最大矩形面积的问题，着重于计算以数组中每个位置 `i` 的高度为矩形的最小高度时，该矩形的最大可能面积。具体来说，任务是确定以 `i` 为高的矩形的最宽可能范围。通过使用单调栈技术，我们可以高效地确定每个元素左右两侧第一个比其小的元素的位置，这两个位置之间的距离即为以 `i` 为最小高度的矩形的最大宽度。

1. **计算最大矩形面积**：对于栈中的每个元素 `index`，当它被弹出时，表示找到了以 `arr[index]` 为最小高度的矩形的最大宽度范围。矩形的宽度由 `index` 左右两侧第一个较小元素的距离决定，高度即为 `arr[index]`。一旦确定了矩形的高度和宽度，计算面积变得直截了当：`高度 × 宽度`。在遍历所有元素的过程中，持续更新已发现的最大矩形面积。
2. **不需特别处理重复值**：由于单调栈的处理方式，即使数组中存在重复值，也不会影响最终结果的正确性。栈结构确保了每个元素及其对应的最大范围被正确识别和计算。

```java
package com.lxy.class25;

import java.util.Stack;

public class Code03_LargestRectangleInHistogram {
    public static int largestRectangleArea(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        int n=height.length;
        Stack<Integer> stack=new Stack<>();
        int res=Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            while(!stack.isEmpty()&&height[stack.peek()]>=height[i]){
                int index=stack.pop();
                int leftLessIndex=stack.isEmpty()?-1:stack.peek();
                res= Math.max(res,(i-1-leftLessIndex)*height[index]);
            }
            stack.push(i);
        }
        while(!stack.isEmpty()){
            int index=stack.pop();
            int leftLessIndex=stack.isEmpty()?-1:stack.peek();
            res= Math.max(res,(n-1-leftLessIndex)*height[index]);
        }
        return res;
    }
}
```

## 4. 最大全1子矩阵
**题目**: 给定一个二维数组 `matrix`，其中的元素非0即1。请找出所有由1组成的最大子矩阵，并返回该子矩阵内1的数量。

**分析：** 本问题可以被有效转换为一系列求直方图中最大矩形面积的子问题。具体方法是，将给定的二维数组的每一行视为直方图的底部，通过逐行累计高度，构建出每一行对应的直方图。然后，利用已经实现的直方图求最大矩形面积的方法，针对每一行计算可能形成的最大矩形面积。最终答案即为所有行计算出的最大矩形面积中的最大值。这种转换策略简化了问题的处理，使得可以重用求解直方图中最大矩形面积的高效算法。

```java
package com.lxy.class25;

import java.util.Stack;

public class Code04_MaximalRectangle {
    public static int maximalRectangle(char[][] map) {
        if (map == null || map.length == 0 || map[0].length == 0) {
            return 0;
        }
        int maxArea = 0;
        int[] height = new int[map[0].length];
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[0].length; j++) {
                height[j] = map[i][j] == '0' ? 0 : height[j] + 1;
            }
            maxArea = Math.max(largestRectangleArea(height), maxArea);
        }
        return maxArea;
    }

    public static int largestRectangleArea(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        int n = height.length;
        Stack<Integer> stack = new Stack<>();
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && height[stack.peek()] >= height[i]) {
                int index = stack.pop();
                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
                res = Math.max(res, (i - 1 - leftLessIndex) * height[index]);
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int index = stack.pop();
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
            res = Math.max(res, (n - 1 - leftLessIndex) * height[index]);
        }
        return res;
    }
}
```

## 5. 计算全1子矩阵的数量
**题目**: 给定一个二维数组 `matrix`，其中的元素非0即1。需要计算并返回由1组成的所有可能的子矩阵数量。

**分析：** 本问题解决策略旨在将问题转化为基于每一行 `i` 作为基底，计算由该行形成的矩阵中所有可能子矩阵的总数。更具体地，我们针对每行构成的直方图，进一步细分任务为计算每个位置 `i` 高度所能形成的所有子矩阵数量。因此，我们需要获得每个位置`i`的最大矩阵范围，借助单调栈确定每个高度的最大宽度 `L`，子矩阵的数量可通过计算 `L * (L+1) / 2` 来估算，再乘以 `height[i]` 得出最终结果。然而，这种方法存在重复计算的风险，尤其是在高度相同的连续列中。为避免此类重复，建议在相同高度的连续区段只在区段末端进行子矩阵数量的计算，而非在每个位置重复计算。因此，在实际计算过程中，乘以的系数不仅是高度 `height[i]`，而是需要从 `height[i]` 中减去其左右两侧较小值中的较大者。这种处理方式旨在减少计算冗余，确保计算的高效和精准。

```java
package com.lxy.class25;

import java.util.Stack;

public class Code05_CountSubMatricesWithAllOnes {
    public static int numSubMatrix(int[][] m) {
        if (m == null || m.length == 0 || m[0].length == 0) {
            return 0;
        }
        int r=m.length;
        int c=m[0].length;
        int[]height=new int[c];
        int num=0;
        for (int row = 0; row < r; row++) {
            for (int col = 0; col < c; col++) {
                height[col]=m[row][col]==1?height[col]+1:0;
            }
            num+=numSubMatrixBasedRow(height);
        }
        return num;
    }

    private static int numSubMatrixBasedRow(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        int n=height.length;
        Stack<Integer> stack=new Stack<>();
        int num=0;
        for (int i = 0; i < n; i++) {
            while(!stack.isEmpty()&&height[stack.peek()]>=height[i]){
                Integer index = stack.pop();
                if(height[index]>height[i]){
                    int leftLessIndex =stack.isEmpty()?-1:stack.peek();
                    int length=i-leftLessIndex-1;
                    int down=Math.max(height[i],leftLessIndex==-1?0:height[leftLessIndex]);
                    num+=length*(length+1)/2*(height[index]-down);
                }
            }
            stack.push(i);
        }
        while (!stack.isEmpty()){
            int index=stack.pop();
            int leftLessIndex =stack.isEmpty()?-1:stack.peek();
            int length=n-leftLessIndex-1;
            int down=leftLessIndex==-1?0:height[leftLessIndex];
            num+=length*(length+1)/2*(height[index]-down);
        }
        return num;
    }
}
```

# class26

### 1. 子数组最小值的累加和
**题目**：给定一个整数数组 `arr`，计算所有可能子数组的最小值之和。

**分析：** 本问题可以转化为寻找每个数组位置 `i` 对应的值作为子数组最小值时，这些子数组的最大可能范围。为此，我们采用单调栈来维护每个元素作为最小值的潜在区间。单调栈帮助我们确定每个元素左侧和右侧第一个小于该元素的位置，从而定义了以该元素为最小值的最大子数组的边界。每个这样的符合条件的子数组的个数由该元素左侧到其位置的距离乘以其位置到右侧边界的距离来确定。这种方法确保了我们能够精确计算出穿过位置 `i` 的所有有效子数组的数量。

对于数组中的重复值，处理方法需要确保计算的唯一性和正确性。当遇到重复值时，计算的区间应该只扩展到最后一个重复值之前的位置，以避免重复计算。这一点在实际实现中至关重要，因为它确保了每个子数组只被计算一次，从而防止了结果的重复累加。

这种通过单调栈解决问题的策略不仅效率高，而且在处理涉及数组区间的问题时具有很高的适用性。通过精确地界定每个元素作为最小值可能影响的子数组范围，我们能够有效地计算出所有可能的子数组最小值的累加和，确保了解决方案的准确性和高效性。

```java
package com.lxy.class26;

import java.util.Stack;
import java.util.function.LongFunction;

public class Code01_SumOfSubarrayMinimums {
    public static int subArrayMinSum(int[] arr) {
        if(arr==null||arr.length==0){
            return 0;
        }
        Stack<Integer> stack=new Stack<>();
        int res=0;
        for (int i = 0; i < arr.length; i++) {
            while(!stack.isEmpty()&&arr[stack.peek()]>=arr[i]){
                Integer index = stack.pop();
                int leftLessIndex=stack.isEmpty()?-1:stack.peek();
                res+=(index-leftLessIndex)*(i-index)*arr[index];
            }
            stack.push(i);
        }
        while(!stack.isEmpty()){
            Integer index = stack.pop();
            int leftLessIndex=stack.isEmpty()?-1:stack.peek();
            res+=(index-leftLessIndex)*(arr.length-index)*arr[index];
        }
        return res;
    }
}
```

### 2. 斐波那契数列的矩阵乘法实现
**题目**：实现斐波那契数列的矩阵乘法方式，计算并返回斐波那契数列中第 `n` 个数的值。

斐波那契数列是一个经典的数列，以0和1开始，之后的每个数都是前两个数的和。这个数列在编程和数学的众多问题中均有广泛应用。通常，斐波那契数列定义如下：

$  F(n) = F(n-1) + F(n-2)  $
$  F(1) = 1, \ F(2) = 1  $

虽然这个数列的递归定义非常直观，但使用递归方法计算大规模斐波那契数时效率较低，因为它涉及大量的重复计算。一个更高效的计算方法是使用**矩阵乘法**。

斐波那契数列可以通过矩阵的幂次运算来快速计算。具体而言，斐波那契数列的递推关系可以通过以下的矩阵关系表示：

$  
\begin{bmatrix}
F(n) &
F(n-1)
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}\begin{bmatrix}
F(n-1) &
F(n-2)
\end{bmatrix}
 $​

将上述矩阵式转换为：

$ 
\begin{bmatrix}
F(n) &
F(n-1)
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}^{n-2}
\begin{bmatrix}
F(2) &
F(1)
\end{bmatrix}
 $​

要优化计算  F(n) ，即求$  \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}  $​的  n-2  次方，我们使用快速幂算法来减少计算时间。快速幂算法通过二进制展开  n-2  来减少乘法次数。对于每次迭代，我们只对结果矩阵进行一次乘法运算：

**快速幂算法**：

- 定义$  A = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} $，然后求$  A^{n-2} $。
1. 初始化结果矩阵为单位矩阵 $(I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix} $。
2. 当$  n-2  $不为0时，检查 \$(n-2 $ 的最低位：
   - 如果最低位为1（即，$ n-2  $为奇数），则$ \(I = I \times A $。
   - 不论最低位是什么，每次迭代都计算$  A = A \times A $（矩阵自乘）。
   - 将 $ n-2  $右移一位。
3. 迭代直到$  n-2 = 0 $。

这种方法能够在$  O(\log n)  $的时间复杂度内计算出$  F(n) $​，是解决大规模斐波那契数问题的高效方式。

```java
package com.lxy.class26;

public class Code02_FibonacciProblem {
    // O(logN)
    public static int fibonacciProblem(int n) {
        if (n < 1) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        }
        // [ 1 ,1 ]
        // [ 1, 0 ]
        int[][] base = {
                { 1, 1 },
                { 1, 0 }
        };
        int[][] res = matrixPower(base, n - 2);
        return res[0][0] + res[1][0];
    }

    public static int[][] matrixPower(int[][] m, int p) {
        int[][] res = new int[m.length][m[0].length];
        for (int i = 0; i < res.length; i++) {
            res[i][i] = 1;
        }
        // res = 矩阵中的1
        int[][] t = m;// 矩阵1次方
        for (; p != 0; p >>= 1) {
            if ((p & 1) != 0) {
                res = product(res, t);
            }
            t = product(t, t);
        }
        return res;
    }
    // 两个矩阵乘完之后的结果返回
    public static int[][] product(int[][] a, int[][] b) {
        int n = a.length;
        int m = b[0].length;
        int k = a[0].length; // a的列数同时也是b的行数
        int[][] ans = new int[n][m];
        for(int i = 0 ; i < n; i++) {
            for(int j = 0 ; j < m;j++) {
                for(int c = 0; c < k; c++) {
                    ans[i][j] += a[i][c] * b[c][j];
                }
            }
        }
        return ans;
    }
}
```

总结：

如果一个递归关系除初始项外具有以下形式：

$ F(N) = C_1 \times F(N-1) + C_2 \times F(N-2) + \ldots + C_k \times F(N-k) $

其中 \( C_1, C_2, \ldots, C_k \) 和 \( k \) 都是常数，并且递归表达式是固定的、不依赖于其他变量或条件，那么这种递归关系可以通过矩阵快速幂方法进行优化，将时间复杂度优化至 \( O(\log N) \)。

具体来说，我们可以将递归关系转化为矩阵乘法的形式，从而利用矩阵快速幂技术来加速计算。矩阵的形式表达如下：

$ \begin{bmatrix}
F(N) &
F(N-1) &
\dots &
F(N-k+1)
\end{bmatrix}
= \text{矩阵}^{N-k} \times \begin{bmatrix}
F(k) &
F(k-1) &
\dots &
F(1)
\end{bmatrix} $

这里的矩阵具体形式取决于递归系数$  C_1, C_2, \ldots, C_k $，并且这种方法允许我们在对数时间内计算出第 \( N \) 项的值，从而大幅提升计算效率。

### 3. 台阶问题的方法数

**题目**：一个人可以选择一次迈一个台阶或两个台阶。给定台阶总数 `N`，计算并返回这个人上 `N` 级台阶的所有可能方法数。

### 4. 牛的繁殖问题
**题目**：一个农场开始时有一只成熟的母牛A。考虑以下规则：每一只成熟的母牛每年会生一只母牛；每一只新生的母牛都在出生后第三年成熟；母牛永远不会死。计算并返回 `N` 年后农场的母牛总数。

### 5. 合规字符串的数量
**题目**：给定一个数字 `N`，构造长度为 `N` 的由字符 `0` 和 `1` 组成的所有可能的字符串。如果一个字符串中每个 `0` 字符的左侧都紧邻一个 `1`，则认为这个字符串是合规的。计算并返回所有合规字符串的数量。

### 6. 铺设瓷砖的方法数
**题目**：使用 `1x2` 的瓷砖填满 `N*2` 的区域。计算并返回所有可能的铺瓷砖方式的总数。

这些问题涉及到不同领域的典型算法挑战，从动态规划到矩阵乘法，以及组合计数问题。每个问题都提供了一种独特的视角来探索算法和数据结构的应用。

# class27

## 1.KMP

KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，由Donald Knuth、Vaughan Pratt 和 James H. Morris 在 1977 年共同发明。这种算法可以在 O(n + m) 的时间复杂度内完成搜索，其中 n 是文本字符串的长度，m 是模式字符串的长度。KMP 算法比传统的暴力匹配算法更高效，因为它通过避免不必要的比较来减少回溯。

KMP 算法的核心在于预处理模式字符串以创建一个部分匹配表（也称为 "前缀函数" 或 "π函数"）。这个表用于在不匹配的情况下确定搜索的下一位置，从而避免从头开始匹配。

1. **前缀表（Partial Match Table）的构建**:
   - 前缀表记录了模式字符串中前缀与后缀的最长公共元素长度。
   - 对于模式字符串中的每个子串，计算其前缀与后缀最长的公共元素长度，并存储在表中。
   - 这个表会在匹配过程中用来决定下一步的跳转位置。
2. **字符串匹配过程**:
   - 使用前缀表，KMP 算法在文本字符串中移动模式字符串。
   - 比较文本字符串和模式字符串的字符，当发现字符不匹配时，使用前缀表中的值来决定模式字符串的新位置。
   - 如果模式字符串中的字符与文本字符串中的字符完全匹配，那么找到了一个匹配的位置。

实现KMP算法

**分析：**

**前缀表 (next) 的构建分析**

在 KMP 算法中，前缀表 (`next` 数组) 是一种关键的数据结构，它被用来在模式匹配过程中发生不匹配时优化跳转。对于模式字符串 `s2` 中的每个位置 `i`，`next[i]` 的值并不直接依赖于该位置的字符，而是与位置 `i-1` 的 `next[i-1]` 值密切相关。这里 `next[i-1]` 记为 `cur`，其中 `cur` 表示前缀与后缀的最长公共元素长度，也是最大前缀区间的下一个位置。如果 `s2[i-1]` 与 `s2[cur]` 相等，则表明可以在 `s2[i-1]` 的基础上扩展匹配的前缀和后缀，因此 `next[i]` 应更新为 `cur + 1`。

**字符匹配过程分析**

有了前缀表，KMP 算法在进行字符串匹配时能够有效减少不必要的比较和回溯。在匹配过程中，使用两个指针 `i1` 和 `i2` 分别遍历文本字符串 `s1` 和模式字符串 `s2`：

- 当 `s1[i1]` 与 `s2[i2]` 匹配时，两个指针都向前移动。
- 如果发生不匹配，`i2` 则跳转到 `next[i2]` 指示的位置。这个跳转是基于 `s2` 在 `i2` 之前的部分已经与 `s1` 中的某段相匹配，并且根据前缀表，`s2` 中最长的有效前缀将是下一个最有可能匹配的开始位置。
- 如果 `next[i2]` 为 -1，即使 `s2` 回到了起始位置仍不匹配，`i1` 也需要向前移动以尝试下一个新的匹配开始位置。
- 循环会在 `i1` 或 `i2` 超出字符串长度时结束。匹配成功的条件是 `i2` 完全遍历了模式字符串 `s2`，此时，匹配开始的位置为 `i1 - i2`。

```java
package com.lxy.class27;

public class Code01_KMP {
    public static int kmp(String s1,String s2){
        if (s1 == null || s2 == null || s2.isEmpty() || s1.length() < s2.length()) {
            return -1;
        }
        int n=s1.length();
        int m=s2.length();
        int[]next=getNextArray(s2.toCharArray());
        int i1=0;
        int i2=0;
        char[]str1=s1.toCharArray();
        char[]str2=s2.toCharArray();
        while(i1<s1.length()&&i2<s2.length()){
            if (str1[i1]==str2[i2]){
                i1++;
                i2++;
            } else if (next[i2]==-1) {
                i1++;
            }else {
                i2=next[i2];
            }
        }
        return i2==s2.length()?i1-i2:-1;
    }

    private static int[] getNextArray(char[] str) {
        if (str.length == 1) {
            return new int[] { -1 };
        }
        int n=str.length;
        int[]next=new int[n];
        next[0]=-1;
        next[1]=0;
        int i=2;
        int cur=0;
        while(i<n){
            if(str[i-1]==str[cur]){
                next[i++]=++cur;
            } else if (cur>0) {
                cur=next[cur];
            }else{
                next[i++]=0;
            }
        }
        return next;
    }
}
```

## 2.判断二叉树子结构

**题目：**  给定两个二叉树的根节点 `head1` 和 `head2`，确定是否存在一个子树在 `head1` 中，其结构与 `head2` 完全相同。

**分析：**将二叉树序列化，KMP判断

```java
package com.lxy.class27;

import java.util.ArrayList;

public class Code02_TreeEqual {
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int v) {
            val = v;
        }
    }
    
    public static boolean isSubtree(TreeNode big, TreeNode small) {
        if (small == null) {
            return true;
        }
        if (big == null) {
            return false;
        }
        ArrayList<String> b = preSerial(big);
        ArrayList<String> s = preSerial(small);
        String[] str = new String[b.size()];
        for (int i = 0; i < str.length; i++) {
            str[i] = b.get(i);
        }

        String[] match = new String[s.size()];
        for (int i = 0; i < match.length; i++) {
            match[i] = s.get(i);
        }
        return getIndexOf(str, match) != -1;
    }

    public static ArrayList<String> preSerial(TreeNode head) {
        ArrayList<String> ans = new ArrayList<>();
        pres(head, ans);
        return ans;
    }

    public static void pres(TreeNode head, ArrayList<String> ans) {
        if (head == null) {
            ans.add(null);
        } else {
            ans.add(String.valueOf(head.val));
            pres(head.left, ans);
            pres(head.right, ans);
        }
    }

    public static int getIndexOf(String[] str1, String[] str2) {
        if (str1 == null || str2 == null || str1.length < 1 || str1.length < str2.length) {
            return -1;
        }
        int x = 0;
        int y = 0;
        int[] next = getNextArray(str2);
        while (x < str1.length && y < str2.length) {
            if (isEqual(str1[x], str2[y])) {
                x++;
                y++;
            } else if (next[y] == -1) {
                x++;
            } else {
                y = next[y];
            }
        }
        return y == str2.length ? x - y : -1;
    }

    public static int[] getNextArray(String[] ms) {
        if (ms.length == 1) {
            return new int[] { -1 };
        }
        int[] next = new int[ms.length];
        next[0] = -1;
        next[1] = 0;
        int i = 2;
        int cn = 0;
        while (i < next.length) {
            if (isEqual(ms[i - 1], ms[cn])) {
                next[i++] = ++cn;
            } else if (cn > 0) {
                cn = next[cn];
            } else {
                next[i++] = 0;
            }
        }
        return next;
    }

    public static boolean isEqual(String a, String b) {
        if (a == null && b == null) {
            return true;
        } else {
            if (a == null || b == null) {
                return false;
            } else {
                return a.equals(b);
            }
        }
    }
}
```

## 3. 旋转字符串判断

**题目：**  判断两个字符串 `str1` 和 `str2` 是否为旋转字符串。旋转字符串是指可以通过将字符串的某部分移动到另一端来得到另一个字符串。

**分析：**选择其一扩充至2倍，KMP算法判断。



```java
package com.lxy.class27;
public class Code03_IsRotation {

    public static boolean isRotation(String a, String b) {
        if (a == null || b == null || a.length() != b.length()) {
            return false;
        }
        String b2 = b + b;
        return getIndexOf(b2, a) != -1;
    }

    // KMP Algorithm
    public static int getIndexOf(String s, String m) {
        if (s.length() < m.length()) {
            return -1;
        }
        char[] ss = s.toCharArray();
        char[] ms = m.toCharArray();
        int si = 0;
        int mi = 0;
        int[] next = getNextArray(ms);
        while (si < ss.length && mi < ms.length) {
            if (ss[si] == ms[mi]) {
                si++;
                mi++;
            } else if (next[mi] == -1) {
                si++;
            } else {
                mi = next[mi];
            }
        }
        return mi == ms.length ? si - mi : -1;
    }

    public static int[] getNextArray(char[] ms) {
        if (ms.length == 1) {
            return new int[] { -1 };
        }
        int[] next = new int[ms.length];
        next[0] = -1;
        next[1] = 0;
        int pos = 2;
        int cn = 0;
        while (pos < next.length) {
            if (ms[pos - 1] == ms[cn]) {
                next[pos++] = ++cn;
            } else if (cn > 0) {
                cn = next[cn];
            } else {
                next[pos++] = 0;
            }
        }
        return next;
    }
}
```















